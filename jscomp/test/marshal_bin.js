//# 1 "marshal_test.bc.runtime.js"
// Generated by js_of_ocaml
(function
  (Object) {
  typeof globalThis
  !==
  "object"
  &&
  (this
    ? get()
    : (Object.defineProperty
      (Object.prototype, "_T_", { configurable: true, get: get }),
      _T_));
  function get() {
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_
  }
}
  (Object));
(function (globalThis) {
  "use strict";
  function caml_int64_is_zero(x) { return + x.isZero() }
  function caml_str_repeat(n, s) {
    if (n == 0) return "";
    if (s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for (; ;) {
      if (n & 1) r += s;
      n >>= 1;
      if (n == 0) return r;
      s += s;
      l++;
      if (l == 9) s.slice(0, 1)
    }
  }
  var caml_int64_offset = Math.pow(2, - 24);
  function caml_raise_constant(tag) { throw tag }
  var caml_global_data = [0];
  function caml_raise_zero_divide() { caml_raise_constant(caml_global_data.Division_by_zero) }
  function MlInt64(lo, mi, hi) { this.lo = lo & 0xffffff; this.mi = mi & 0xffffff; this.hi = hi & 0xffff }
  MlInt64.prototype.caml_custom = "_j";
  MlInt64.prototype.copy
    =
    function () { return new MlInt64(this.lo, this.mi, this.hi) };
  MlInt64.prototype.ucompare
    =
    function (x) {
      if (this.hi > x.hi) return 1;
      if (this.hi < x.hi) return - 1;
      if (this.mi > x.mi) return 1;
      if (this.mi < x.mi) return - 1;
      if (this.lo > x.lo) return 1;
      if (this.lo < x.lo) return - 1;
      return 0
    };
  MlInt64.prototype.compare
    =
    function (x) {
      var hi = this.hi << 16, xhi = x.hi << 16;
      if (hi > xhi) return 1;
      if (hi < xhi) return - 1;
      if (this.mi > x.mi) return 1;
      if (this.mi < x.mi) return - 1;
      if (this.lo > x.lo) return 1;
      if (this.lo < x.lo) return - 1;
      return 0
    };
  MlInt64.prototype.neg
    =
    function () {
      var lo = - this.lo, mi = - this.mi + (lo >> 24), hi = - this.hi + (mi >> 24);
      return new MlInt64(lo, mi, hi)
    };
  MlInt64.prototype.add
    =
    function (x) {
      var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo, mi, hi)
    };
  MlInt64.prototype.sub
    =
    function (x) {
      var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo, mi, hi)
    };
  MlInt64.prototype.mul
    =
    function (x) {
      var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo, mi, hi)
    };
  MlInt64.prototype.isZero
    =
    function () { return (this.lo | this.mi | this.hi) == 0 };
  MlInt64.prototype.isNeg = function () { return this.hi << 16 < 0 };
  MlInt64.prototype.and
    =
    function (x) { return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi) };
  MlInt64.prototype.or
    =
    function (x) { return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi) };
  MlInt64.prototype.xor
    =
    function (x) { return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi) };
  MlInt64.prototype.shift_left
    =
    function (s) {
      s = s & 63;
      if (s == 0) return this;
      if (s < 24)
        return new
          MlInt64
          (this.lo << s,
            this.mi << s | this.lo >> 24 - s,
            this.hi << s | this.mi >> 24 - s);
      if (s < 48)
        return new
          MlInt64
          (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0, 0, this.lo << s - 48)
    };
  MlInt64.prototype.shift_right_unsigned
    =
    function (s) {
      s = s & 63;
      if (s == 0) return this;
      if (s < 24)
        return new
          MlInt64
          (this.lo >> s | this.mi << 24 - s,
            this.mi >> s | this.hi << 24 - s,
            this.hi >> s);
      if (s < 48)
        return new
          MlInt64
          (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
      return new MlInt64(this.hi >> s - 48, 0, 0)
    };
  MlInt64.prototype.shift_right
    =
    function (s) {
      s = s & 63;
      if (s == 0) return this;
      var h = this.hi << 16 >> 16;
      if (s < 24)
        return new
          MlInt64
          (this.lo >> s | this.mi << 24 - s,
            this.mi >> s | h << 24 - s,
            this.hi << 16 >> s >>> 16);
      var sign = this.hi << 16 >> 31;
      if (s < 48)
        return new
          MlInt64
          (this.mi >> s - 24 | this.hi << 48 - s,
            this.hi << 16 >> s - 24 >> 16,
            sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32, sign, sign)
    };
  MlInt64.prototype.lsl1
    =
    function () {
      this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff
    };
  MlInt64.prototype.lsr1
    =
    function () {
      this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1
    };
  MlInt64.prototype.udivmod
    =
    function (x) {
      var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
      while (modulus.ucompare(divisor) > 0) { offset++; divisor.lsl1() }
      while (offset >= 0) {
        offset--;
        quotient.lsl1();
        if (modulus.ucompare(divisor) >= 0) { quotient.lo++; modulus = modulus.sub(divisor) }
        divisor.lsr1()
      }
      return { quotient: quotient, modulus: modulus }
    };
  MlInt64.prototype.div
    =
    function (y) {
      var x = this;
      if (y.isZero()) caml_raise_zero_divide();
      var sign = x.hi ^ y.hi;
      if (x.hi & 0x8000) x = x.neg();
      if (y.hi & 0x8000) y = y.neg();
      var q = x.udivmod(y).quotient;
      if (sign & 0x8000) q = q.neg();
      return q
    };
  MlInt64.prototype.mod
    =
    function (y) {
      var x = this;
      if (y.isZero()) caml_raise_zero_divide();
      var sign = x.hi;
      if (x.hi & 0x8000) x = x.neg();
      if (y.hi & 0x8000) y = y.neg();
      var r = x.udivmod(y).modulus;
      if (sign & 0x8000) r = r.neg();
      return r
    };
  MlInt64.prototype.toInt = function () { return this.lo | this.mi << 24 };
  MlInt64.prototype.toFloat
    =
    function () {
      return (this.hi << 16)
        *
        Math.pow(2, 32)
        +
        this.mi
        *
        Math.pow(2, 24)
        +
        this.lo
    };
  MlInt64.prototype.toArray
    =
    function () {
      return [this.hi >> 8,
      this.hi & 0xff,
      this.mi >> 16,
      this.mi >> 8 & 0xff,
      this.mi & 0xff,
      this.lo >> 16,
      this.lo >> 8 & 0xff,
      this.lo & 0xff]
    };
  MlInt64.prototype.lo32
    =
    function () { return this.lo | (this.mi & 0xff) << 24 };
  MlInt64.prototype.hi32
    =
    function () { return this.mi >>> 8 & 0xffff | this.hi << 16 };
  function caml_int64_of_int32(x) { return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff) }
  function caml_int64_to_int32(x) { return x.toInt() }
  function caml_int64_is_negative(x) { return + x.isNeg() }
  function caml_int64_neg(x) { return x.neg() }
  function caml_subarray_to_jsbytes(a, i, len) {
    var f = String.fromCharCode;
    if (i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for (; 0 < len; i += 1024, len -= 1024)
      s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s
  }
  function caml_convert_string_to_bytes(s) {
    if (s.t == 2)
      s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
      s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0
  }
  function caml_jsbytes_of_string(s) { s.t & 6 && caml_convert_string_to_bytes(s); return s.c }
  function caml_raise_with_arg(tag, arg) { throw [0, tag, arg] }
  function jsoo_is_ascii(s) {
    if (s.length < 24) {
      for (var i = 0; i < s.length; i++)if (s.charCodeAt(i) > 127) return false;
      return true
    }
    else
      return ! /[^\x00-\x7f]/.test(s)
  }
  function caml_utf16_of_utf8(s) {
    for (var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++) {
      c1 = s.charCodeAt(i);
      if (c1 < 0x80) {
        for (var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++);
        if (j - i > 512) { t.substr(0, 1); b += t; t = ""; b += s.slice(i, j) }
        else
          t += s.slice(i, j);
        if (j == l) break;
        i = j
      }
      v = 1;
      if (++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128) {
        c = c2 + (c1 << 6);
        if (c1 < 0xe0) { v = c - 0x3080; if (v < 0x80) v = 1 }
        else {
          v = 2;
          if (++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128) {
            c = c2 + (c << 6);
            if (c1 < 0xf0) {
              v = c - 0xe2080;
              if (v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2
            }
            else {
              v = 3;
              if
                (++i
                <
                l
                &&
                ((c2 = s.charCodeAt(i)) & - 64)
                ==
                128
                &&
                c1
                <
                0xf5) {
                v = c2 - 0x3c82080 + (c << 6);
                if (v < 0x10000 || v > 0x10ffff) v = 3
              }
            }
          }
        }
      }
      if (v < 4) { i -= v; t += "\ufffd" }
      else
        if (v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
        else
          t += String.fromCharCode(v);
      if (t.length > 1024) { t.substr(0, 1); b += t; t = "" }
    }
    return b + t
  }
  function MlBytes(tag, contents, length) { this.t = tag; this.c = contents; this.l = length }
  MlBytes.prototype.toString
    =
    function () {
      switch (this.t) {
        case 9: return this.c;
        default: caml_convert_string_to_bytes(this); case 0:
          if (jsoo_is_ascii(this.c)) { this.t = 9; return this.c } this.t = 8;
        case 8: return this.c
      }
    };
  MlBytes.prototype.toUtf16
    =
    function () {
      var r = this.toString();
      if (this.t == 9) return r;
      return caml_utf16_of_utf8(r)
    };
  MlBytes.prototype.slice
    =
    function () {
      var content = this.t == 4 ? this.c.slice() : this.c;
      return new MlBytes(this.t, content, this.l)
    };
  function caml_bytes_of_jsbytes(s) { return new MlBytes(0, s, s.length) }
  function caml_string_of_jsbytes(s) { return caml_bytes_of_jsbytes(s) }
  function caml_raise_with_string(tag, msg) { caml_raise_with_arg(tag, caml_string_of_jsbytes(msg)) }
  function caml_invalid_argument(msg) { caml_raise_with_string(caml_global_data.Invalid_argument, msg) }
  function caml_parse_format(fmt) {
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if (len > 31) caml_invalid_argument("format_int: format too long");
    var
      f =
      {
        justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"
      };
    for (var i = 0; i < len; i++) {
      var c = fmt.charAt(i);
      switch (c) {
        case "-": f.justify = "-"; break;
        case "+":
        case " ": f.signstyle = c; break;
        case "0": f.filler = "0"; break;
        case "#": f.alternate = true; break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          f.width = 0;
          while (c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) { f.width = f.width * 10 + c; i++ }
          i--;
          break;
        case ".":
          f.prec = 0;
          i++;
          while (c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) { f.prec = f.prec * 10 + c; i++ }
          i--;
        case "d":
        case "i": f.signedconv = true;
        case "u": f.base = 10; break;
        case "x": f.base = 16; break;
        case "X": f.base = 16; f.uppercase = true; break;
        case "o": f.base = 8; break;
        case "e":
        case "f":
        case "g": f.signedconv = true; f.conv = c; break;
        case "E":
        case "F":
        case "G":
          f.signedconv = true;
          f.uppercase = true;
          f.conv = c.toLowerCase();
          break
      }
    }
    return f
  }
  function caml_finish_formatting(f, rawbuffer) {
    if (f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if (f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if (f.alternate) { if (f.base == 8) len += 1; if (f.base == 16) len += 2 }
    var buffer = "";
    if (f.justify == "+" && f.filler == " ")
      for (var i = len; i < f.width; i++)buffer += " ";
    if (f.signedconv)
      if (f.sign < 0)
        buffer += "-";
      else
        if (f.signstyle != "-") buffer += f.signstyle;
    if (f.alternate && f.base == 8) buffer += "0";
    if (f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if (f.justify == "+" && f.filler == "0")
      for (var i = len; i < f.width; i++)buffer += "0";
    buffer += rawbuffer;
    if (f.justify == "-") for (var i = len; i < f.width; i++)buffer += " ";
    return caml_string_of_jsbytes(buffer)
  }
  function caml_int64_format(fmt, x) {
    var f = caml_parse_format(fmt);
    if (f.signedconv && caml_int64_is_negative(x)) { f.sign = - 1; x = caml_int64_neg(x) }
    var
      buffer = "",
      wbase = caml_int64_of_int32(f.base),
      cvtbl = "0123456789abcdef";
    do {
      var p = x.udivmod(wbase);
      x = p.quotient;
      buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer
    }
    while
      (!caml_int64_is_zero(x));
    if (f.prec >= 0) {
      f.filler = " ";
      var n = f.prec - buffer.length;
      if (n > 0) buffer = caml_str_repeat(n, "0") + buffer
    }
    return caml_finish_formatting(f, buffer)
  }
  function caml_expm1_float(x) { return Math.expm1(x) }
  function caml_ml_condition_broadcast(t) { return 0 }
  function caml_jsstring_of_string(s) { return s.toUtf16() }
  function fs_node_supported() {
    return typeof globalThis.process
      !==
      "undefined"
      &&
      typeof globalThis.process.versions
      !==
      "undefined"
      &&
      typeof globalThis.process.versions.node
      !==
      "undefined"
  }
  function make_path_is_absolute() {
    function posix(path) { if (path.charAt(0) === "/") return ["", path.substring(1)]; return }
    function win32(path) {
      var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
      if (Boolean(result[2] || isUnc)) {
        var root = result[1] || "", sep = result[2] || "";
        return [root, path.substring(root.length + sep.length)]
      }
      return
    }
    return fs_node_supported()
      &&
      globalThis.process
      &&
      globalThis.process.platform
      ? globalThis.process.platform === "win32" ? win32 : posix
      : posix
  }
  var path_is_absolute = make_path_is_absolute();
  function caml_trailing_slash(name) { return name.slice(- 1) !== "/" ? name + "/" : name }
  if (fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
  else
    var caml_current_dir = "/static";
  caml_current_dir = caml_trailing_slash(caml_current_dir);
  function caml_make_path(name) {
    name = caml_jsstring_of_string(name);
    if (!path_is_absolute(name)) name = caml_current_dir + name;
    var comp0 = path_is_absolute(name), comp = comp0[1].split("/"), ncomp = [];
    for (var i = 0; i < comp.length; i++)
      switch (comp[i]) {
        case "..": if (ncomp.length > 1) ncomp.pop(); break;
        case ".": break;
        case "": break;
        default: ncomp.push(comp[i]); break
      }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp
  }
  function caml_utf8_of_utf16(s) {
    for (var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++) {
      c = s.charCodeAt(i);
      if (c < 0x80) {
        for (var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++);
        if (j - i > 512) { t.substr(0, 1); b += t; t = ""; b += s.slice(i, j) }
        else
          t += s.slice(i, j);
        if (j == l) break;
        i = j
      }
      if (c < 0x800) {
        t += String.fromCharCode(0xc0 | c >> 6);
        t += String.fromCharCode(0x80 | c & 0x3f)
      }
      else
        if (c < 0xd800 || c >= 0xdfff)
          t
            +=
            String.fromCharCode
              (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
        else
          if
            (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
            t += "\xef\xbf\xbd";
          else {
            i++;
            c = (c << 10) + d - 0x35fdc00;
            t
              +=
              String.fromCharCode
                (0xf0 | c >> 18,
                  0x80 | c >> 12 & 0x3f,
                  0x80 | c >> 6 & 0x3f,
                  0x80 | c & 0x3f)
          }
      if (t.length > 1024) { t.substr(0, 1); b += t; t = "" }
    }
    return b + t
  }
  function caml_bytes_of_utf16_jsstring(s) {
    var tag = 9;
    if (!jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length)
  }
  function caml_string_of_jsstring(s) { return caml_bytes_of_utf16_jsstring(s) }
  var
    unix_error =
      ["E2BIG",
        "EACCES",
        "EAGAIN",
        "EBADF",
        "EBUSY",
        "ECHILD",
        "EDEADLK",
        "EDOM",
        "EEXIST",
        "EFAULT",
        "EFBIG",
        "EINTR",
        "EINVAL",
        "EIO",
        "EISDIR",
        "EMFILE",
        "EMLINK",
        "ENAMETOOLONG",
        "ENFILE",
        "ENODEV",
        "ENOENT",
        "ENOEXEC",
        "ENOLCK",
        "ENOMEM",
        "ENOSPC",
        "ENOSYS",
        "ENOTDIR",
        "ENOTEMPTY",
        "ENOTTY",
        "ENXIO",
        "EPERM",
        "EPIPE",
        "ERANGE",
        "EROFS",
        "ESPIPE",
        "ESRCH",
        "EXDEV",
        "EWOULDBLOCK",
        "EINPROGRESS",
        "EALREADY",
        "ENOTSOCK",
        "EDESTADDRREQ",
        "EMSGSIZE",
        "EPROTOTYPE",
        "ENOPROTOOPT",
        "EPROTONOSUPPORT",
        "ESOCKTNOSUPPORT",
        "EOPNOTSUPP",
        "EPFNOSUPPORT",
        "EAFNOSUPPORT",
        "EADDRINUSE",
        "EADDRNOTAVAIL",
        "ENETDOWN",
        "ENETUNREACH",
        "ENETRESET",
        "ECONNABORTED",
        "ECONNRESET",
        "ENOBUFS",
        "EISCONN",
        "ENOTCONN",
        "ESHUTDOWN",
        "ETOOMANYREFS",
        "ETIMEDOUT",
        "ECONNREFUSED",
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "ELOOP",
        "EOVERFLOW"];
  function make_unix_err_args(code, syscall, path, errno) {
    var variant = unix_error.indexOf(code);
    if (variant < 0) { if (errno == null) errno = - 9999; variant = [0, errno] }
    var
      args =
        [variant,
          caml_string_of_jsstring(syscall || ""),
          caml_string_of_jsstring(path || "")];
    return args
  }
  var caml_named_values = {};
  function caml_named_value(nm) { return caml_named_values[nm] }
  function caml_raise_with_args(tag, args) { throw [0, tag].concat(args) }
  function caml_is_ml_bytes(s) { return s instanceof MlBytes }
  function caml_is_ml_string(s) { return caml_is_ml_bytes(s) }
  function caml_bytes_of_array(a) {
    if (!(a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length)
  }
  function caml_bytes_of_string(s) { return s }
  function caml_raise_sys_error(msg) { caml_raise_with_string(caml_global_data.Sys_error, msg) }
  function caml_raise_no_such_file(name) { caml_raise_sys_error(name + ": No such file or directory") }
  function caml_convert_bytes_to_array(s) {
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for (; i < l; i++)a[i] = b.charCodeAt(i);
    for (l = s.l; i < l; i++)a[i] = 0;
    s.c = a;
    s.t = 4;
    return a
  }
  function caml_uint8_array_of_bytes(s) { if (s.t != 4) caml_convert_bytes_to_array(s); return s.c }
  function caml_create_bytes(len) {
    if (len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len)
  }
  function caml_ml_bytes_length(s) { return s.l }
  function caml_blit_bytes(s1, i1, s2, i2, len) {
    if (len == 0) return 0;
    if (i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)) {
      s2.c
      =
      s1.t == 4
        ? caml_subarray_to_jsbytes(s1.c, i1, len)
        : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
      s2.t = s2.c.length == s2.l ? 0 : 2
    }
    else
      if (s2.t == 2 && i2 == s2.c.length) {
        s2.c
        +=
        s1.t == 4
          ? caml_subarray_to_jsbytes(s1.c, i1, len)
          : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
        s2.t = s2.c.length == s2.l ? 0 : 2
      }
      else {
        if (s2.t != 4) caml_convert_bytes_to_array(s2);
        var c1 = s1.c, c2 = s2.c;
        if (s1.t == 4)
          if (i2 <= i1)
            for (var i = 0; i < len; i++)c2[i2 + i] = c1[i1 + i];
          else
            for (var i = len - 1; i >= 0; i--)c2[i2 + i] = c1[i1 + i];
        else {
          var l = Math.min(len, c1.length - i1);
          for (var i = 0; i < l; i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
          for (; i < len; i++)c2[i2 + i] = 0
        }
      }
    return 0
  }
  function MlFile() { }
  function MlFakeFile(content) { this.data = content }
  MlFakeFile.prototype = new MlFile();
  MlFakeFile.prototype.constructor = MlFakeFile;
  MlFakeFile.prototype.truncate
    =
    function (len) {
      var old = this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old, 0, this.data, 0, len)
    };
  MlFakeFile.prototype.length
    =
    function () { return caml_ml_bytes_length(this.data) };
  MlFakeFile.prototype.write
    =
    function (offset, buf, pos, len) {
      var clen = this.length();
      if (offset + len >= clen) {
        var new_str = caml_create_bytes(offset + len), old_data = this.data;
        this.data = new_str;
        caml_blit_bytes(old_data, 0, this.data, 0, clen)
      }
      caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
      return 0
    };
  MlFakeFile.prototype.read
    =
    function (offset, buf, pos, len) {
      var clen = this.length();
      if (offset + len >= clen) len = clen - offset;
      if (len) {
        var data = caml_create_bytes(len | 0);
        caml_blit_bytes(this.data, offset, data, 0, len);
        buf.set(caml_uint8_array_of_bytes(data), pos)
      }
      return len
    };
  function MlFakeFd(name, file, flags) { this.file = file; this.name = name; this.flags = flags }
  MlFakeFd.prototype.err_closed
    =
    function () { caml_raise_sys_error(this.name + ": file descriptor already closed") };
  MlFakeFd.prototype.length
    =
    function () { if (this.file) return this.file.length(); this.err_closed() };
  MlFakeFd.prototype.write
    =
    function (offset, buf, pos, len) {
      if (this.file) return this.file.write(offset, buf, pos, len);
      this.err_closed()
    };
  MlFakeFd.prototype.read
    =
    function (offset, buf, pos, len) {
      if (this.file) return this.file.read(offset, buf, pos, len);
      this.err_closed()
    };
  MlFakeFd.prototype.close = function () { this.file = undefined };
  function MlFakeDevice(root, f) { this.content = {}; this.root = root; this.lookupFun = f }
  MlFakeDevice.prototype.nm = function (name) { return this.root + name };
  MlFakeDevice.prototype.create_dir_if_needed
    =
    function (name) {
      var comp = name.split("/"), res = "";
      for (var i = 0; i < comp.length - 1; i++) {
        res += comp[i] + "/";
        if (this.content[res]) continue;
        this.content[res] = Symbol("directory")
      }
    };
  MlFakeDevice.prototype.slash
    =
    function (name) { return /\/$/.test(name) ? name : name + "/" };
  MlFakeDevice.prototype.lookup
    =
    function (name) {
      if (!this.content[name] && this.lookupFun) {
        var
        res =
          this.lookupFun
            (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
        if (res !== 0) {
          this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))
        }
      }
    };
  MlFakeDevice.prototype.exists
    =
    function (name) {
      if (name == "") return 1;
      var name_slash = this.slash(name);
      if (this.content[name_slash]) return 1;
      this.lookup(name);
      return this.content[name] ? 1 : 0
    };
  MlFakeDevice.prototype.mkdir
    =
    function (name, mode, raise_unix) {
      var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
      if (this.exists(name))
        if (unix_error)
          caml_raise_with_args
            (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
        else
          caml_raise_sys_error(name + ": File exists");
      var parent = /^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if (!this.exists(parent))
        if (unix_error)
          caml_raise_with_args
            (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
        else
          caml_raise_sys_error(parent + ": No such file or directory");
      if (!this.is_dir(parent))
        if (unix_error)
          caml_raise_with_args
            (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
        else
          caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))
    };
  MlFakeDevice.prototype.rmdir
    =
    function (name, raise_unix) {
      var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
      if (!this.exists(name))
        if (unix_error)
          caml_raise_with_args
            (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
        else
          caml_raise_sys_error(name + ": No such file or directory");
      if (!this.is_dir(name))
        if (unix_error)
          caml_raise_with_args
            (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
        else
          caml_raise_sys_error(name + ": Not a directory");
      for (var n in this.content)
        if (n.match(r))
          if (unix_error)
            caml_raise_with_args
              (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
          else
            caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]
    };
  MlFakeDevice.prototype.readdir
    =
    function (name) {
      var name_slash = name == "" ? "" : this.slash(name);
      if (!this.exists(name))
        caml_raise_sys_error(name + ": No such file or directory");
      if (!this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
      var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
      for (var n in this.content) {
        var m = n.match(r);
        if (m && !seen[m[1]]) { seen[m[1]] = true; a.push(m[1]) }
      }
      return a
    };
  MlFakeDevice.prototype.opendir
    =
    function (name, raise_unix) {
      var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
      return {
        readSync:
          function () {
            if (c)
              if (unix_error)
                caml_raise_with_args
                  (unix_error,
                    make_unix_err_args("EBADF", "closedir", this.nm(name)));
              else
                caml_raise_sys_error(name + ": closedir failed");
            if (i == a.length) return null;
            var entry = a[i];
            i++;
            return { name: entry }
          },
        closeSync:
          function () {
            if (c)
              if (unix_error)
                caml_raise_with_args
                  (unix_error,
                    make_unix_err_args("EBADF", "closedir", this.nm(name)));
              else
                caml_raise_sys_error(name + ": closedir failed");
            c = true;
            a = []
          }
      }
    };
  MlFakeDevice.prototype.is_dir
    =
    function (name) {
      if (name == "") return true;
      var name_slash = this.slash(name);
      return this.content[name_slash] ? 1 : 0
    };
  MlFakeDevice.prototype.unlink
    =
    function (name) {
      var ok = this.content[name] ? true : false;
      delete this.content[name];
      return ok
    };
  MlFakeDevice.prototype.open
    =
    function (name, f) {
      var file;
      if (f.rdonly && f.wronly)
        caml_raise_sys_error
          (this.nm(name)
            +
            " : flags Open_rdonly and Open_wronly are not compatible");
      if (f.text && f.binary)
        caml_raise_sys_error
          (this.nm(name)
            +
            " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if (this.content[name]) {
        if (this.is_dir(name))
          caml_raise_sys_error(this.nm(name) + " : is a directory");
        if (f.create && f.excl)
          caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if (f.truncate) file.truncate()
      }
      else
        if (f.create) {
          this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_create_bytes(0));
          file = this.content[name]
        }
        else
          caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name), file, f)
    };
  MlFakeDevice.prototype.open
    =
    function (name, f) {
      var file;
      if (f.rdonly && f.wronly)
        caml_raise_sys_error
          (this.nm(name)
            +
            " : flags Open_rdonly and Open_wronly are not compatible");
      if (f.text && f.binary)
        caml_raise_sys_error
          (this.nm(name)
            +
            " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if (this.content[name]) {
        if (this.is_dir(name))
          caml_raise_sys_error(this.nm(name) + " : is a directory");
        if (f.create && f.excl)
          caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if (f.truncate) file.truncate()
      }
      else
        if (f.create) {
          this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_create_bytes(0));
          file = this.content[name]
        }
        else
          caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name), file, f)
    };
  MlFakeDevice.prototype.register
    =
    function (name, content) {
      var file;
      if (this.content[name])
        caml_raise_sys_error(this.nm(name) + " : file already exists");
      if (caml_is_ml_bytes(content)) file = new MlFakeFile(content);
      if (caml_is_ml_string(content))
        file = new MlFakeFile(caml_bytes_of_string(content));
      else
        if (content instanceof Array)
          file = new MlFakeFile(caml_bytes_of_array(content));
        else
          if (typeof content === "string")
            file = new MlFakeFile(caml_bytes_of_jsbytes(content));
          else
            if (content.toString) {
              var
              bytes =
                caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
              file = new MlFakeFile(bytes)
            }
      if (file) { this.create_dir_if_needed(name); this.content[name] = file }
      else
        caml_raise_sys_error
          (this.nm(name) + " : registering file with invalid content type")
    };
  MlFakeDevice.prototype.constructor = MlFakeDevice;
  function caml_ml_string_length(s) { return caml_ml_bytes_length(s) }
  function caml_bytes_unsafe_get(s, i) {
    switch (s.t & 6) {
      default: if (i >= s.c.length) return 0; case 0: return s.c.charCodeAt(i);
      case 4: return s.c[i]
    }
  }
  function caml_string_unsafe_get(s, i) { return caml_bytes_unsafe_get(s, i) }
  function caml_uint8_array_of_string(s) {
    var l = caml_ml_string_length(s), a = new Array(l), i = 0;
    for (; i < l; i++)a[i] = caml_string_unsafe_get(s, i);
    return a
  }
  function caml_bytes_bound_error() { caml_invalid_argument("index out of bounds") }
  function caml_bytes_unsafe_set(s, i, c) {
    c &= 0xff;
    if (s.t != 4) {
      if (i == s.c.length) { s.c += String.fromCharCode(c); if (i + 1 == s.l) s.t = 0; return 0 }
      caml_convert_bytes_to_array(s)
    }
    s.c[i] = c;
    return 0
  }
  function caml_bytes_set(s, i, c) {
    if (i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c)
  }
  function MlNodeFd(fd, flags) { this.fs = require("fs"); this.fd = fd; this.flags = flags }
  MlNodeFd.prototype = new MlFile();
  MlNodeFd.prototype.constructor = MlNodeFd;
  MlNodeFd.prototype.truncate
    =
    function (len) {
      try { this.fs.ftruncateSync(this.fd, len | 0) }
      catch (err) { caml_raise_sys_error(err.toString()) }
    };
  MlNodeFd.prototype.length
    =
    function () {
      try { return this.fs.fstatSync(this.fd).size }
      catch (err) { caml_raise_sys_error(err.toString()) }
    };
  MlNodeFd.prototype.write
    =
    function (offset, buf, buf_offset, len) {
      try {
        if (this.flags.isCharacterDevice)
          this.fs.writeSync(this.fd, buf, buf_offset, len);
        else
          this.fs.writeSync(this.fd, buf, buf_offset, len, offset)
      }
      catch (err) { caml_raise_sys_error(err.toString()) }
      return 0
    };
  MlNodeFd.prototype.read
    =
    function (offset, a, buf_offset, len) {
      try {
        if (this.flags.isCharacterDevice)
          var read = this.fs.readSync(this.fd, a, buf_offset, len);
        else
          var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
        return read
      }
      catch (err) { caml_raise_sys_error(err.toString()) }
    };
  MlNodeFd.prototype.close
    =
    function () {
      try { this.fs.closeSync(this.fd); return 0 }
      catch (err) { caml_raise_sys_error(err.toString()) }
    };
  function MlNodeDevice(root) { this.fs = require("fs"); this.root = root }
  MlNodeDevice.prototype.nm = function (name) { return this.root + name };
  MlNodeDevice.prototype.exists
    =
    function (name) { try { return this.fs.existsSync(this.nm(name)) ? 1 : 0 } catch (err) { return 0 } };
  MlNodeDevice.prototype.mkdir
    =
    function (name, mode, raise_unix) {
      try { this.fs.mkdirSync(this.nm(name), { mode: mode }); return 0 }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.rmdir
    =
    function (name, raise_unix) {
      try { this.fs.rmdirSync(this.nm(name)); return 0 }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.readdir
    =
    function (name, raise_unix) {
      try { return this.fs.readdirSync(this.nm(name)) }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.is_dir
    =
    function (name) {
      try { return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0 }
      catch (err) { caml_raise_sys_error(err.toString()) }
    };
  MlNodeDevice.prototype.unlink
    =
    function (name, raise_unix) {
      try {
        var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
        this.fs.unlinkSync(this.nm(name));
        return b
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.open
    =
    function (name, f, raise_unix) {
      var consts = require("constants"), res = 0;
      for (var key in f)
        switch (key) {
          case "rdonly": res |= consts.O_RDONLY; break;
          case "wronly": res |= consts.O_WRONLY; break;
          case "append": res |= consts.O_WRONLY | consts.O_APPEND; break;
          case "create": res |= consts.O_CREAT; break;
          case "truncate": res |= consts.O_TRUNC; break;
          case "excl": res |= consts.O_EXCL; break;
          case "binary": res |= consts.O_BINARY; break;
          case "text": res |= consts.O_TEXT; break;
          case "nonblock": res |= consts.O_NONBLOCK; break
        }
      try {
        var
        fd = this.fs.openSync(this.nm(name), res),
        isCharacterDevice =
          this.fs.lstatSync(this.nm(name)).isCharacterDevice();
        f.isCharacterDevice = isCharacterDevice;
        return new MlNodeFd(fd, f)
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.rename
    =
    function (o, n, raise_unix) {
      try { this.fs.renameSync(this.nm(o), this.nm(n)) }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.stat
    =
    function (name, raise_unix) {
      try {
        var js_stats = this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.lstat
    =
    function (name, raise_unix) {
      try {
        var js_stats = this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.symlink
    =
    function (to_dir, target, path, raise_unix) {
      try {
        this.fs.symlinkSync(this.nm(target), this.nm(path), to_dir ? "dir" : "file");
        return 0
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.readlink
    =
    function (name, raise_unix) {
      try {
        var link = this.fs.readlinkSync(this.nm(name), "utf8");
        return caml_string_of_jsstring(link)
      }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.opendir
    =
    function (name, raise_unix) {
      try { return this.fs.opendirSync(this.nm(name)) }
      catch (err) { this.raise_nodejs_error(err, raise_unix) }
    };
  MlNodeDevice.prototype.raise_nodejs_error
    =
    function (err, raise_unix) {
      var unix_error = caml_named_value("Unix.Unix_error");
      if (raise_unix && unix_error) {
        var args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
        caml_raise_with_args(unix_error, args)
      }
      else
        caml_raise_sys_error(err.toString())
    };
  MlNodeDevice.prototype.stats_from_js
    =
    function (js_stats) {
      var file_kind;
      if (js_stats.isFile())
        file_kind = 0;
      else
        if (js_stats.isDirectory())
          file_kind = 1;
        else
          if (js_stats.isCharacterDevice())
            file_kind = 2;
          else
            if (js_stats.isBlockDevice())
              file_kind = 3;
            else
              if (js_stats.isSymbolicLink())
                file_kind = 4;
              else
                if (js_stats.isFIFO())
                  file_kind = 5;
                else
                  if (js_stats.isSocket()) file_kind = 6;
      return [0,
        js_stats.dev,
        js_stats.ino,
        file_kind,
        js_stats.mode,
        js_stats.nlink,
        js_stats.uid,
        js_stats.gid,
        js_stats.rdev,
        js_stats.size,
        js_stats.atimeMs,
        js_stats.mtimeMs,
        js_stats.ctimeMs]
    };
  MlNodeDevice.prototype.constructor = MlNodeDevice;
  function caml_get_root(path) { var x = path_is_absolute(path); if (!x) return; return x[0] + "/" }
  function caml_failwith(msg) {
    if (!caml_global_data.Failure)
      caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg)
  }
  var
    caml_root =
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
  if (fs_node_supported())
    jsoo_mount_point.push
      ({ path: caml_root, device: new MlNodeDevice(caml_root) });
  else
    jsoo_mount_point.push
      ({ path: caml_root, device: new MlFakeDevice(caml_root) });
  jsoo_mount_point.push
    ({ path: "/static/", device: new MlFakeDevice("/static/") });
  function resolve_fs_device(name) {
    var
    path = caml_make_path(name),
    name = path.join("/"),
    name_slash = caml_trailing_slash(name),
    res;
    for (var i = 0; i < jsoo_mount_point.length; i++) {
      var m = jsoo_mount_point[i];
      if
        (name_slash.search(m.path)
        ==
        0
        &&
        (!res || res.path.length < m.path.length))
        res
          =
        {
          path: m.path,
          device: m.device,
          rest: name.substring(m.path.length, name.length)
        }
    }
    if (!res && fs_node_supported()) {
      var root = caml_get_root(name);
      if (root && root.match(/^[a-zA-Z]:\/$/)) {
        var m = { path: root, device: new MlNodeDevice(root) };
        jsoo_mount_point.push(m);
        res
          =
        {
          path: m.path,
          device: m.device,
          rest: name.substring(m.path.length, name.length)
        }
      }
    }
    if (res) return res;
    caml_raise_sys_error("no device found for " + name_slash)
  }
  function caml_sys_is_directory(name) {
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0
  }
  function caml_raise_not_found() { caml_raise_constant(caml_global_data.Not_found) }
  function caml_sys_getenv(name) {
    var process = globalThis.process, n = caml_jsstring_of_string(name);
    if (process && process.env && process.env[n] != undefined)
      return caml_string_of_jsstring(process.env[n]);
    if (globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
      return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
    caml_raise_not_found()
  }
  function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits) {
    if (nbits == 0) { nat2.data[ofs2] = 0; return 0 }
    var wrap = 0;
    for (var i = len1 - 1; i >= 0; i--) {
      var a = nat1.data[ofs1 + i] >>> 0;
      nat1.data[ofs1 + i] = a >>> nbits | wrap;
      wrap = a << 32 - nbits
    }
    nat2.data[ofs2] = wrap;
    return 0
  }
  var caml_gr_state;
  function caml_gr_state_get() {
    if (caml_gr_state) return caml_gr_state;
    throw [0,
      caml_named_value("Graphics.Graphic_failure"),
      caml_string_of_jsbytes("Not initialized")]
  }
  function caml_gr_point_color(x, y) {
    var
    s = caml_gr_state_get(),
    im = s.context.getImageData(x, s.height - y, 1, 1),
    d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2]
  }
  var MlObjectTable;
  if (typeof globalThis.WeakMap === "undefined")
    MlObjectTable
      =
      function () {
        function NaiveLookup(objs) { this.objs = objs }
        NaiveLookup.prototype.get
          =
          function (v) { for (var i = 0; i < this.objs.length; i++)if (this.objs[i] === v) return i };
        NaiveLookup.prototype.set = function () { };
        return function () { this.objs = []; this.lookup = new NaiveLookup(this.objs) }
      }
        ();
  else
    MlObjectTable
      =
      function () { this.objs = []; this.lookup = new (globalThis.WeakMap)() };
  MlObjectTable.prototype.store
    =
    function (v) { this.lookup.set(v, this.objs.length); this.objs.push(v) };
  MlObjectTable.prototype.recall
    =
    function (v) {
      var i = this.lookup.get(v);
      return i === undefined ? undefined : this.objs.length - i
    };
  function caml_sys_rename(o, n) {
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if (o_root.device != n_root.device)
      caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
    if (!o_root.device.rename)
      caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest)
  }
  function caml_log10_float(x) { return Math.log10(x) }
  var caml_runtime_warnings = 0;
  function caml_ml_enable_runtime_warnings(bool) { caml_runtime_warnings = bool; return 0 }
  function caml_classify_float(x) {
    if (isFinite(x)) {
      if (Math.abs(x) >= 2.2250738585072014e-308) return 0;
      if (x != 0) return 1;
      return 2
    }
    return isNaN(x) ? 4 : 3
  }
  var caml_ml_channels = new Array();
  function caml_refill(chan) {
    if (chan.refill != null) {
      var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
      if (str_a.length == 0)
        chan.refill = null;
      else {
        if (chan.buffer.length < chan.buffer_max + str_a.length) {
          var b = new Uint8Array(chan.buffer_max + str_a.length);
          b.set(chan.buffer);
          chan.buffer = b
        }
        chan.buffer.set(str_a, chan.buffer_max);
        chan.offset += str_a.length;
        chan.buffer_max += str_a.length
      }
    }
    else {
      var
      nread =
        chan.file.read
          (chan.offset,
            chan.buffer,
            chan.buffer_max,
            chan.buffer.length - chan.buffer_max);
      chan.offset += nread;
      chan.buffer_max += nread
    }
  }
  function caml_array_bound_error() { caml_invalid_argument("index out of bounds") }
  function caml_ml_input_scan_line(chanid) {
    var chan = caml_ml_channels[chanid], p = chan.buffer_curr;
    do
      if (p >= chan.buffer_max) {
        if (chan.buffer_curr > 0) {
          chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
          p -= chan.buffer_curr;
          chan.buffer_max -= chan.buffer_curr;
          chan.buffer_curr = 0
        }
        if (chan.buffer_max >= chan.buffer.length) return - chan.buffer_max;
        var prev_max = chan.buffer_max;
        caml_refill(chan);
        if (prev_max == chan.buffer_max) return - chan.buffer_max
      }
    while
      (chan.buffer[p++] != 10);
    return p - chan.buffer_curr
  }
  function caml_gc_minor(unit) { if (typeof globalThis.gc == "function") globalThis.gc(true); return 0 }
  function caml_ml_condition_new(unit) { return { condition: 1 } }
  function caml_int64_of_bytes(a) {
    return new
      MlInt64
      (a[7] << 0 | a[6] << 8 | a[5] << 16,
        a[4] << 0 | a[3] << 8 | a[2] << 16,
        a[1] << 0 | a[0] << 8)
  }
  function caml_ba_uint8_get64(ba, i0) {
    var ofs = ba.offset(i0);
    if (ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
      b1 = ba.get(ofs + 0),
      b2 = ba.get(ofs + 1),
      b3 = ba.get(ofs + 2),
      b4 = ba.get(ofs + 3),
      b5 = ba.get(ofs + 4),
      b6 = ba.get(ofs + 5),
      b7 = ba.get(ofs + 6),
      b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1])
  }
  function caml_int64_to_bytes(x) { return x.toArray() }
  function caml_int64_marshal(writer, v, sizes) {
    var b = caml_int64_to_bytes(v);
    for (var i = 0; i < 8; i++)writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8
  }
  function caml_ba_num_dims(ba) { return ba.dims.length }
  function caml_return_exn_constant(tag) { return tag }
  function caml_wrap_exception(e) {
    if (e instanceof Array) return e;
    if
      (globalThis.RangeError
      &&
      e instanceof globalThis.RangeError
      &&
      e.message
      &&
      e.message.match(/maximum call stack/i))
      return caml_return_exn_constant(caml_global_data.Stack_overflow);
    if
      (globalThis.InternalError
      &&
      e instanceof globalThis.InternalError
      &&
      e.message
      &&
      e.message.match(/too much recursion/i))
      return caml_return_exn_constant(caml_global_data.Stack_overflow);
    if (e instanceof globalThis.Error && caml_named_value("jsError"))
      return [0, caml_named_value("jsError"), e];
    return [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))]
  }
  function caml_create_file(name, content) {
    var root = resolve_fs_device(name);
    if (!root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0
  }
  function jsoo_create_file(name, content) {
    var
    name = caml_string_of_jsbytes(name),
    content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content)
  }
  function caml_fs_init() {
    var tmp = globalThis.caml_fs_tmp;
    if (tmp)
      for (var i = 0; i < tmp.length; i++)
        jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0
  }
  function caml_get_continuation_callstack() { return [0] }
  var caml_parser_trace = 0;
  function caml_set_parser_trace(bool) { var oldflag = caml_parser_trace; caml_parser_trace = bool; return oldflag }
  function caml_list_of_js_array(a) {
    var l = 0;
    for (var i = a.length - 1; i >= 0; i--) { var e = a[i]; l = [0, e, l] }
    return l
  }
  function caml_mul(a, b) { return Math.imul(a, b) }
  function caml_hash_mix_int(h, d) {
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0
  }
  function num_digits_nat(nat, ofs, len) {
    for (var i = len - 1; i >= 0; i--)if (nat.data[ofs + i] != 0) return i + 1;
    return 1
  }
  function caml_hash_nat(x) {
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for (var i = 0; i < len; i++)h = caml_hash_mix_int(h, x.data[i]);
    return h
  }
  function caml_call_gen(f, args) {
    if (f.fun) return caml_call_gen(f.fun, args);
    if (typeof f !== "function") return f;
    var n = f.length | 0;
    if (n === 0) return f.apply(null, args);
    var argsLen = args.length | 0, d = n - argsLen | 0;
    if (d == 0)
      return f.apply(null, args);
    else
      if (d < 0)
        return caml_call_gen(f.apply(null, args.slice(0, n)), args.slice(n));
      else
        return function () {
          var
          extra_args = arguments.length == 0 ? 1 : arguments.length,
          nargs = new Array(args.length + extra_args);
          for (var i = 0; i < args.length; i++)nargs[i] = args[i];
          for (var i = 0; i < arguments.length; i++)
            nargs[args.length + i] = arguments[i];
          return caml_call_gen(f, nargs)
        }
  }
  var caml_callback = caml_call_gen;
  function caml_js_wrap_callback_arguments(f) {
    return function () {
      var len = arguments.length, args = new Array(len);
      for (var i = 0; i < len; i++)args[i] = arguments[i];
      return caml_callback(f, [args])
    }
  }
  function caml_sys_chdir(dir) {
    var root = resolve_fs_device(dir);
    if (root.device.exists(root.rest)) {
      if (root.rest)
        caml_current_dir = caml_trailing_slash(root.path + root.rest);
      else
        caml_current_dir = root.path;
      return 0
    }
    else
      caml_raise_no_such_file(caml_jsbytes_of_string(dir))
  }
  function caml_obj_tag(x) {
    if (x instanceof Array && x[0] == x[0] >>> 0)
      return x[0];
    else
      if (caml_is_ml_bytes(x))
        return 252;
      else
        if (caml_is_ml_string(x))
          return 252;
        else
          if (x instanceof Function || typeof x == "function")
            return 247;
          else
            if (x && x.caml_custom) return 255; else return 1000
  }
  function caml_obj_update_tag(b, o, n) { if (b[0] == o) { b[0] = n; return 1 } return 0 }
  var caml_ml_domain_unique_token_ = [0];
  function caml_ml_domain_unique_token(unit) { return caml_ml_domain_unique_token_ }
  function caml_lazy_update_to_forcing(o) {
    var t = caml_obj_tag(o);
    if (t != 246 && t != 250 && t != 244) return 4;
    if (caml_obj_update_tag(o, 246, 244))
      return 0;
    else {
      var field0 = o[1];
      t = o[0];
      if (t == 244)
        return field0 == caml_ml_domain_unique_token(0) ? 1 : 2;
      else
        if (t == 250) return 3; else return 2
    }
  }
  function caml_gc_counters() { return [254, 0, 0, 0] }
  function caml_gr_synchronize() { caml_failwith("caml_gr_synchronize not Implemented") }
  function caml_unix_closedir(dir_handle) {
    try { dir_handle.pointer.closeSync() }
    catch (e) {
      var unix_error = caml_named_value("Unix.Unix_error");
      caml_raise_with_args
        (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path))
    }
  }
  function caml_unix_opendir(path) {
    var root = resolve_fs_device(path);
    if (!root.device.opendir)
      caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return { pointer: dir_handle, path: path }
  }
  function caml_unix_rewinddir(dir_handle) {
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0
  }
  function caml_raise_end_of_file() { caml_raise_constant(caml_global_data.End_of_file) }
  function caml_unix_readdir(dir_handle) {
    var entry;
    try { entry = dir_handle.pointer.readSync() }
    catch (e) {
      var unix_error = caml_named_value("Unix.Unix_error");
      caml_raise_with_args
        (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path))
    }
    if (entry === null)
      caml_raise_end_of_file();
    else
      return caml_string_of_jsstring(entry.name)
  }
  function caml_unix_findfirst(path) {
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
      dir_handle = caml_unix_opendir(path),
      first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle]
  }
  function caml_is_continuation_tag(t) { return 0 }
  var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
  function jsoo_floor_log2(x) {
    if (log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if (x == 0) return - Infinity;
    if (x >= 1) while (x >= 2) { x /= 2; i++ } else while (x < 1) { x *= 2; i-- }
    return i
  }
  function caml_int32_bits_of_float(x) {
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0
  }
  function caml_int64_create_lo_mi_hi(lo, mi, hi) { return new MlInt64(lo, mi, hi) }
  function caml_int64_bits_of_float(x) {
    if (!isFinite(x)) {
      if (isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
      return x > 0
        ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
        : caml_int64_create_lo_mi_hi(0, 0, 0xfff0)
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if (sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if (exp <= 0) { exp = 0; x /= Math.pow(2, - 1026) }
    else {
      x /= Math.pow(2, exp - 1027);
      if (x < 16) { x *= 2; exp -= 1 }
      if (exp == 0) x /= 2
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3)
  }
  function caml_ba_serialize(writer, ba, sz) {
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if (ba.caml_custom == "_bigarr02")
      for (var i = 0; i < ba.dims.length; i++)
        if (ba.dims[i] < 0xffff)
          writer.write(16, ba.dims[i]);
        else {
          writer.write(16, 0xffff);
          writer.write(32, 0);
          writer.write(32, ba.dims[i])
        }
    else
      for (var i = 0; i < ba.dims.length; i++)writer.write(32, ba.dims[i]);
    switch (ba.kind) {
      case 2:
      case 3:
      case 12:
        for (var i = 0; i < ba.data.length; i++)writer.write(8, ba.data[i]); break;
      case 4:
      case 5:
        for (var i = 0; i < ba.data.length; i++)writer.write(16, ba.data[i]); break;
      case 6:
        for (var i = 0; i < ba.data.length; i++)writer.write(32, ba.data[i]); break;
      case 8:
      case 9:
        writer.write(8, 0);
        for (var i = 0; i < ba.data.length; i++)writer.write(32, ba.data[i]);
        break;
      case 7:
        for (var i = 0; i < ba.data.length / 2; i++) {
          var b = caml_int64_to_bytes(ba.get(i));
          for (var j = 0; j < 8; j++)writer.write(8, b[j])
        }
        break;
      case 1:
        for (var i = 0; i < ba.data.length; i++) {
          var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
          for (var j = 0; j < 8; j++)writer.write(8, b[j])
        }
        break;
      case 0:
        for (var i = 0; i < ba.data.length; i++) { var b = caml_int32_bits_of_float(ba.get(i)); writer.write(32, b) }
        break;
      case 10:
        for (var i = 0; i < ba.data.length / 2; i++) {
          var j = ba.get(i);
          writer.write(32, caml_int32_bits_of_float(j[1]));
          writer.write(32, caml_int32_bits_of_float(j[2]))
        }
        break;
      case 11:
        for (var i = 0; i < ba.data.length / 2; i++) {
          var
          complex = ba.get(i),
          b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
          for (var j = 0; j < 8; j++)writer.write(8, b[j]);
          var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
          for (var j = 0; j < 8; j++)writer.write(8, b[j])
        }
        break
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8
  }
  function caml_ba_get_size_per_element(kind) { switch (kind) { case 7: case 10: case 11: return 2; default: return 1 } }
  function caml_ba_create_buffer(kind, size) {
    var view;
    switch (kind) {
      case 0: view = Float32Array; break;
      case 1: view = Float64Array; break;
      case 2: view = Int8Array; break;
      case 3: view = Uint8Array; break;
      case 4: view = Int16Array; break;
      case 5: view = Uint16Array; break;
      case 6: view = Int32Array; break;
      case 7: view = Int32Array; break;
      case 8: view = Int32Array; break;
      case 9: view = Int32Array; break;
      case 10: view = Float32Array; break;
      case 11: view = Float64Array; break;
      case 12: view = Uint8Array; break
    }
    if (!view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data
  }
  function caml_int32_float_of_bits(x) {
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0]
  }
  function caml_int64_float_of_bits(x) {
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if (exp == 2047)
      return (lo | mi | hi & 0xf) == 0 ? hi & 0x8000 ? - Infinity : Infinity : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if (exp > 0) { res += 16; res *= Math.pow(2, exp - 1027) }
    else
      res *= Math.pow(2, - 1026);
    if (hi & 0x8000) res = - res;
    return res
  }
  function caml_ba_get_size(dims) {
    var n_dims = dims.length, size = 1;
    for (var i = 0; i < n_dims; i++) {
      if (dims[i] < 0)
        caml_invalid_argument("Bigarray.create: negative dimension");
      size = size * dims[i]
    }
    return size
  }
  function caml_int64_create_lo_hi(lo, hi) {
    return new
      MlInt64
      (lo & 0xffffff,
        lo >>> 24 & 0xff | (hi & 0xffff) << 8,
        hi >>> 16 & 0xffff)
  }
  function caml_int64_hi32(v) { return v.hi32() }
  function caml_int64_lo32(v) { return v.lo32() }
  var caml_ba_custom_name = "_bigarr02";
  function Ml_Bigarray(kind, layout, dims, buffer) {
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer
  }
  Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
  Ml_Bigarray.prototype.offset
    =
    function (arg) {
      var ofs = 0;
      if (typeof arg === "number") arg = [arg];
      if (!(arg instanceof Array))
        caml_invalid_argument("bigarray.js: invalid offset");
      if (this.dims.length != arg.length)
        caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if (this.layout == 0)
        for (var i = 0; i < this.dims.length; i++) {
          if (arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
          ofs = ofs * this.dims[i] + arg[i]
        }
      else
        for (var i = this.dims.length - 1; i >= 0; i--) {
          if (arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
          ofs = ofs * this.dims[i] + (arg[i] - 1)
        }
      return ofs
    };
  Ml_Bigarray.prototype.get
    =
    function (ofs) {
      switch (this.kind) {
        case 7:
          var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
          return caml_int64_create_lo_hi(l, h);
        case 10:
        case 11:
          var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
          return [254, r, i];
        default: return this.data[ofs]
      }
    };
  Ml_Bigarray.prototype.set
    =
    function (ofs, v) {
      switch (this.kind) {
        case 7:
          this.data[ofs * 2 + 0] = caml_int64_lo32(v);
          this.data[ofs * 2 + 1] = caml_int64_hi32(v);
          break;
        case 10:
        case 11:
          this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
        default: this.data[ofs] = v; break
      }
      return 0
    };
  Ml_Bigarray.prototype.fill
    =
    function (v) {
      switch (this.kind) {
        case 7:
          var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
          if (a == b)
            this.data.fill(a);
          else
            for (var i = 0; i < this.data.length; i++)this.data[i] = i % 2 == 0 ? a : b;
          break;
        case 10:
        case 11:
          var im = v[1], re = v[2];
          if (im == re)
            this.data.fill(im);
          else
            for (var i = 0; i < this.data.length; i++)
              this.data[i] = i % 2 == 0 ? im : re;
          break;
        default: this.data.fill(v); break
      }
    };
  Ml_Bigarray.prototype.compare
    =
    function (b, total) {
      if (this.layout != b.layout || this.kind != b.kind) {
        var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
        return k2 - k1
      }
      if (this.dims.length != b.dims.length)
        return b.dims.length - this.dims.length;
      for (var i = 0; i < this.dims.length; i++)
        if (this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
      switch (this.kind) {
        case 0:
        case 1:
        case 10:
        case 11:
          var x, y;
          for (var i = 0; i < this.data.length; i++) {
            x = this.data[i];
            y = b.data[i];
            if (x < y) return - 1;
            if (x > y) return 1;
            if (x != y) { if (!total) return NaN; if (x == x) return 1; if (y == y) return - 1 }
          }
          break;
        case 7:
          for (var i = 0; i < this.data.length; i += 2) {
            if (this.data[i + 1] < b.data[i + 1]) return - 1;
            if (this.data[i + 1] > b.data[i + 1]) return 1;
            if (this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
            if (this.data[i] >>> 0 > b.data[i] >>> 0) return 1
          }
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
          for (var i = 0; i < this.data.length; i++) {
            if (this.data[i] < b.data[i]) return - 1;
            if (this.data[i] > b.data[i]) return 1
          }
          break
      }
      return 0
    };
  function Ml_Bigarray_c_1_1(kind, layout, dims, buffer) {
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer
  }
  Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
  Ml_Bigarray_c_1_1.prototype.offset
    =
    function (arg) {
      if (typeof arg !== "number")
        if (arg instanceof Array && arg.length == 1)
          arg = arg[0];
        else
          caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if (arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
      return arg
    };
  Ml_Bigarray_c_1_1.prototype.get = function (ofs) { return this.data[ofs] };
  Ml_Bigarray_c_1_1.prototype.set
    =
    function (ofs, v) { this.data[ofs] = v; return 0 };
  Ml_Bigarray_c_1_1.prototype.fill
    =
    function (v) { this.data.fill(v); return 0 };
  function caml_ba_create_unsafe(kind, layout, dims, data) {
    var size_per_element = caml_ba_get_size_per_element(kind);
    if (caml_ba_get_size(dims) * size_per_element != data.length)
      caml_invalid_argument("length doesn't match dims");
    if (layout == 0 && dims.length == 1 && size_per_element == 1)
      return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data)
  }
  function caml_ba_deserialize(reader, sz, name) {
    var num_dims = reader.read32s();
    if (num_dims < 0 || num_dims > 16)
      caml_failwith("input_value: wrong number of bigarray dimensions");
    var tag = reader.read32s(), kind = tag & 0xff, layout = tag >> 8 & 1, dims = [];
    if (name == "_bigarr02")
      for (var i = 0; i < num_dims; i++) {
        var size_dim = reader.read16u();
        if (size_dim == 0xffff) {
          var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
          if (size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
          size_dim = size_dim_lo
        }
        dims.push(size_dim)
      }
    else
      for (var i = 0; i < num_dims; i++)dims.push(reader.read32u());
    var
      size = caml_ba_get_size(dims),
      data = caml_ba_create_buffer(kind, size),
      ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch (kind) {
      case 2: for (var i = 0; i < size; i++)data[i] = reader.read8s(); break;
      case 3:
      case 12: for (var i = 0; i < size; i++)data[i] = reader.read8u(); break;
      case 4: for (var i = 0; i < size; i++)data[i] = reader.read16s(); break;
      case 5: for (var i = 0; i < size; i++)data[i] = reader.read16u(); break;
      case 6: for (var i = 0; i < size; i++)data[i] = reader.read32s(); break;
      case 8:
      case 9:
        var sixty = reader.read8u();
        if (sixty)
          caml_failwith
            ("input_value: cannot read bigarray with 64-bit OCaml ints");
        for (var i = 0; i < size; i++)data[i] = reader.read32s();
        break;
      case 7:
        var t = new Array(8);
        for (var i = 0; i < size; i++) {
          for (var j = 0; j < 8; j++)t[j] = reader.read8u();
          var int64 = caml_int64_of_bytes(t);
          ba.set(i, int64)
        }
        break;
      case 1:
        var t = new Array(8);
        for (var i = 0; i < size; i++) {
          for (var j = 0; j < 8; j++)t[j] = reader.read8u();
          var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
          ba.set(i, f)
        }
        break;
      case 0:
        for (var i = 0; i < size; i++) { var f = caml_int32_float_of_bits(reader.read32s()); ba.set(i, f) }
        break;
      case 10:
        for (var i = 0; i < size; i++) {
          var
          re = caml_int32_float_of_bits(reader.read32s()),
          im = caml_int32_float_of_bits(reader.read32s());
          ba.set(i, [254, re, im])
        }
        break;
      case 11:
        var t = new Array(8);
        for (var i = 0; i < size; i++) {
          for (var j = 0; j < 8; j++)t[j] = reader.read8u();
          var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
          for (var j = 0; j < 8; j++)t[j] = reader.read8u();
          var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
          ba.set(i, [254, re, im])
        }
        break
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data)
  }
  function caml_ba_compare(a, b, total) { return a.compare(b, total) }
  function caml_hash_mix_int64(h, v) {
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h
  }
  function caml_hash_mix_float(h, v0) { return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0)) }
  function caml_ba_hash(ba) {
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch (ba.kind) {
      case 2:
      case 3:
      case 12:
        if (num_elts > 256) num_elts = 256;
        var w = 0, i = 0;
        for (i = 0; i + 4 <= ba.data.length; i += 4) {
          w
          =
          ba.data[i + 0]
          |
          ba.data[i + 1]
          <<
          8
          |
          ba.data[i + 2]
          <<
          16
          |
          ba.data[i + 3]
          <<
          24;
          h = caml_hash_mix_int(h, w)
        }
        w = 0;
        switch (num_elts & 3) {
          case 3: w = ba.data[i + 2] << 16;
          case 2: w |= ba.data[i + 1] << 8;
          case 1: w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w)
        }
        break;
      case 4:
      case 5:
        if (num_elts > 128) num_elts = 128;
        var w = 0, i = 0;
        for (i = 0; i + 2 <= ba.data.length; i += 2) {
          w = ba.data[i + 0] | ba.data[i + 1] << 16;
          h = caml_hash_mix_int(h, w)
        }
        if ((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
        break;
      case 6:
        if (num_elts > 64) num_elts = 64;
        for (var i = 0; i < num_elts; i++)h = caml_hash_mix_int(h, ba.data[i]);
        break;
      case 8:
      case 9:
        if (num_elts > 64) num_elts = 64;
        for (var i = 0; i < num_elts; i++)h = caml_hash_mix_int(h, ba.data[i]);
        break;
      case 7:
        if (num_elts > 32) num_elts = 32;
        num_elts *= 2;
        for (var i = 0; i < num_elts; i++)h = caml_hash_mix_int(h, ba.data[i]);
        break;
      case 10: num_elts *= 2;
      case 0:
        if (num_elts > 64) num_elts = 64;
        for (var i = 0; i < num_elts; i++)h = caml_hash_mix_float(h, ba.data[i]);
        break;
      case 11: num_elts *= 2;
      case 1:
        if (num_elts > 32) num_elts = 32;
        for (var i = 0; i < num_elts; i++)h = caml_hash_mix_float(h, ba.data[i]);
        break
    }
    return h
  }
  function caml_int32_unmarshal(reader, size) { size[0] = 4; return reader.read32s() }
  function caml_nativeint_unmarshal(reader, size) {
    switch (reader.read8u()) {
      case 1: size[0] = 4; return reader.read32s();
      case 2: caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer")
    }
  }
  function caml_int64_unmarshal(reader, size) {
    var t = new Array(8);
    for (var j = 0; j < 8; j++)t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t)
  }
  function caml_int64_compare(x, y, total) { return x.compare(y) }
  function caml_int64_hash(v) { return v.lo32() ^ v.hi32() }
  var
    caml_custom_ops =
    {
      "_j":
      {
        deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash
      },
      "_i": { deserialize: caml_int32_unmarshal, fixed_length: 4 },
      "_n": { deserialize: caml_nativeint_unmarshal, fixed_length: 4 },
      "_bigarray":
      {
        deserialize:
          function (reader, sz) { return caml_ba_deserialize(reader, sz, "_bigarray") },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash
      },
      "_bigarr02":
      {
        deserialize:
          function (reader, sz) { return caml_ba_deserialize(reader, sz, "_bigarr02") },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash
      }
    };
  function caml_compare_val_get_custom(a) {
    return caml_custom_ops[a.caml_custom]
      &&
      caml_custom_ops[a.caml_custom].compare
  }
  function caml_compare_val_number_custom(num, custom, swap, total) {
    var comp = caml_compare_val_get_custom(custom);
    if (comp) {
      var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
      if (total && x != x) return swap;
      if (+ x != + x) return + x;
      if ((x | 0) != 0) return x | 0
    }
    return swap
  }
  function caml_compare_val_tag(a) {
    if (typeof a === "number")
      return 1000;
    else
      if (caml_is_ml_bytes(a))
        return 252;
      else
        if (caml_is_ml_string(a))
          return 1252;
        else
          if (a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255) { var tag = a[0] | 0; return tag == 254 ? 0 : tag }
          else
            if (a instanceof String)
              return 12520;
            else
              if (typeof a == "string")
                return 12520;
              else
                if (a instanceof Number)
                  return 1000;
                else
                  if (a && a.caml_custom)
                    return 1255;
                  else
                    if (a && a.compare)
                      return 1256;
                    else
                      if (typeof a == "function")
                        return 1247;
                      else
                        if (typeof a == "symbol") return 1251;
    return 1001
  }
  function caml_int_compare(a, b) { if (a < b) return - 1; if (a == b) return 0; return 1 }
  function caml_bytes_compare(s1, s2) {
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0
  }
  function caml_string_compare(s1, s2) { return caml_bytes_compare(s1, s2) }
  function caml_compare_val(a, b, total) {
    var stack = [];
    for (; ;) {
      if (!(total && a === b)) {
        var tag_a = caml_compare_val_tag(a);
        if (tag_a == 250) { a = a[1]; continue }
        var tag_b = caml_compare_val_tag(b);
        if (tag_b == 250) { b = b[1]; continue }
        if (tag_a !== tag_b) {
          if (tag_a == 1000) {
            if (tag_b == 1255)
              return caml_compare_val_number_custom(a, b, - 1, total);
            return - 1
          }
          if (tag_b == 1000) {
            if (tag_a == 1255)
              return caml_compare_val_number_custom(b, a, 1, total);
            return 1
          }
          return tag_a < tag_b ? - 1 : 1
        }
        switch (tag_a) {
          case 247: caml_invalid_argument("compare: functional value"); break;
          case 248:
            var x = caml_int_compare(a[2], b[2]); if (x != 0) return x | 0; break;
          case 249: caml_invalid_argument("compare: functional value"); break;
          case 250:
            caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
            break;
          case 251: caml_invalid_argument("equal: abstract value"); break;
          case 252:
            if (a !== b) { var x = caml_bytes_compare(a, b); if (x != 0) return x | 0 }
            break;
          case 253:
            caml_invalid_argument("equal: got Double_tag, should not happen");
            break;
          case 254:
            caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
            break;
          case 255:
            caml_invalid_argument("equal: got Custom_tag, should not happen");
            break;
          case 1247:
            caml_invalid_argument("compare: functional value"); break;
          case 1255:
            var comp = caml_compare_val_get_custom(a);
            if (comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom ? - 1 : 1;
            if (!comp) caml_invalid_argument("compare: abstract value");
            var x = comp(a, b, total);
            if (x != x) return total ? - 1 : x;
            if (x !== (x | 0)) return - 1;
            if (x != 0) return x | 0;
            break;
          case 1256:
            var x = a.compare(b, total);
            if (x != x) return total ? - 1 : x;
            if (x !== (x | 0)) return - 1;
            if (x != 0) return x | 0;
            break;
          case 1000:
            a = + a;
            b = + b;
            if (a < b) return - 1;
            if (a > b) return 1;
            if (a != b) { if (!total) return NaN; if (a == a) return 1; if (b == b) return - 1 }
            break;
          case 1001:
            if (a < b) return - 1;
            if (a > b) return 1;
            if (a != b) { if (!total) return NaN; if (a == a) return 1; if (b == b) return - 1 }
            break;
          case 1251: if (a !== b) { if (!total) return NaN; return 1 } break;
          case 1252:
            var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
            if (a !== b) { if (a < b) return - 1; if (a > b) return 1 }
            break;
          case 12520:
            var a = a.toString(), b = b.toString();
            if (a !== b) { if (a < b) return - 1; if (a > b) return 1 }
            break;
          case 246:
          case 254:
          default:
            if (caml_is_continuation_tag(tag_a)) { caml_invalid_argument("compare: continuation value"); break }
            if (a.length != b.length) return a.length < b.length ? - 1 : 1;
            if (a.length > 1) stack.push(a, b, 1);
            break
        }
      }
      if (stack.length == 0) return 0;
      var i = stack.pop();
      b = stack.pop();
      a = stack.pop();
      if (i + 1 < a.length) stack.push(a, b, i + 1);
      a = a[i];
      b = b[i]
    }
  }
  function caml_greaterthan(x, y) { return + (caml_compare_val(x, y, false) > 0) }
  function div_helper(a, b, c) {
    var
    x = a * 65536 + (b >>> 16),
    y = Math.floor(x / c) * 65536,
    z = x % c * 65536,
    w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c]
  }
  function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2) {
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for (var i = len - 2; i >= 0; i--) {
      var x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
      natq.data[ofsq + i] = x[0];
      rem = x[1]
    }
    natr.data[ofsr] = rem;
    return 0
  }
  function num_leading_zero_bits_in_digit(nat, ofs) {
    var a = nat.data[ofs], b = 0;
    if (a & 0xFFFF0000) { b += 16; a >>>= 16 }
    if (a & 0xFF00) { b += 8; a >>>= 8 }
    if (a & 0xF0) { b += 4; a >>>= 4 }
    if (a & 12) { b += 2; a >>>= 2 }
    if (a & 2) { b += 1; a >>>= 1 }
    if (a & 1) b += 1;
    return 32 - b
  }
  function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits) {
    if (nbits == 0) { nat2.data[ofs2] = 0; return 0 }
    var wrap = 0;
    for (var i = 0; i < len1; i++) {
      var a = nat1.data[ofs1 + i] >>> 0;
      nat1.data[ofs1 + i] = a << nbits | wrap;
      wrap = a >>> 32 - nbits
    }
    nat2.data[ofs2] = wrap;
    return 0
  }
  function MlNat(x) { this.data = new Int32Array(x); this.length = this.data.length + 2 }
  MlNat.prototype.caml_custom = "_nat";
  function create_nat(size) {
    var arr = new MlNat(size);
    for (var i = 0; i < size; i++)arr.data[i] = - 1;
    return arr
  }
  function set_to_zero_nat(nat, ofs, len) { for (var i = 0; i < len; i++)nat.data[ofs + i] = 0; return 0 }
  function incr_nat(nat, ofs, len, carry_in) {
    var carry = carry_in;
    for (var i = 0; i < len; i++) {
      var x = (nat.data[ofs + i] >>> 0) + carry;
      nat.data[ofs + i] = x | 0;
      if (x == x >>> 0) { carry = 0; break } else carry = 1
    }
    return carry
  }
  function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in) {
    var carry = carry_in;
    for (var i = 0; i < len2; i++) {
      var
      x =
        (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
      nat1.data[ofs1 + i] = x;
      if (x == x >>> 0) carry = 0; else carry = 1
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry)
  }
  function nat_of_array(l) { return new MlNat(l) }
  function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3) {
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for (var i = 0; i < len2; i++) {
      var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        +
        (nat2.data[ofs2 + i] >>> 0)
        *
        (a & 0x0000FFFF)
        +
        carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
      carry = Math.floor(x2 / 65536);
      var x3 = x1 + x2 % 65536 * 65536;
      nat1.data[ofs1 + i] = x3;
      carry += Math.floor(x3 / 4294967296)
    }
    return len2 < len1 && carry
      ? add_nat
        (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
      : carry
  }
  function decr_nat(nat, ofs, len, carry_in) {
    var borrow = carry_in == 1 ? 0 : 1;
    for (var i = 0; i < len; i++) {
      var x = (nat.data[ofs + i] >>> 0) - borrow;
      nat.data[ofs + i] = x;
      if (x >= 0) { borrow = 0; break } else borrow = 1
    }
    return borrow == 1 ? 0 : 1
  }
  function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in) {
    var borrow = carry_in == 1 ? 0 : 1;
    for (var i = 0; i < len2; i++) {
      var
      x =
        (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
      nat1.data[ofs1 + i] = x;
      if (x >= 0) borrow = 0; else borrow = 1
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1)
  }
  function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
    var a = num_digits_nat(nat1, ofs1, len1), b = num_digits_nat(nat2, ofs2, len2);
    if (a > b) return 1;
    if (a < b) return - 1;
    for (var i = len1 - 1; i >= 0; i--) {
      if (nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
      if (nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1
    }
    return 0
  }
  function div_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
    if (len2 == 1) {
      div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
      return 0
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for (var i = len1 - 1; i >= len2; i--) {
      var
      quo =
        d == 4294967296
          ? nat1.data[ofs1 + i] >>> 0
          : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
          [0];
      set_to_zero_nat(a, 0, len2 + 1);
      mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
      while
        (nat1.data[ofs1 + i]
        !=
        0
        ||
        compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2)
        >=
        0) {
        quo = quo + 1;
        sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1)
      }
      nat1.data[ofs1 + i] = quo
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0
  }
  function caml_ba_blit(src, dst) {
    if (dst.dims.length != src.dims.length)
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for (var i = 0; i < dst.dims.length; i++)
      if (dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0
  }
  function is_digit_int(nat, ofs) { if (nat.data[ofs] >= 0) return 1; return 0 }
  function caml_int64_div(x, y) { return x.div(y) }
  function caml_js_html_entities(s) {
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if (s.match(entity)) {
      var str, temp = document.createElement("p");
      temp.innerHTML = s;
      str = temp.textContent || temp.innerText;
      temp = null;
      return str
    }
    else
      caml_failwith("Invalid entity " + s)
  }
  function caml_string_unsafe_set(s, i, c) { return caml_bytes_unsafe_set(s, i, c) }
  function caml_int64_of_float(x) {
    if (x < 0) x = Math.ceil(x);
    return new
      MlInt64
      (x & 0xffffff,
        Math.floor(x * caml_int64_offset) & 0xffffff,
        Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)
  }
  function caml_ml_channel_size_64(chanid) {
    var chan = caml_ml_channels[chanid];
    return caml_int64_of_float(chan.file.length())
  }
  function caml_ba_set_2(ba, i0, i1, v) { ba.set(ba.offset([i0, i1]), v); return 0 }
  var
    caml_argv =
      function () {
        var process = globalThis.process, main = "a.out", args = [];
        if (process && process.argv && process.argv.length > 1) { var argv = process.argv; main = argv[1]; args = argv.slice(2) }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for (var i = 0; i < args.length; i++)
          args2.push(caml_string_of_jsstring(args[i]));
        return args2
      }
        (),
    caml_executable_name = caml_argv[1];
  function caml_js_eval_string(s) { return eval(caml_jsstring_of_string(s)) }
  function serialize_nat(writer, nat, sz) {
    var len = nat.data.length;
    writer.write(32, len);
    for (var i = 0; i < len; i++)writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8
  }
  function caml_memprof_set(_control) { return 0 }
  function caml_sys_exit(code) {
    if (globalThis.quit) globalThis.quit(code);
    if (globalThis.process && globalThis.process.exit)
      globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented")
  }
  function caml_channel_descriptor(chanid) { var chan = caml_ml_channels[chanid]; return chan.fd }
  function caml_js_from_array(a) { return a.slice(1) }
  function caml_ba_reshape(ba, vind) {
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if (num_dims < 0 || num_dims > 16)
      caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for (var i = 0; i < num_dims; i++) {
      new_dim[i] = vind[i];
      if (new_dim[i] < 0)
        caml_invalid_argument("Bigarray.reshape: negative dimension");
      num_elts = num_elts * new_dim[i]
    }
    var size = caml_ba_get_size(ba.dims);
    if (num_elts != size)
      caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data)
  }
  var caml_oo_last_id = 0;
  function caml_set_oo_id(b) { b[2] = caml_oo_last_id++; return b }
  function caml_gr_fill_rect(x, y, w, h) {
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0
  }
  function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len) {
    if (12 != ba2.kind)
      caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
    if (len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if (pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if (ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0
  }
  function caml_gr_set_window_title(name) {
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if (s.set_title) s.set_title(jsname);
    return 0
  }
  function caml_get_global_data() { return caml_global_data }
  function caml_int64_shift_right_unsigned(x, s) { return x.shift_right_unsigned(s) }
  function caml_ba_uint8_get16(ba, i0) {
    var ofs = ba.offset(i0);
    if (ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8
  }
  function caml_compare(a, b) { return caml_compare_val(a, b, true) }
  var
    caml_MD5Transform =
      function () {
        function add(x, y) { return x + y | 0 }
        function xx(q, a, b, x, s, t) { a = add(add(a, q), add(x, t)); return add(a << s | a >>> 32 - s, b) }
        function ff(a, b, c, d, x, s, t) { return xx(b & c | ~b & d, a, b, x, s, t) }
        function gg(a, b, c, d, x, s, t) { return xx(b & d | c & ~d, a, b, x, s, t) }
        function hh(a, b, c, d, x, s, t) { return xx(b ^ c ^ d, a, b, x, s, t) }
        function ii(a, b, c, d, x, s, t) { return xx(c ^ (b | ~d), a, b, x, s, t) }
        return function (w, buffer) {
          var a = w[0], b = w[1], c = w[2], d = w[3];
          a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
          d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
          c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
          b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
          a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
          d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
          c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
          b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
          a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
          d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
          c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
          b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
          a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
          d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
          c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
          b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
          a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
          d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
          c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
          b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
          a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
          d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
          c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
          b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
          a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
          d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
          c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
          b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
          a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
          d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
          c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
          b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
          a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
          d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
          c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
          b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
          a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
          d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
          c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
          b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
          a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
          d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
          c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
          b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
          a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
          d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
          c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
          b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
          a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
          d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
          c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
          b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
          a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
          d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
          c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
          b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
          a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
          d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
          c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
          b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
          a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
          d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
          c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
          b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
          w[0] = add(a, w[0]);
          w[1] = add(b, w[1]);
          w[2] = add(c, w[2]);
          w[3] = add(d, w[3])
        }
      }
        ();
  function caml_MD5Update(ctx, input, input_len) {
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if (in_buf) {
      var missing = 64 - in_buf;
      if (input_len < missing) { ctx.b8.set(input.subarray(0, input_len), in_buf); return }
      ctx.b8.set(input.subarray(0, missing), in_buf);
      caml_MD5Transform(ctx.w, ctx.b32);
      input_len -= missing;
      input_pos += missing
    }
    while (input_len >= 64) {
      ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
      caml_MD5Transform(ctx.w, ctx.b32);
      input_len -= 64;
      input_pos += 64
    }
    if (input_len)
      ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0)
  }
  function caml_fresh_oo_id() { return caml_oo_last_id++ }
  function caml_int64_to_float(x) { return x.toFloat() }
  function caml_ba_get_1(ba, i0) { return ba.get(ba.offset(i0)) }
  function caml_bigstring_memcmp(s1, pos1, s2, pos2, len) {
    for (var i = 0; i < len; i++) {
      var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
      if (a < b) return - 1;
      if (a > b) return 1
    }
    return 0
  }
  function caml_new_string(s) { return caml_string_of_jsbytes(s) }
  function caml_erf_float(x) {
    var
    a1 = 0.254829592,
    a2 = - 0.284496736,
    a3 = 1.421413741,
    a4 = - 1.453152027,
    a5 = 1.061405429,
    p = 0.3275911,
    sign = 1;
    if (x < 0) sign = - 1;
    x = Math.abs(x);
    var
      t = 1.0 / (1.0 + p * x),
      y =
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
    return sign * y
  }
  function caml_ba_uint8_get32(ba, i0) {
    var ofs = ba.offset(i0);
    if (ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
      b1 = ba.get(ofs + 0),
      b2 = ba.get(ofs + 1),
      b3 = ba.get(ofs + 2),
      b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24
  }
  function caml_raw_backtrace_length() { return 0 }
  function caml_str_initialize(unit) { return 0 }
  function caml_obj_block(tag, size) {
    var o = new Array(size + 1);
    o[0] = tag;
    for (var i = 1; i <= size; i++)o[i] = 0;
    return o
  }
  function caml_gr_clear_graph() {
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0
  }
  function bigstring_to_array_buffer(bs) { return bs.data.buffer }
  function caml_sys_const_naked_pointers_checked(_unit) { return 0 }
  function lxor_digit_nat(nat1, ofs1, nat2, ofs2) { nat1.data[ofs1] ^= nat2.data[ofs2]; return 0 }
  function caml_obj_add_offset(v, offset) { caml_failwith("Obj.add_offset is not supported") }
  function caml_final_release() { return 0 }
  function caml_js_to_array(a) {
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for (var i = 0; i < len; i++)b[i + 1] = a[i];
    return b
  }
  function caml_gr_plot(x, y) {
    var
    s = caml_gr_state_get(),
    im = s.context.createImageData(1, 1),
    d = im.data,
    color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0
  }
  function caml_bytes_set16(s, i, i16) {
    if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0
  }
  function caml_string_set16(s, i, i16) { return caml_bytes_set16(s, i, i16) }
  function caml_bytes_set64(s, i, i64) {
    if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for (var j = 0; j < 8; j++)caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0
  }
  function caml_int64_bswap(x) {
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]])
  }
  function caml_gc_major(unit) { if (typeof globalThis.gc == "function") globalThis.gc(); return 0 }
  function caml_lex_array(s) {
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for (var i = 0; i < l; i++)
      a[i]
        =
        (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
        <<
        16
        >>
        16;
    return a
  }
  function caml_lex_engine(tbl, start_state, lexbuf) {
    var
    lex_buffer = 2,
    lex_buffer_len = 3,
    lex_start_pos = 5,
    lex_curr_pos = 6,
    lex_last_pos = 7,
    lex_last_action = 8,
    lex_eof_reached = 9,
    lex_base = 1,
    lex_backtrk = 2,
    lex_default = 3,
    lex_trans = 4,
    lex_check = 5;
    if (!tbl.lex_default) {
      tbl.lex_base = caml_lex_array(tbl[lex_base]);
      tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
      tbl.lex_check = caml_lex_array(tbl[lex_check]);
      tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
      tbl.lex_default = caml_lex_array(tbl[lex_default])
    }
    var
      c,
      state = start_state,
      buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if (state >= 0) {
      lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = - 1
    }
    else
      state = - state - 1;
    for (; ;) {
      var base = tbl.lex_base[state];
      if (base < 0) return - base - 1;
      var backtrk = tbl.lex_backtrk[state];
      if (backtrk >= 0) {
        lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = backtrk
      }
      if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
        if (lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
      else { c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++ }
      if (tbl.lex_check[base + c] == state)
        state = tbl.lex_trans[base + c];
      else
        state = tbl.lex_default[state];
      if (state < 0) {
        lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
        if (lexbuf[lex_last_action] == - 1)
          caml_failwith("lexing: empty token");
        else
          return lexbuf[lex_last_action]
      }
      else
        if (c == 256) lexbuf[lex_eof_reached] = 0
    }
  }
  function caml_sys_file_exists(name) { var root = resolve_fs_device(name); return root.device.exists(root.rest) }
  function caml_convert_raw_backtrace_slot() { caml_failwith("caml_convert_raw_backtrace_slot") }
  function caml_array_sub(a, i, len) {
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for (var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++)a2[i2] = a[i1];
    return a2
  }
  function caml_bytes_equal(s1, s2) {
    if (s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0
  }
  function caml_gr_size_x() { var s = caml_gr_state_get(); return s.width }
  function caml_ml_debug_info_status() { return 0 }
  function caml_atomic_fetch_add(ref, i) { var old = ref[1]; ref[1] += i; return old }
  var
    os_type =
      globalThis.process
        &&
        globalThis.process.platform
        &&
        globalThis.process.platform
        ==
        "win32"
        ? "Cygwin"
        : "Unix";
  function caml_sys_const_ostype_cygwin() { return os_type == "Cygwin" ? 1 : 0 }
  function caml_cosh_float(x) { return Math.cosh(x) }
  function MlMutex() { this.locked = false }
  function caml_ml_mutex_new(unit) { return new MlMutex() }
  var caml_ephe_key_offset = 3;
  function caml_ephe_check_key(x, i) {
    var weak = x[caml_ephe_key_offset + i];
    if (globalThis.WeakRef && weak instanceof globalThis.WeakRef)
      weak = weak.deref();
    return weak === undefined ? 0 : 1
  }
  function caml_hash_mix_final(h) {
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h
  }
  function caml_gr_text_size(txt) {
    var
    s = caml_gr_state_get(),
    w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size]
  }
  function caml_lex_run_mem(s, i, mem, curr_pos) {
    for (; ;) {
      var dst = s.charCodeAt(i);
      i++;
      if (dst == 0xff) return;
      var src = s.charCodeAt(i);
      i++;
      if (src == 0xff)
        mem[dst + 1] = curr_pos;
      else
        mem[dst + 1] = mem[src + 1]
    }
  }
  function caml_lex_run_tag(s, i, mem) {
    for (; ;) {
      var dst = s.charCodeAt(i);
      i++;
      if (dst == 0xff) return;
      var src = s.charCodeAt(i);
      i++;
      if (src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1]
    }
  }
  function caml_new_lex_engine(tbl, start_state, lexbuf) {
    var
    lex_buffer = 2,
    lex_buffer_len = 3,
    lex_start_pos = 5,
    lex_curr_pos = 6,
    lex_last_pos = 7,
    lex_last_action = 8,
    lex_eof_reached = 9,
    lex_mem = 10,
    lex_base = 1,
    lex_backtrk = 2,
    lex_default = 3,
    lex_trans = 4,
    lex_check = 5,
    lex_base_code = 6,
    lex_backtrk_code = 7,
    lex_default_code = 8,
    lex_trans_code = 9,
    lex_check_code = 10,
    lex_code = 11;
    if (!tbl.lex_default) {
      tbl.lex_base = caml_lex_array(tbl[lex_base]);
      tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
      tbl.lex_check = caml_lex_array(tbl[lex_check]);
      tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
      tbl.lex_default = caml_lex_array(tbl[lex_default])
    }
    if (!tbl.lex_default_code) {
      tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
      tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
      tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
      tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
      tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])
    }
    if (tbl.lex_code == null)
      tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
      c,
      state = start_state,
      buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if (state >= 0) {
      lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = - 1
    }
    else
      state = - state - 1;
    for (; ;) {
      var base = tbl.lex_base[state];
      if (base < 0) {
        var pc_off = tbl.lex_base_code[state];
        caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
        return - base - 1
      }
      var backtrk = tbl.lex_backtrk[state];
      if (backtrk >= 0) {
        var pc_off = tbl.lex_backtrk_code[state];
        caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
        lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = backtrk
      }
      if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
        if (lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
      else { c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++ }
      var pstate = state;
      if (tbl.lex_check[base + c] == state)
        state = tbl.lex_trans[base + c];
      else
        state = tbl.lex_default[state];
      if (state < 0) {
        lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
        if (lexbuf[lex_last_action] == - 1)
          caml_failwith("lexing: empty token");
        else
          return lexbuf[lex_last_action]
      }
      else {
        var base_code = tbl.lex_base_code[pstate], pc_off;
        if (tbl.lex_check_code[base_code + c] == pstate)
          pc_off = tbl.lex_trans_code[base_code + c];
        else
          pc_off = tbl.lex_default_code[pstate];
        if (pc_off > 0)
          caml_lex_run_mem
            (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
        if (c == 256) lexbuf[lex_eof_reached] = 0
      }
    }
  }
  function caml_ba_uint8_set64(ba, i0, v) {
    var ofs = ba.offset(i0);
    if (ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for (var i = 0; i < 8; i++)ba.set(ofs + i, v[7 - i]);
    return 0
  }
  function caml_sys_executable_name(a) { return caml_executable_name }
  function caml_lessequal(x, y) { return + (caml_compare_val(x, y, false) <= 0) }
  function caml_acosh_float(x) { return Math.acosh(x) }
  function caml_MD5Init() {
    var
    buffer = new ArrayBuffer(64),
    b32 = new Uint32Array(buffer),
    b8 = new Uint8Array(buffer);
    return {
      len: 0,
      w: new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
      b32: b32,
      b8: b8
    }
  }
  function caml_ml_flush(chanid) {
    var chan = caml_ml_channels[chanid];
    if (!chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if (!chan.buffer || chan.buffer_curr == 0) return 0;
    if (chan.output)
      chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
      chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0
  }
  function caml_seek_out(chanid, pos) {
    caml_ml_flush(chanid);
    var chan = caml_ml_channels[chanid];
    chan.offset = pos;
    return 0
  }
  function caml_ml_seek_out_64(chanid, pos) { var pos = caml_int64_to_float(pos); return caml_seek_out(chanid, pos) }
  function compare_nat_real(nat1, nat2) { return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length) }
  function caml_gc_set(_control) { return 0 }
  function caml_js_get(o, f) { return o[f] }
  function caml_unix_isatty(fileDescriptor) {
    if (fs_node_supported()) { var tty = require("tty"); return tty.isatty(fileDescriptor) ? 1 : 0 }
    else
      return 0
  }
  function caml_ml_set_buffered(chanid, v) {
    caml_ml_channels[chanid].buffered = v;
    if (!v) caml_ml_flush(chanid);
    return 0
  }
  function caml_gc_compaction() { return 0 }
  function caml_ephe_get_key(x, i) {
    if (i < 0 || caml_ephe_key_offset + i >= x.length)
      caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if (globalThis.WeakRef && weak instanceof globalThis.WeakRef)
      weak = weak.deref();
    return weak === undefined ? 0 : [0, weak]
  }
  function caml_unix_localtime(t) {
    var
    d = new Date(t * 1000),
    d_num = d.getTime(),
    januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
    doy = Math.floor((d_num - januaryfirst) / 86400000),
    jan = new Date(d.getFullYear(), 0, 1),
    jul = new Date(d.getFullYear(), 6, 1),
    stdTimezoneOffset =
      Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
      d.getSeconds(),
      d.getMinutes(),
      d.getHours(),
      d.getDate(),
      d.getMonth(),
      d.getFullYear() - 1900,
      d.getDay(),
      doy,
      d.getTimezoneOffset() < stdTimezoneOffset | 0]
  }
  function caml_unix_mktime(tm) {
    var
    d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
    t = Math.floor(d / 1000),
    tm2 = caml_unix_localtime(t);
    return [0, t, tm2]
  }
  function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len) {
    if (12 != ba2.kind)
      caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
    if (len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if (pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if (ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0
  }
  var caml_sys_fds = new Array(3);
  function caml_sys_close(fd) {
    var file = caml_sys_fds[fd];
    if (file) file.close();
    delete caml_sys_fds[fd];
    return 0
  }
  function caml_ml_close_channel(chanid) {
    var chan = caml_ml_channels[chanid];
    chan.opened = false;
    caml_sys_close(chan.fd);
    return 0
  }
  function caml_exn_with_js_backtrace(exn, force) {
    if (!exn.js_error || force || exn[0] == 248)
      exn.js_error
        =
        new (globalThis.Error)("Js exception containing backtrace");
    return exn
  }
  function caml_atomic_exchange(ref, v) { var r = ref[1]; ref[1] = v; return r }
  function caml_sys_isatty(_chan) { return 0 }
  function is_digit_zero(nat, ofs) { if (nat.data[ofs] == 0) return 1; return 0 }
  function caml_unix_lstat(name) {
    var root = resolve_fs_device(name);
    if (!root.device.lstat)
      caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true)
  }
  function caml_unix_lstat_64(name) { var r = caml_unix_lstat(name); r[9] = caml_int64_of_int32(r[9]) }
  function caml_js_set(o, f, v) { o[f] = v; return 0 }
  function caml_array_get(array, index) {
    if (index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1]
  }
  function caml_continuation_use_noexc(cont) { var stack = cont[1]; cont[1] = 0; return stack }
  function caml_unix_rmdir(name) {
    var root = resolve_fs_device(name);
    if (!root.device.rmdir)
      caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true)
  }
  function caml_log2_float(x) { return Math.log2(x) }
  function caml_gc_huge_fallback_count(unit) { return 0 }
  function caml_spacetime_only_works_for_native_code() { caml_failwith("Spacetime profiling only works for native code") }
  function caml_int64_sub(x, y) { return x.sub(y) }
  function caml_seek_in(chanid, pos) {
    var chan = caml_ml_channels[chanid];
    if (chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
      (pos
      >=
      chan.offset
      -
      chan.buffer_max
      &&
      pos
      <=
      chan.offset
      &&
      chan.file.flags.binary)
      chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else { chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0 }
    return 0
  }
  function caml_ml_seek_in_64(chanid, pos) { var pos = caml_int64_to_float(pos); return caml_seek_in(chanid, pos) }
  var caml_domain_id = 0;
  function caml_ml_mutex_unlock(t) { t.locked = false; return 0 }
  var caml_domain_latest_idx = 1;
  function caml_domain_spawn(f, mutex) {
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id
  }
  function caml_unix_mkdir(name, perm) {
    var root = resolve_fs_device(name);
    if (!root.device.mkdir)
      caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true)
  }
  function caml_int64_shift_left(x, s) { return x.shift_left(s) }
  function caml_notequal(x, y) { return + (caml_compare_val(x, y, false) != 0) }
  function caml_sys_const_int_size() { return 32 }
  function caml_js_wrap_callback(f) {
    return function () {
      var len = arguments.length;
      if (len > 0) {
        var args = new Array(len);
        for (var i = 0; i < len; i++)args[i] = arguments[i]
      }
      else
        args = [undefined];
      var res = caml_callback(f, args);
      return res instanceof Function ? caml_js_wrap_callback(res) : res
    }
  }
  function caml_js_wrap_meth_callback(f) {
    return function () {
      var len = arguments.length, args = new Array(len + 1);
      args[0] = this;
      for (var i = 0; i < len; i++)args[i + 1] = arguments[i];
      var res = caml_callback(f, args);
      return res instanceof Function ? caml_js_wrap_callback(res) : res
    }
  }
  function caml_is_js() { return 1 }
  function caml_lazy_update_to_forward(o) { caml_obj_update_tag(o, 244, 250); return 0 }
  function caml_ba_dim(ba, i) {
    if (i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i]
  }
  function caml_ba_dim_1(ba) { return caml_ba_dim(ba, 0) }
  function caml_js_meth_call(o, f, args) { return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args)) }
  var caml_ephe_data_offset = 2;
  function caml_weak_create(n) {
    if (n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x
  }
  function caml_ephe_create(n) { var x = caml_weak_create(n); return x }
  function caml_js_to_byte_string(s) { return caml_string_of_jsbytes(s) }
  function caml_trampoline(res) {
    var c = 1;
    while (res && res.joo_tramp) { res = res.joo_tramp.apply(null, res.joo_args); c++ }
    return res
  }
  function caml_maybe_print_stats(unit) { return 0 }
  function caml_bytes_get64(s, i) {
    if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for (var j = 0; j < 8; j++)a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a)
  }
  function caml_unix_has_symlink(unit) { return fs_node_supported() ? 1 : 0 }
  function caml_ephe_set_key(x, i, v) {
    if (i < 0 || caml_ephe_key_offset + i >= x.length)
      caml_invalid_argument("Weak.set");
    if (v instanceof Object && globalThis.WeakRef) {
      if (x[1].register) x[1].register(v, undefined, v);
      x[caml_ephe_key_offset + i] = new (globalThis.WeakRef)(v)
    }
    else
      x[caml_ephe_key_offset + i] = v;
    return 0
  }
  function caml_ephe_unset_key(x, i) {
    if (i < 0 || caml_ephe_key_offset + i >= x.length)
      caml_invalid_argument("Weak.set");
    if
      (globalThis.WeakRef
      &&
      x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      &&
      x[1].unregister) {
      var old = x[caml_ephe_key_offset + i].deref();
      if (old !== undefined) {
        var count = 0;
        for (var j = caml_ephe_key_offset; j < x.length; j++) {
          var key = x[j];
          if (key instanceof globalThis.WeakRef) { key = key.deref(); if (key === old) count++ }
        }
        if (count == 1) x[1].unregister(old)
      }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0
  }
  function caml_weak_set(x, i, v) {
    if (v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0
  }
  function caml_sys_remove(name) {
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if (ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0
  }
  function caml_string_bound_error() { caml_invalid_argument("index out of bounds") }
  function caml_string_get32(s, i) {
    if (i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
      b1 = caml_string_unsafe_get(s, i),
      b2 = caml_string_unsafe_get(s, i + 1),
      b3 = caml_string_unsafe_get(s, i + 2),
      b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1
  }
  function caml_bytes_get(s, i) {
    if (i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i)
  }
  function caml_hypot_float(x, y) { return Math.hypot(x, y) }
  function caml_js_call(f, o, args) { return f.apply(o, caml_js_from_array(args)) }
  function caml_sys_const_max_wosize() { return 0x7FFFFFFF / 4 | 0 }
  function caml_unix_inet_addr_of_string() { return 0 }
  function caml_hash_mix_bytes_arr(h, s) {
    var len = s.length, i, w;
    for (i = 0; i + 4 <= len; i += 4) {
      w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
      h = caml_hash_mix_int(h, w)
    }
    w = 0;
    switch (len & 3) {
      case 3: w = s[i + 2] << 16;
      case 2: w |= s[i + 1] << 8;
      case 1: w |= s[i]; h = caml_hash_mix_int(h, w)
    }
    h ^= len;
    return h
  }
  function caml_hash_mix_jsbytes(h, s) {
    var len = s.length, i, w;
    for (i = 0; i + 4 <= len; i += 4) {
      w
      =
      s.charCodeAt(i)
      |
      s.charCodeAt(i + 1)
      <<
      8
      |
      s.charCodeAt(i + 2)
      <<
      16
      |
      s.charCodeAt(i + 3)
      <<
      24;
      h = caml_hash_mix_int(h, w)
    }
    w = 0;
    switch (len & 3) {
      case 3: w = s.charCodeAt(i + 2) << 16;
      case 2: w |= s.charCodeAt(i + 1) << 8;
      case 1: w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w)
    }
    h ^= len;
    return h
  }
  function caml_ml_bytes_content(s) {
    switch (s.t & 6) {
      default: caml_convert_string_to_bytes(s); case 0: return s.c;
      case 4: return s.c
    }
  }
  function caml_hash_mix_bytes(h, v) {
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
      ? caml_hash_mix_jsbytes(h, content)
      : caml_hash_mix_bytes_arr(h, content)
  }
  function caml_bytes_lessthan(s1, s2) {
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0
  }
  function caml_erfc_float(x) { return 1 - caml_erf_float(x) }
  function caml_gr_fill_poly(ar) {
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for (var i = 2; i < ar.length; i++)
      s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0
  }
  function caml_gc_quick_stat() { return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
  function caml_ml_input_char(chanid) {
    var chan = caml_ml_channels[chanid];
    if (chan.buffer_curr >= chan.buffer_max) { chan.buffer_curr = 0; chan.buffer_max = 0; caml_refill(chan) }
    if (chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res
  }
  function caml_ml_input_int(chanid) {
    var chan = caml_ml_channels[chanid], res = 0;
    for (var i = 0; i < 4; i++)res = (res << 8) + caml_ml_input_char(chanid);
    return res
  }
  function caml_gr_display_mode() { caml_failwith("caml_gr_display_mode not Implemented") }
  function caml_obj_reachable_words(o) { return 0 }
  function nth_digit_nat(nat, ofs) { return nat.data[ofs] }
  function caml_array_blit(a1, i1, a2, i2, len) {
    if (i2 <= i1)
      for (var j = 1; j <= len; j++)a2[i2 + j] = a1[i1 + j];
    else
      for (var j = len; j >= 1; j--)a2[i2 + j] = a1[i1 + j];
    return 0
  }
  function caml_float_of_string(s) {
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if (s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if (s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if (m) {
      var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
      res = mantissa * Math.pow(2, exponent);
      return res
    }
    if (/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if (/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string")
  }
  function caml_sys_getcwd() { return caml_string_of_jsbytes(caml_current_dir) }
  function caml_int64_add(x, y) { return x.add(y) }
  function caml_int64_mul(x, y) { return x.mul(y) }
  function caml_int64_ult(x, y) { return x.ucompare(y) < 0 }
  function caml_parse_sign_and_base(s) {
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if (len > 0)
      switch (caml_string_unsafe_get(s, i)) { case 45: i++; sign = - 1; break; case 43: i++; sign = 1; break }
    if (i + 1 < len && caml_string_unsafe_get(s, i) == 48)
      switch (caml_string_unsafe_get(s, i + 1)) {
        case 120:
        case 88: base = 16; i += 2; break;
        case 111:
        case 79: base = 8; i += 2; break;
        case 98:
        case 66: base = 2; i += 2; break;
        case 117:
        case 85: i += 2; break
      }
    return [i, sign, base]
  }
  function caml_parse_digit(c) {
    if (c >= 48 && c <= 57) return c - 48;
    if (c >= 65 && c <= 90) return c - 55;
    if (c >= 97 && c <= 122) return c - 87;
    return - 1
  }
  function caml_int64_of_string(s) {
    var
    r = caml_parse_sign_and_base(s),
    i = r[0],
    sign = r[1],
    base = r[2],
    base64 = caml_int64_of_int32(base),
    threshold =
      new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
    c = caml_string_unsafe_get(s, i),
    d = caml_parse_digit(c);
    if (d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for (; ;) {
      i++;
      c = caml_string_unsafe_get(s, i);
      if (c == 95) continue;
      d = caml_parse_digit(c);
      if (d < 0 || d >= base) break;
      if (caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
      d = caml_int64_of_int32(d);
      res = caml_int64_add(caml_int64_mul(base64, res), d);
      if (caml_int64_ult(res, d)) caml_failwith("int_of_string")
    }
    if (i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if (base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
      caml_failwith("int_of_string");
    if (sign < 0) res = caml_int64_neg(res);
    return res
  }
  function caml_ba_set_1(ba, i0, v) { ba.set(ba.offset(i0), v); return 0 }
  function caml_int64_xor(x, y) { return x.xor(y) }
  function caml_int64_or(x, y) { return x.or(y) }
  function caml_lxm_next(v) {
    function shift_l(x, k) { return caml_int64_shift_left(x, k) }
    function shift_r(x, k) { return caml_int64_shift_right_unsigned(x, k) }
    function or(a, b) { return caml_int64_or(a, b) }
    function xor(a, b) { return caml_int64_xor(a, b) }
    function add(a, b) { return caml_int64_add(a, b) }
    function mul(a, b) { return caml_int64_mul(a, b) }
    function rotl(x, k) { return or(shift_l(x, k), shift_r(x, 64 - k)) }
    function get(a, i) { return caml_ba_get_1(a, i) }
    function set(a, i, x) { return caml_ba_set_1(a, i, x) }
    var
      M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
      daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
      z,
      q0,
      q1,
      st = v,
      a = get(st, 0),
      s = get(st, 1),
      x0 = get(st, 2),
      x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z
  }
  function caml_sys_const_big_endian() { return 0 }
  function caml_list_to_js_array(l) { var a = []; for (; l !== 0; l = l[2])a.push(l[1]); return a }
  var
    caml_legacy_custom_code = false,
    caml_output_val =
      function () {
        function Writer() { this.chunk = [] }
        Writer.prototype
          =
        {
          chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
            function (size, value) {
              for (var i = size - 8; i >= 0; i -= 8)
                this.chunk[this.chunk_idx++] = value >> i & 0xFF
            },
          write_at:
            function (pos, size, value) {
              var pos = pos;
              for (var i = size - 8; i >= 0; i -= 8)
                this.chunk[pos++] = value >> i & 0xFF
            },
          write_code:
            function (size, code, value) {
              this.chunk[this.chunk_idx++] = code;
              for (var i = size - 8; i >= 0; i -= 8)
                this.chunk[this.chunk_idx++] = value >> i & 0xFF
            },
          write_shared:
            function (offset) {
              if (offset < 1 << 8)
                this.write_code(8, 0x04, offset);
              else
                if (offset < 1 << 16)
                  this.write_code(16, 0x05, offset);
                else
                  this.write_code(32, 0x06, offset)
            },
          pos: function () { return this.chunk_idx },
          finalize:
            function () {
              this.block_len = this.chunk_idx - 20;
              this.chunk_idx = 0;
              this.write(32, 0x8495A6BE);
              this.write(32, this.block_len);
              this.write(32, this.obj_counter);
              this.write(32, this.size_32);
              this.write(32, this.size_64);
              return this.chunk
            }
        };
        return function (v, flags) {
          flags = caml_list_to_js_array(flags);
          var
            no_sharing = flags.indexOf(0) !== - 1,
            closures = flags.indexOf(1) !== - 1;
          if (closures)
            console.warn
              ("in caml_output_val: flag Marshal.Closures is not supported.");
          var
            writer = new Writer(),
            stack = [],
            intern_obj_table = no_sharing ? null : new MlObjectTable();
          function memo(v) {
            if (no_sharing) return false;
            var existing_offset = intern_obj_table.recall(v);
            if (existing_offset) { writer.write_shared(existing_offset); return true }
            else { intern_obj_table.store(v); return false }
          }
          function extern_rec(v) {
            if (v.caml_custom) {
              if (memo(v)) return;
              var
                name = v.caml_custom,
                ops = caml_custom_ops[name],
                sz_32_64 = [0, 0];
              if (!ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
              if (caml_legacy_custom_code) {
                writer.write(8, 0x12);
                for (var i = 0; i < name.length; i++)
                  writer.write(8, name.charCodeAt(i));
                writer.write(8, 0);
                ops.serialize(writer, v, sz_32_64)
              }
              else
                if (ops.fixed_length == undefined) {
                  writer.write(8, 0x18);
                  for (var i = 0; i < name.length; i++)
                    writer.write(8, name.charCodeAt(i));
                  writer.write(8, 0);
                  var header_pos = writer.pos();
                  for (var i = 0; i < 12; i++)writer.write(8, 0);
                  ops.serialize(writer, v, sz_32_64);
                  writer.write_at(header_pos, 32, sz_32_64[0]);
                  writer.write_at(header_pos + 4, 32, 0);
                  writer.write_at(header_pos + 8, 32, sz_32_64[1])
                }
                else {
                  writer.write(8, 0x19);
                  for (var i = 0; i < name.length; i++)
                    writer.write(8, name.charCodeAt(i));
                  writer.write(8, 0);
                  var old_pos = writer.pos();
                  ops.serialize(writer, v, sz_32_64);
                  if (ops.fixed_length != writer.pos() - old_pos)
                    caml_failwith
                      ("output_value: incorrect fixed sizes specified by " + name)
                }
              writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
              writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)
            }
            else
              if (v instanceof Array && v[0] === (v[0] | 0)) {
                if (v[0] == 251)
                  caml_failwith("output_value: abstract value (Abstract)");
                if (caml_is_continuation_tag(v[0]))
                  caml_invalid_argument("output_value: continuation value");
                if (v.length > 1 && memo(v)) return;
                if (v[0] < 16 && v.length - 1 < 8)
                  writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
                else
                  writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if (v.length > 1) stack.push(v, 1)
              }
              else
                if (caml_is_ml_bytes(v)) {
                  if (!caml_is_ml_bytes(caml_string_of_jsbytes("")))
                    caml_failwith
                      ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                  if (memo(v)) return;
                  var len = caml_ml_bytes_length(v);
                  if (len < 0x20)
                    writer.write(8, 0x20 + len);
                  else
                    if (len < 0x100)
                      writer.write_code(8, 0x09, len);
                    else
                      writer.write_code(32, 0x0A, len);
                  for (var i = 0; i < len; i++)
                    writer.write(8, caml_bytes_unsafe_get(v, i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)
                }
                else
                  if (caml_is_ml_string(v)) {
                    var len = caml_ml_string_length(v);
                    if (len < 0x20)
                      writer.write(8, 0x20 + len);
                    else
                      if (len < 0x100)
                        writer.write_code(8, 0x09, len);
                      else
                        writer.write_code(32, 0x0A, len);
                    for (var i = 0; i < len; i++)
                      writer.write(8, caml_string_unsafe_get(v, i));
                    writer.size_32 += 1 + ((len + 4) / 4 | 0);
                    writer.size_64 += 1 + ((len + 8) / 8 | 0)
                  }
                  else
                    if (v != (v | 0)) {
                      var type_of_v = typeof v;
                      caml_failwith
                        ("output_value: abstract value (" + type_of_v + ")")
                    }
                    else
                      if (v >= 0 && v < 0x40)
                        writer.write(8, 0X40 + v);
                      else
                        if (v >= - (1 << 7) && v < 1 << 7)
                          writer.write_code(8, 0x00, v);
                        else
                          if (v >= - (1 << 15) && v < 1 << 15)
                            writer.write_code(16, 0x01, v);
                          else
                            writer.write_code(32, 0x02, v)
          }
          extern_rec(v);
          while (stack.length > 0) {
            var i = stack.pop(), v = stack.pop();
            if (i + 1 < v.length) stack.push(v, i + 1);
            extern_rec(v[i])
          }
          if (intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
          writer.finalize();
          return writer.chunk
        }
      }
        ();
  function caml_string_of_array(a) { return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length)) }
  function caml_output_value_to_string(v, flags) { return caml_string_of_array(caml_output_val(v, flags)) }
  function caml_raise_not_a_dir(name) { caml_raise_sys_error(name + ": Not a directory") }
  function caml_sys_system_command(cmd) {
    var cmd = caml_jsstring_of_string(cmd);
    if (typeof require != "undefined") {
      var child_process = require("child_process");
      if (child_process && child_process.execSync)
        try { child_process.execSync(cmd, { stdio: "inherit" }); return 0 }
        catch (e) { return 1 }
    }
    else
      return 127
  }
  function caml_js_error_of_exception(exn) { if (exn.js_error) return exn.js_error; return null }
  function caml_unix_getuid(unit) {
    if (globalThis.process && globalThis.process.getuid)
      return globalThis.process.getuid();
    caml_raise_not_found()
  }
  function deserialize_nat(reader, sz) {
    var len = reader.read32s(), nat = new MlNat(len);
    for (var i = 0; i < len; i++)nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat
  }
  function initialize_nat() {
    caml_custom_ops["_nat"]
    =
    { deserialize: deserialize_nat, serialize: serialize_nat, hash: caml_hash_nat }
  }
  function caml_gr_open_subwindow(a, b, c, d) { caml_failwith("caml_gr_open_subwindow not Implemented") }
  function caml_marshal_data_size(s, ofs) {
    function get32(s, i) {
      return caml_bytes_unsafe_get(s, i)
        <<
        24
        |
        caml_bytes_unsafe_get(s, i + 1)
        <<
        16
        |
        caml_bytes_unsafe_get(s, i + 2)
        <<
        8
        |
        caml_bytes_unsafe_get(s, i + 3)
    }
    if (get32(s, ofs) != (0x8495A6BE | 0))
      caml_failwith("Marshal.data_size: bad object");
    return get32(s, ofs + 4)
  }
  function MlStringReader(s, i) { this.s = caml_jsbytes_of_string(s); this.i = i }
  MlStringReader.prototype
    =
  {
    read8u: function () { return this.s.charCodeAt(this.i++) },
    read8s: function () { return this.s.charCodeAt(this.i++) << 24 >> 24 },
    read16u:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 2;
        return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)
      },
    read16s:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 2;
        return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)
      },
    read32u:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 4;
        return (s.charCodeAt(i)
          <<
          24
          |
          s.charCodeAt(i + 1)
          <<
          16
          |
          s.charCodeAt(i + 2)
          <<
          8
          |
          s.charCodeAt(i + 3))
          >>>
          0
      },
    read32s:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 4;
        return s.charCodeAt(i)
          <<
          24
          |
          s.charCodeAt(i + 1)
          <<
          16
          |
          s.charCodeAt(i + 2)
          <<
          8
          |
          s.charCodeAt(i + 3)
      },
    readstr:
      function (len) {
        var i = this.i;
        this.i = i + len;
        return caml_string_of_jsbytes(this.s.substring(i, i + len))
      }
  };
  function caml_float_of_bytes(a) { return caml_int64_float_of_bits(caml_int64_of_bytes(a)) }
  function caml_input_value_from_reader(reader, ofs) {
    var
    _magic = reader.read32u(),
    _block_len = reader.read32u(),
    num_objects = reader.read32u(),
    _size_32 = reader.read32u(),
    _size_64 = reader.read32u(),
    stack = [],
    intern_obj_table = num_objects > 0 ? [] : null,
    obj_counter = 0;
    function intern_rec() {
      var code = reader.read8u();
      if (code >= 0x40)
        if (code >= 0x80) {
          var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
          if (size == 0) return v;
          if (intern_obj_table) intern_obj_table[obj_counter++] = v;
          stack.push(v, size);
          return v
        }
        else
          return code & 0x3F;
      else
        if (code >= 0x20) {
          var len = code & 0x1F, v = reader.readstr(len);
          if (intern_obj_table) intern_obj_table[obj_counter++] = v;
          return v
        }
        else
          switch (code) {
            case 0x00: return reader.read8s();
            case 0x01: return reader.read16s();
            case 0x02: return reader.read32s();
            case 0x03: caml_failwith("input_value: integer too large"); break;
            case 0x04:
              var offset = reader.read8u();
              return intern_obj_table[obj_counter - offset];
            case 0x05:
              var offset = reader.read16u();
              return intern_obj_table[obj_counter - offset];
            case 0x06:
              var offset = reader.read32u();
              return intern_obj_table[obj_counter - offset];
            case 0x08:
              var
                header = reader.read32u(),
                tag = header & 0xFF,
                size = header >> 10,
                v = [tag];
              if (size == 0) return v;
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              stack.push(v, size);
              return v;
            case 0x13:
              caml_failwith("input_value: data block too large"); break;
            case 0x09:
              var len = reader.read8u(), v = reader.readstr(len);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              return v;
            case 0x0A:
              var len = reader.read32u(), v = reader.readstr(len);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              return v;
            case 0x0C:
              var t = new Array(8);
              for (var i = 0; i < 8; i++)t[7 - i] = reader.read8u();
              var v = caml_float_of_bytes(t);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              return v;
            case 0x0B:
              var t = new Array(8);
              for (var i = 0; i < 8; i++)t[i] = reader.read8u();
              var v = caml_float_of_bytes(t);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              return v;
            case 0x0E:
              var len = reader.read8u(), v = new Array(len + 1);
              v[0] = 254;
              var t = new Array(8);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              for (var i = 1; i <= len; i++) {
                for (var j = 0; j < 8; j++)t[7 - j] = reader.read8u();
                v[i] = caml_float_of_bytes(t)
              }
              return v;
            case 0x0D:
              var len = reader.read8u(), v = new Array(len + 1);
              v[0] = 254;
              var t = new Array(8);
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              for (var i = 1; i <= len; i++) {
                for (var j = 0; j < 8; j++)t[j] = reader.read8u();
                v[i] = caml_float_of_bytes(t)
              }
              return v;
            case 0x07:
              var len = reader.read32u(), v = new Array(len + 1);
              v[0] = 254;
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              var t = new Array(8);
              for (var i = 1; i <= len; i++) {
                for (var j = 0; j < 8; j++)t[7 - j] = reader.read8u();
                v[i] = caml_float_of_bytes(t)
              }
              return v;
            case 0x0F:
              var len = reader.read32u(), v = new Array(len + 1);
              v[0] = 254;
              var t = new Array(8);
              for (var i = 1; i <= len; i++) {
                for (var j = 0; j < 8; j++)t[j] = reader.read8u();
                v[i] = caml_float_of_bytes(t)
              }
              return v;
            case 0x10:
            case 0x11: caml_failwith("input_value: code pointer"); break;
            case 0x12:
            case 0x18:
            case 0x19:
              var c, s = "";
              while ((c = reader.read8u()) != 0) s += String.fromCharCode(c);
              var ops = caml_custom_ops[s], expected_size;
              if (!ops)
                caml_failwith("input_value: unknown custom block identifier");
              switch (code) {
                case 0x12: break;
                case 0x19:
                  if (!ops.fixed_length)
                    caml_failwith
                      ("input_value: expected a fixed-size custom block");
                  expected_size = ops.fixed_length;
                  break;
                case 0x18:
                  expected_size = reader.read32u();
                  reader.read32s();
                  reader.read32s();
                  break
              }
              var old_pos = reader.i, size = [0], v = ops.deserialize(reader, size);
              if (expected_size != undefined)
                if (expected_size != size[0])
                  caml_failwith
                    ("input_value: incorrect length of serialized custom block");
              if (intern_obj_table) intern_obj_table[obj_counter++] = v;
              return v;
            default: caml_failwith("input_value: ill-formed message")
          }
    }
    var res = intern_rec();
    while (stack.length > 0) {
      var size = stack.pop(), v = stack.pop(), d = v.length;
      if (d < size) stack.push(v, size);
      v[d] = intern_rec()
    }
    if (typeof ofs != "number") ofs[0] = reader.i;
    return res
  }
  function caml_string_of_bytes(s) { return s }
  function caml_input_value_from_bytes(s, ofs) {
    var
    reader =
      new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs)
  }
  function caml_input_value(chanid) {
    var chan = caml_ml_channels[chanid], header = new Uint8Array(20);
    function block(buffer, offset, n) {
      var r = 0;
      while (r < n) {
        if (chan.buffer_curr >= chan.buffer_max) { chan.buffer_curr = 0; chan.buffer_max = 0; caml_refill(chan) }
        if (chan.buffer_curr >= chan.buffer_max) break;
        buffer[offset + r] = chan.buffer[chan.buffer_curr];
        chan.buffer_curr++;
        r++
      }
      return r
    }
    var r = block(header, 0, 20);
    if (r == 0)
      caml_raise_end_of_file();
    else
      if (r < 20) caml_failwith("input_value: truncated object");
    var len = caml_marshal_data_size(caml_bytes_of_array(header), 0);
    var buf = new Uint8Array(len + 20);
    buf.set(header, 0);
    var r = block(buf, 20, len);
    if (r < len)
      caml_failwith("input_value: truncated object " + r + "  " + len);
    var
      offset = [0],
      res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res
  }
  function caml_input_value_to_outside_heap(c) { return caml_input_value(c) }
  function caml_atomic_cas(ref, o, n) { if (ref[1] === o) { ref[1] = n; return 1 } return 0 }
  function caml_copysign_float(x, y) { if (y == 0) y = 1 / y; x = Math.abs(x); return y < 0 ? - x : x }
  function caml_gr_set_text_size(size) {
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0
  }
  function caml_atomic_load(ref) { return ref[1] }
  function caml_MD5Final(ctx) {
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if (in_buf > 56) {
      for (var j = in_buf; j < 64; j++)ctx.b8[j] = 0;
      caml_MD5Transform(ctx.w, ctx.b32);
      for (var j = 0; j < 56; j++)ctx.b8[j] = 0
    }
    else
      for (var j = in_buf; j < 56; j++)ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for (var i = 0; i < 4; i++)
      for (var j = 0; j < 4; j++)t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t
  }
  function caml_md5_bytes(s, ofs, len) {
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx))
  }
  function caml_ba_set_generic(ba, i, v) { ba.set(ba.offset(caml_js_from_array(i)), v); return 0 }
  function caml_ml_condition_wait(t, mutext) { return 0 }
  function caml_bytes_lessequal(s1, s2) {
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0
  }
  function caml_string_lessequal(s1, s2) { return caml_bytes_lessequal(s1, s2) }
  function caml_string_greaterequal(s1, s2) { return caml_string_lessequal(s2, s1) }
  function caml_nextafter_float(x, y) {
    if (isNaN(x) || isNaN(y)) return NaN;
    if (x == y) return y;
    if (x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if (x < y == x > 0)
      bits = caml_int64_add(bits, one);
    else
      bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits)
  }
  function caml_gr_size_y() { var s = caml_gr_state_get(); return s.height }
  function caml_pos_in(chanid) {
    var chan = caml_ml_channels[chanid];
    return chan.offset - (chan.buffer_max - chan.buffer_curr)
  }
  function caml_ml_pos_in(chanid) { return caml_pos_in(chanid) }
  function caml_int64_and(x, y) { return x.and(y) }
  function caml_sys_const_word_size() { return 32 }
  function caml_unix_unlink(name) {
    var root = resolve_fs_device(name);
    if (!root.device.unlink)
      caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true)
  }
  function caml_sys_open_for_node(fd, flags) {
    if (flags.name)
      try {
        var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
        return new MlNodeFd(fd2, flags)
      }
      catch (e) { }
    return new MlNodeFd(fd, flags)
  }
  function MlFakeFd_out(fd, flags) {
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function (s) { return 0 };
    if (fd == 1 && typeof console.log == "function")
      this.log = console.log;
    else
      if (fd == 2 && typeof console.error == "function")
        this.log = console.error;
      else
        if (typeof console.log == "function") this.log = console.log;
    this.flags = flags
  }
  MlFakeFd_out.prototype.length = function () { return 0 };
  MlFakeFd_out.prototype.write
    =
    function (offset, buf, pos, len) {
      if (this.log) {
        if
          (len
          >
          0
          &&
          pos
          >=
          0
          &&
          pos
          +
          len
          <=
          buf.length
          &&
          buf[pos + len - 1]
          ==
          10)
          len--;
        var src = caml_create_bytes(len);
        caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
        this.log(src.toUtf16());
        return 0
      }
      caml_raise_sys_error(this.fd + ": file descriptor already closed")
    };
  MlFakeFd_out.prototype.read
    =
    function (offset, buf, pos, len) { caml_raise_sys_error(this.fd + ": file descriptor is write only") };
  MlFakeFd_out.prototype.close = function () { this.log = undefined };
  function caml_sys_open_internal(file, idx) {
    if (idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx
  }
  function caml_sys_open(name, flags, _perms) {
    var f = {};
    while (flags) {
      switch (flags[1]) {
        case 0: f.rdonly = 1; break;
        case 1: f.wronly = 1; break;
        case 2: f.append = 1; break;
        case 3: f.create = 1; break;
        case 4: f.truncate = 1; break;
        case 5: f.excl = 1; break;
        case 6: f.binary = 1; break;
        case 7: f.text = 1; break;
        case 8: f.nonblock = 1; break
      }
      flags = flags[2]
    }
    if (f.rdonly && f.wronly)
      caml_raise_sys_error
        (caml_jsbytes_of_string(name)
          +
          " : flags Open_rdonly and Open_wronly are not compatible");
    if (f.text && f.binary)
      caml_raise_sys_error
        (caml_jsbytes_of_string(name)
          +
          " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined)
  }
  (function () {
    function file(fd, flags) {
      return fs_node_supported()
        ? caml_sys_open_for_node(fd, flags)
        : new MlFakeFd_out(fd, flags)
    }
    caml_sys_open_internal
      (file(0, { rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true }), 0);
    caml_sys_open_internal
      (file(1, { buffered: 2, wronly: 1, isCharacterDevice: true }), 1);
    caml_sys_open_internal
      (file(2, { buffered: 2, wronly: 1, isCharacterDevice: true }), 2)
  }
    ());
  function caml_string_get(s, i) {
    if (i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i)
  }
  var
    re_match =
      function () {
        var
        re_word_letters =
          [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
        opcodes =
        {
          CHAR: 0,
          CHARNORM: 1,
          STRING: 2,
          STRINGNORM: 3,
          CHARCLASS: 4,
          BOL: 5,
          EOL: 6,
          WORDBOUNDARY: 7,
          BEGGROUP: 8,
          ENDGROUP: 9,
          REFGROUP: 10,
          ACCEPT: 11,
          SIMPLEOPT: 12,
          SIMPLESTAR: 13,
          SIMPLEPLUS: 14,
          GOTO: 15,
          PUSHBACK: 16,
          SETMARK: 17,
          CHECKPROGRESS: 18
        };
        function is_word_letter(c) { return re_word_letters[c >> 3] >> (c & 7) & 1 }
        function in_bitset(s, i) { return caml_string_get(s, i >> 3) >> (i & 7) & 1 }
        function re_match_impl(re, s, pos, partial) {
          var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
          for (var i = 0; i < groups.length; i++)groups[i] = { start: - 1, end: - 1 };
          groups[0].start = pos;
          function backtrack() {
            while (stack.length) {
              var item = stack.pop();
              if (item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
              else
                if (item.pos) { pc = item.pos.pc; pos = item.pos.txt; return }
            }
            quit = true
          }
          function push(item) { stack.push(item) }
          function accept() {
            groups[0].end = pos;
            var result = new Array(1 + groups.length * 2);
            result[0] = 0;
            for (var i = 0; i < groups.length; i++) {
              var g = groups[i];
              if (g.start < 0 || g.end < 0) g.start = g.end = - 1;
              result[2 * i + 1] = g.start;
              result[2 * i + 1 + 1] = g.end
            }
            return result
          }
          function prefix_match() { if (partial) return accept(); else backtrack() }
          while (!quit) {
            var
            op = prog[pc] & 0xff,
            sarg = prog[pc] >> 8,
            uarg = sarg & 0xff,
            c = s[pos],
            group;
            pc++;
            switch (op) {
              case opcodes.CHAR:
                if (pos === s.length) { prefix_match(); break }
                if (c === uarg) pos++; else backtrack();
                break;
              case opcodes.CHARNORM:
                if (pos === s.length) { prefix_match(); break }
                if (normtable.charCodeAt(c) === uarg) pos++; else backtrack();
                break;
              case opcodes.STRING:
                for
                  (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
                  i
                  <
                  arg.length;
                  i++) {
                  if (pos === s.length) { prefix_match(); break }
                  if (c === arg.charCodeAt(i))
                    c = s[++pos];
                  else { backtrack(); break }
                }
                break;
              case opcodes.STRINGNORM:
                for
                  (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
                  i
                  <
                  arg.length;
                  i++) {
                  if (pos === s.length) { prefix_match(); break }
                  if (normtable.charCodeAt(c) === arg.charCodeAt(i))
                    c = s[++pos];
                  else { backtrack(); break }
                }
                break;
              case opcodes.CHARCLASS:
                if (pos === s.length) { prefix_match(); break }
                if (in_bitset(cpool[uarg], c)) pos++; else backtrack();
                break;
              case opcodes.BOL:
                if (pos > 0 && s[pos - 1] != 10) backtrack(); break;
              case opcodes.EOL:
                if (pos < s.length && s[pos] != 10) backtrack(); break;
              case opcodes.WORDBOUNDARY:
                if (pos == 0) {
                  if (pos === s.length) { prefix_match(); break }
                  if (is_word_letter(s[0])) break;
                  backtrack()
                }
                else
                  if (pos === s.length) { if (is_word_letter(s[pos - 1])) break; backtrack() }
                  else {
                    if (is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                      break;
                    backtrack()
                  }
                break;
              case opcodes.BEGGROUP:
                group = groups[uarg];
                push({ undo: { obj: group, prop: "start", value: group.start } });
                group.start = pos;
                break;
              case opcodes.ENDGROUP:
                group = groups[uarg];
                push({ undo: { obj: group, prop: "end", value: group.end } });
                group.end = pos;
                break;
              case opcodes.REFGROUP:
                group = groups[uarg];
                if (group.start < 0 || group.end < 0) { backtrack(); break }
                for (var i = group.start; i < group.end; i++) {
                  if (pos === s.length) { prefix_match(); break }
                  if (s[i] != s[pos]) { backtrack(); break }
                  pos++
                }
                break;
              case opcodes.SIMPLEOPT: if (in_bitset(cpool[uarg], c)) pos++; break;
              case opcodes.SIMPLESTAR:
                while (in_bitset(cpool[uarg], c)) c = s[++pos]; break;
              case opcodes.SIMPLEPLUS:
                if (pos === s.length) { prefix_match(); break }
                if (in_bitset(cpool[uarg], c))
                  do c = s[++pos]; while (in_bitset(cpool[uarg], c));
                else
                  backtrack();
                break;
              case opcodes.ACCEPT: return accept();
              case opcodes.GOTO: pc = pc + sarg; break;
              case opcodes.PUSHBACK: push({ pos: { pc: pc + sarg, txt: pos } }); break;
              case opcodes.SETMARK:
                push
                  ({ undo: { obj: re_register, prop: uarg, value: re_register[uarg] } });
                re_register[uarg] = pos;
                break;
              case opcodes.CHECKPROGRESS:
                if (re_register[uarg] === pos) backtrack(); break;
              default: throw new Error("Invalid bytecode")
            }
          }
          return 0
        }
        return re_match_impl
      }
        ();
  function re_search_backward(re, s, pos) {
    if (pos < 0 || pos > caml_ml_string_length(s))
      caml_invalid_argument("Str.search_backward");
    while (pos >= 0) { var res = re_match(re, s, pos, 0); if (res) return res; pos-- }
    return [0]
  }
  function caml_js_from_string(s) { return caml_jsstring_of_string(s) }
  function caml_ba_sub(ba, ofs, len) {
    var changed_dim, mul = 1;
    if (ba.layout == 0) {
      for (var i = 1; i < ba.dims.length; i++)mul = mul * ba.dims[i];
      changed_dim = 0
    }
    else {
      for (var i = 0; i < ba.dims.length - 1; i++)mul = mul * ba.dims[i];
      changed_dim = ba.dims.length - 1;
      ofs = ofs - 1
    }
    if (ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
      caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for (var i = 0; i < ba.dims.length; i++)new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data)
  }
  function caml_gc_full_major(unit) { if (typeof globalThis.gc == "function") globalThis.gc(); return 0 }
  function caml_ml_mutex_try_lock(t) { if (!t.locked) { t.locked = true; return 1 } return 0 }
  function caml_bytes_set32(s, i, i32) {
    if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
      b4 = 0xFF & i32 >> 24,
      b3 = 0xFF & i32 >> 16,
      b2 = 0xFF & i32 >> 8,
      b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0
  }
  function caml_gr_sigio_signal() { return 0 }
  function caml_ba_uint8_set32(ba, i0, v) {
    var ofs = ba.offset(i0);
    if (ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0
  }
  function caml_sys_const_ostype_unix() { return os_type == "Unix" ? 1 : 0 }
  function caml_unix_gmtime(t) {
    var
    d = new Date(t * 1000),
    d_num = d.getTime(),
    januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
    doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
      d.getUTCSeconds(),
      d.getUTCMinutes(),
      d.getUTCHours(),
      d.getUTCDate(),
      d.getUTCMonth(),
      d.getUTCFullYear() - 1900,
      d.getUTCDay(),
      doy,
      false | 0]
  }
  function caml_signbit_float(x) { if (x == 0) x = 1 / x; return x < 0 ? 1 : 0 }
  function caml_gr_set_line_width(w) {
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0
  }
  function caml_gr_set_font(f) {
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0
  }
  function caml_gr_set_color(color) {
    var s = caml_gr_state_get();
    function convert(number) {
      var str = "" + number.toString(16);
      while (str.length < 2) str = "0" + str;
      return str
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0
  }
  function caml_gr_moveto(x, y) { var s = caml_gr_state_get(); s.x = x; s.y = y; return 0 }
  function caml_gr_resize_window(w, h) {
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0
  }
  function caml_gr_state_init() {
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom"
  }
  function caml_gr_current_x() { var s = caml_gr_state_get(); return s.x }
  function caml_ba_kind_of_typed_array(ta) {
    var kind;
    if (ta instanceof Float32Array)
      kind = 0;
    else
      if (ta instanceof Float64Array)
        kind = 1;
      else
        if (ta instanceof Int8Array)
          kind = 2;
        else
          if (ta instanceof Uint8Array)
            kind = 3;
          else
            if (ta instanceof Int16Array)
              kind = 4;
            else
              if (ta instanceof Uint16Array)
                kind = 5;
              else
                if (ta instanceof Int32Array)
                  kind = 6;
                else
                  if (ta instanceof Uint32Array)
                    kind = 6;
                  else
                    caml_invalid_argument
                      ("caml_ba_kind_of_typed_array: unsupported kind");
    return kind
  }
  function caml_ba_from_typed_array(ta) {
    var kind = caml_ba_kind_of_typed_array(ta);
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta)
  }
  function caml_ml_seek_out(chanid, pos) { return caml_seek_out(chanid, pos) }
  function caml_js_typeof(o) { return typeof o }
  function caml_hash_mix_string(h, v) { return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v)) }
  function caml_string_hash(h, v) {
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF
  }
  function caml_restore_raw_backtrace(exn, bt) { return 0 }
  function caml_gr_lineto(x, y) {
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0
  }
  function caml_js_function_arity(f) { return f.length }
  function caml_js_wrap_meth_callback_unsafe(f) {
    return function () {
      var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
      args[0] = this;
      for (var i = 0; i < len; i++)args[i + 1] = arguments[i];
      return caml_callback(f, args)
    }
  }
  function caml_ba_dim_3(ba) { return caml_ba_dim(ba, 2) }
  function caml_is_special_exception(exn) { switch (exn[2]) { case - 8: case - 11: case - 12: return 1; default: return 0 } }
  function caml_format_exception(exn) {
    var r = "";
    if (exn[0] == 0) {
      r += exn[1][1];
      if
        (exn.length
        ==
        3
        &&
        exn[2][0]
        ==
        0
        &&
        caml_is_special_exception(exn[1]))
        var bucket = exn[2], start = 1;
      else
        var start = 2, bucket = exn;
      r += "(";
      for (var i = start; i < bucket.length; i++) {
        if (i > start) r += ", ";
        var v = bucket[i];
        if (typeof v == "number")
          r += v.toString();
        else
          if (v instanceof MlBytes)
            r += '"' + v.toString() + '"';
          else
            if (typeof v == "string")
              r += '"' + v.toString() + '"';
            else
              r += "_"
      }
      r += ")"
    }
    else
      if (exn[0] == 248) r += exn[1];
    return r
  }
  function caml_fatal_uncaught_exception(err) {
    if (err instanceof Array && (err[0] == 0 || err[0] == 248)) {
      var handler = caml_named_value("Printexc.handle_uncaught_exception");
      if (handler)
        caml_callback(handler, [err, false]);
      else {
        var
        msg = caml_format_exception(err),
        at_exit = caml_named_value("Pervasives.do_at_exit");
        if (at_exit) caml_callback(at_exit, [0]);
        console.error("Fatal error: exception " + msg + "\n")
      }
    }
    else
      throw err
  }
  function caml_ephe_check_data(x) { return x[caml_ephe_data_offset] === undefined ? 0 : 1 }
  function caml_bytes_get16(s, i) {
    if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b1 = caml_bytes_unsafe_get(s, i), b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1
  }
  function caml_obj_make_forward(b, v) { b[0] = 250; b[1] = v; return 0 }
  function caml_js_from_bool(x) { return ! !x }
  function caml_ml_set_channel_name(chanid, name) { var chan = caml_ml_channels[chanid]; chan.name = name; return 0 }
  function caml_exp2_float(x) { return Math.pow(2, x) }
  function caml_gr_close_graph() {
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0
  }
  function caml_ml_domain_cpu_relax(unit) { return 0 }
  function caml_create_string(len) {
    if (len < 0) caml_invalid_argument("String.create");
    return new MlBytes(len ? 2 : 9, "", len)
  }
  function caml_ml_input_block(chanid, ba, i, l) {
    var
    chan = caml_ml_channels[chanid],
    n = l,
    avail = chan.buffer_max - chan.buffer_curr;
    if (l <= avail) {
      ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
      chan.buffer_curr += l
    }
    else
      if (avail > 0) {
        ba.set
        (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
        chan.buffer_curr += avail;
        n = avail
      }
      else {
        chan.buffer_curr = 0;
        chan.buffer_max = 0;
        caml_refill(chan);
        var avail = chan.buffer_max - chan.buffer_curr;
        if (n > avail) n = avail;
        ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
        chan.buffer_curr += n
      }
    return n
  }
  function caml_md5_chan(chanid, toread) {
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if (toread < 0)
      while (true) {
        var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
        if (read == 0) break;
        caml_MD5Update(ctx, buffer.subarray(0, read), read)
      }
    else
      while (toread > 0) {
        var
        read =
          caml_ml_input_block
            (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
        if (read == 0) caml_raise_end_of_file();
        caml_MD5Update(ctx, buffer.subarray(0, read), read);
        toread -= read
      }
    return caml_string_of_array(caml_MD5Final(ctx))
  }
  function caml_atanh_float(x) { return Math.atanh(x) }
  function caml_ml_condition_signal(t) { return 0 }
  function caml_unix_findnext(dir_handle) { return caml_unix_readdir(dir_handle) }
  function caml_ml_output_bytes(chanid, buffer, offset, len) {
    var chan = caml_ml_channels[chanid];
    if (!chan.opened)
      caml_raise_sys_error("Cannot output to a closed channel");
    var buffer = caml_uint8_array_of_bytes(buffer);
    buffer = buffer.subarray(offset, offset + len);
    if (chan.buffer_curr + buffer.length > chan.buffer.length) {
      var b = new Uint8Array(chan.buffer_curr + buffer.length);
      b.set(chan.buffer);
      chan.buffer = b
    }
    switch (chan.buffered) {
      case 0:
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        caml_ml_flush(chanid);
        break;
      case 1:
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if (chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
        break;
      case 2:
        var id = buffer.lastIndexOf(10);
        if (id < 0) {
          chan.buffer.set(buffer, chan.buffer_curr);
          chan.buffer_curr += buffer.length;
          if (chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid)
        }
        else {
          chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
          chan.buffer_curr += id + 1;
          caml_ml_flush(chanid);
          chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
          chan.buffer_curr += buffer.length - id - 1
        }
        break
    }
    return 0
  }
  function caml_ml_output(chanid, buffer, offset, len) {
    return caml_ml_output_bytes
      (chanid, caml_bytes_of_string(buffer), offset, len)
  }
  function caml_ml_domain_id(unit) { return caml_domain_id }
  function caml_ephe_get_data(x) {
    return x[caml_ephe_data_offset] === undefined
      ? 0
      : [0, x[caml_ephe_data_offset]]
  }
  function caml_xmlhttprequest_create(unit) {
    if (typeof globalThis.XMLHttpRequest !== "undefined")
      try { return new (globalThis.XMLHttpRequest)() } catch (e) { }
    if (typeof globalThis.activeXObject !== "undefined") {
      try { return new (globalThis.activeXObject)("Msxml2.XMLHTTP") }
      catch (e) { }
      try { return new (globalThis.activeXObject)("Msxml3.XMLHTTP") }
      catch (e) { }
      try { return new (globalThis.activeXObject)("Microsoft.XMLHTTP") }
      catch (e) { }
    }
    caml_failwith("Cannot create a XMLHttpRequest")
  }
  function caml_trampoline_return(f, args) { return { joo_tramp: f, joo_args: args } }
  function caml_ml_is_buffered(chanid) { return caml_ml_channels[chanid].buffered ? 1 : 0 }
  function caml_array_append(a1, a2) {
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for (; i < l1; i++)a[i] = a1[i];
    for (; i < l; i++, j++)a[i] = a2[j];
    return a
  }
  function caml_unix_gettimeofday() { return new Date().getTime() / 1000 }
  function caml_unix_time() { return Math.floor(caml_unix_gettimeofday()) }
  function caml_ml_set_channel_refill(chanid, f) { caml_ml_channels[chanid].refill = f; return 0 }
  function caml_fill_bytes(s, i, l, c) {
    if (l > 0)
      if (i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if (c == 0) { s.c = ""; s.t = 2 }
        else { s.c = caml_str_repeat(l, String.fromCharCode(c)); s.t = l == s.l ? 0 : 2 }
      else {
        if (s.t != 4) caml_convert_bytes_to_array(s);
        for (l += i; i < l; i++)s.c[i] = c
      }
    return 0
  }
  function caml_js_expr(s) {
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s))
  }
  function caml_ml_runtime_warnings_enabled(_unit) { return caml_runtime_warnings }
  function caml_output_value_to_bytes(v, flags) { return caml_bytes_of_array(caml_output_val(v, flags)) }
  function caml_eventlog_resume(unit) { return 0 }
  function caml_md5_string(s, ofs, len) { return caml_md5_bytes(caml_bytes_of_string(s), ofs, len) }
  function caml_string_equal(s1, s2) { return caml_bytes_equal(s1, s2) }
  function caml_array_of_string(x) { return caml_uint8_array_of_string(x) }
  function caml_jsoo_flags_use_js_string(unit) { return 0 }
  function caml_output_value_to_buffer(s, ofs, len, v, flags) {
    var t = caml_output_val(v, flags);
    if (t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0
  }
  function re_replacement_text(repl, groups, orig) {
    var
    repl = caml_jsbytes_of_string(repl),
    len = repl.length,
    orig = caml_jsbytes_of_string(orig),
    res = "",
    n = 0,
    cur,
    start,
    end,
    c;
    while (n < len) {
      cur = repl.charAt(n++);
      if (cur != "\\")
        res += cur;
      else {
        if (n == len)
          caml_failwith("Str.replace: illegal backslash sequence");
        cur = repl.charAt(n++);
        switch (cur) {
          case "\\": res += cur; break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            c = + cur;
            if (c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
            start = caml_array_get(groups, c * 2);
            end = caml_array_get(groups, c * 2 + 1);
            if (start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
            res += orig.slice(start, end);
            break;
          default: res += "\\" + cur
        }
      }
    }
    return caml_string_of_jsbytes(res)
  }
  function caml_pure_js_expr(s) {
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s))
  }
  function caml_blit_string(a, b, c, d, e) { caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e); return 0 }
  function blit_nat(nat1, ofs1, nat2, ofs2, len) {
    for (var i = 0; i < len; i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0
  }
  function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len) {
    if (12 != ba1.kind)
      caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
    if (len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if (ofs1 + len > ba1.data.length) caml_array_bound_error();
    if (pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0
  }
  function caml_unix_stat(name) {
    var root = resolve_fs_device(name);
    if (!root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true)
  }
  function caml_register_named_value(nm, v) { caml_named_values[caml_jsbytes_of_string(nm)] = v; return 0 }
  function jsoo_create_file_extern(name, content) {
    if (globalThis.jsoo_create_file)
      globalThis.jsoo_create_file(name, content);
    else {
      if (!globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
      globalThis.caml_fs_tmp.push({ name: name, content: content })
    }
    return 0
  }
  function caml_unix_stat_64(name) { var r = caml_unix_stat(name); r[9] = caml_int64_of_int32(r[9]) }
  function caml_to_js_string(s) { return caml_jsstring_of_string(s) }
  function caml_ml_mutex_lock(t) {
    if (t.locked)
      caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
      t.locked = true;
    return 0
  }
  function re_search_forward(re, s, pos) {
    if (pos < 0 || pos > caml_ml_string_length(s))
      caml_invalid_argument("Str.search_forward");
    while (pos <= caml_ml_string_length(s)) { var res = re_match(re, s, pos, 0); if (res) return res; pos++ }
    return [0]
  }
  var caml_blit_string_to_bigstring = caml_bigstring_blit_string_to_ba;
  function caml_make_vect(len, init) {
    if (len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for (var i = 1; i < len; i++)b[i] = init;
    return b
  }
  function caml_ml_seek_in(chanid, pos) { return caml_seek_in(chanid, pos) }
  function caml_sys_read_directory(name) {
    var
    root = resolve_fs_device(name),
    a = root.device.readdir(root.rest),
    l = new Array(a.length + 1);
    l[0] = 0;
    for (var i = 0; i < a.length; i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l
  }
  function caml_ml_output_char(chanid, c) {
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0
  }
  function caml_sys_const_ostype_win32() { return os_type == "Win32" ? 1 : 0 }
  function caml_obj_is_block(x) { return + (x instanceof Array) }
  function caml_obj_set_raw_field(o, i, v) { return o[i + 1] = v }
  function caml_js_var(x) {
    var x = caml_jsstring_of_string(x);
    if (!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
      console.error
        ('caml_js_var: "'
          +
          x
          +
          '" is not a valid JavaScript variable. continuing ..');
    return eval(x)
  }
  function caml_trunc_float(x) { return Math.trunc(x) }
  function caml_ephe_unset_data(x) {
    if (globalThis.FinalizationRegistry && globalThis.WeakRef)
      if (x[1] instanceof globalThis.FinalizationRegistry)
        for (var j = caml_ephe_key_offset; j < x.length; j++) {
          var key = x[j];
          if (key instanceof globalThis.WeakRef) { key = key.deref(); if (key) x[1].unregister(key) }
        }
    x[caml_ephe_data_offset] = undefined;
    return 0
  }
  function caml_ephe_set_data(x, data) {
    if (globalThis.FinalizationRegistry && globalThis.WeakRef)
      if (!(x[1] instanceof globalThis.FinalizationRegistry)) {
        x[1]
        =
        new
          (globalThis.FinalizationRegistry)
          (function () { caml_ephe_unset_data(x) });
        for (var j = caml_ephe_key_offset; j < x.length; j++) {
          var key = x[j];
          if (key instanceof globalThis.WeakRef) { key = key.deref(); if (key) x[1].register(key, undefined, key) }
        }
      }
    x[caml_ephe_data_offset] = data;
    return 0
  }
  function caml_ephe_blit_data(src, dst) {
    var n = src[caml_ephe_data_offset];
    if (n === undefined)
      caml_ephe_unset_data(dst);
    else
      caml_ephe_set_data(dst, n);
    return 0
  }
  function caml_is_printable(c) { return + (c > 31 && c < 127) }
  function caml_array_of_bytes(x) { return caml_uint8_array_of_bytes(x) }
  function caml_equal(x, y) { return + (caml_compare_val(x, y, false) == 0) }
  function re_partial_match(re, s, pos) {
    if (pos < 0 || pos > caml_ml_string_length(s))
      caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0]
  }
  function caml_sys_random_seed() {
    if (globalThis.crypto)
      if (typeof globalThis.crypto.getRandomValues === "function") {
        var a = new Uint32Array(1);
        globalThis.crypto.getRandomValues(a);
        return [0, a[0]]
      }
      else
        if (globalThis.crypto.randomBytes === "function") {
          var buff = globalThis.crypto.randomBytes(4), a = new Uint32Array(buff);
          return [0, a[0]]
        }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x]
  }
  var all_finalizers = new (globalThis.Set)();
  function caml_final_register_called_without_value(cb, a) {
    if (globalThis.FinalizationRegistry && a instanceof Object) {
      var
      x =
        new
          (globalThis.FinalizationRegistry)
          (function (x) { all_finalizers.delete(x); cb(0); return });
      x.register(a, x);
      all_finalizers.add(x)
    }
    return 0
  }
  function caml_ba_get_2(ba, i0, i1) { return ba.get(ba.offset([i0, i1])) }
  function caml_ba_uint8_set16(ba, i0, v) {
    var ofs = ba.offset(i0);
    if (ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0
  }
  function caml_lazy_reset_to_lazy(o) { caml_obj_update_tag(o, 244, 246); return 0 }
  function caml_js_delete(o, f) { delete o[f]; return 0 }
  function caml_int_of_string(s) {
    var
    r = caml_parse_sign_and_base(s),
    i = r[0],
    sign = r[1],
    base = r[2],
    len = caml_ml_string_length(s),
    threshold = - 1 >>> 0,
    c = i < len ? caml_string_unsafe_get(s, i) : 0,
    d = caml_parse_digit(c);
    if (d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for (i++; i < len; i++) {
      c = caml_string_unsafe_get(s, i);
      if (c == 95) continue;
      d = caml_parse_digit(c);
      if (d < 0 || d >= base) break;
      res = base * res + d;
      if (res > threshold) caml_failwith("int_of_string")
    }
    if (i != len) caml_failwith("int_of_string");
    res = sign * res;
    if (base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0
  }
  function caml_list_mount_point() {
    var prev = 0;
    for (var i = 0; i < jsoo_mount_point.length; i++) {
      var old = prev;
      prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old]
    }
    return prev
  }
  var
    caml_marshal_constants =
    {
      PREFIX_SMALL_BLOCK: 0x80,
      PREFIX_SMALL_INT: 0x40,
      PREFIX_SMALL_STRING: 0x20,
      CODE_INT8: 0x00,
      CODE_INT16: 0x01,
      CODE_INT32: 0x02,
      CODE_INT64: 0x03,
      CODE_SHARED8: 0x04,
      CODE_SHARED16: 0x05,
      CODE_SHARED32: 0x06,
      CODE_BLOCK32: 0x08,
      CODE_BLOCK64: 0x13,
      CODE_STRING8: 0x09,
      CODE_STRING32: 0x0A,
      CODE_DOUBLE_BIG: 0x0B,
      CODE_DOUBLE_LITTLE: 0x0C,
      CODE_DOUBLE_ARRAY8_BIG: 0x0D,
      CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
      CODE_DOUBLE_ARRAY32_BIG: 0x0F,
      CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
      CODE_CODEPOINTER: 0x10,
      CODE_INFIXPOINTER: 0x11,
      CODE_CUSTOM: 0x12,
      CODE_CUSTOM_LEN: 0x18,
      CODE_CUSTOM_FIXED: 0x19
    };
  function caml_obj_raw_field(o, i) { return o[i + 1] }
  function caml_js_equals(x, y) { return + (x == y) }
  function caml_obj_compare_and_swap(x, i, old, n) { if (x[i + 1] == old) { x[i + 1] = n; return 1 } return 0 }
  function bigstring_to_typed_array(bs) { return bs.data }
  function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2) {
    while (a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
      rot = 0,
      xPos,
      yPos,
      xPos_prev,
      yPos_prev,
      space = 2,
      num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
      delta = (a2 - a1) * Math.PI / num,
      i = a1 * Math.PI;
    for (var j = 0; j <= num; j++) {
      xPos
      =
      cx
      -
      rx
      *
      Math.sin(i)
      *
      Math.sin(rot * Math.PI)
      +
      ry
      *
      Math.cos(i)
      *
      Math.cos(rot * Math.PI);
      xPos = xPos.toFixed(2);
      yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
      yPos = yPos.toFixed(2);
      if (j == 0)
        ctx.moveTo(xPos, yPos);
      else
        if (xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
      xPos_prev = xPos;
      yPos_prev = yPos;
      i -= delta
    }
    return 0
  }
  function caml_gr_fill_arc(x, y, rx, ry, a1, a2) {
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0
  }
  function caml_ba_slice(ba, vind) {
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if (num_inds > ba.dims.length)
      caml_invalid_argument("Bigarray.slice: too many indices");
    if (ba.layout == 0) {
      for (var i = 0; i < num_inds; i++)index[i] = vind[i];
      for (; i < ba.dims.length; i++)index[i] = 0;
      sub_dims = ba.dims.slice(num_inds)
    }
    else {
      for (var i = 0; i < num_inds; i++)
        index[ba.dims.length - num_inds + i] = vind[i];
      for (var i = 0; i < ba.dims.length - num_inds; i++)index[i] = 1;
      sub_dims = ba.dims.slice(0, ba.dims.length - num_inds)
    }
    ofs = ba.offset(index);
    var
      size = caml_ba_get_size(sub_dims),
      size_per_element = caml_ba_get_size_per_element(ba.kind),
      new_data =
        ba.data.subarray
          (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data)
  }
  function caml_js_wrap_callback_unsafe(f) {
    return function () {
      var len = caml_js_function_arity(f), args = new Array(len);
      for (var i = 0; i < len; i++)args[i] = arguments[i];
      return caml_callback(f, args)
    }
  }
  function caml_ba_kind(ba) { return ba.kind }
  function caml_js_fun_call(f, a) {
    switch (a.length) {
      case 1: return f();
      case 2: return f(a[1]);
      case 3: return f(a[1], a[2]);
      case 4: return f(a[1], a[2], a[3]);
      case 5: return f(a[1], a[2], a[3], a[4]);
      case 6: return f(a[1], a[2], a[3], a[4], a[5]);
      case 7: return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8: return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7])
    }
    return f.apply(null, caml_js_from_array(a))
  }
  function caml_gc_major_slice(work) { return 0 }
  function caml_js_pure_expr(f) { return caml_callback(f, [0]) }
  function compare_digits_nat(nat1, ofs1, nat2, ofs2) {
    if (nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if (nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0
  }
  function caml_ml_input(chanid, b, i, l) {
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l)
  }
  function caml_gr_wait_event(_evl) {
    caml_failwith
      ("caml_gr_wait_event not Implemented: use Graphics_js instead")
  }
  function caml_gr_sigio_handler() { return 0 }
  function caml_hash_mix_bigstring(h, bs) { return caml_hash_mix_bytes_arr(h, bs.data) }
  function caml_record_backtrace() { return 0 }
  function caml_unix_cleanup() { }
  function caml_sys_const_backend_type() { return [0, caml_string_of_jsbytes("js_of_ocaml")] }
  function caml_sys_get_config() { return [0, caml_string_of_jsbytes(os_type), 32, 0] }
  function caml_obj_is_shared(x) { return 1 }
  function caml_ml_out_channels_list() {
    var l = 0;
    for (var c = 0; c < caml_ml_channels.length; c++)
      if
        (caml_ml_channels[c]
        &&
        caml_ml_channels[c].opened
        &&
        caml_ml_channels[c].out)
        l = [0, caml_ml_channels[c].fd, l];
    return l
  }
  function caml_asinh_float(x) { return Math.asinh(x) }
  function caml_pos_out(chanid) { var chan = caml_ml_channels[chanid]; return chan.offset + chan.buffer_curr }
  function bigstring_of_array_buffer(ab) {
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta)
  }
  function caml_mod(x, y) { if (y == 0) caml_raise_zero_divide(); return x % y }
  function caml_ba_init() { return 0 }
  function caml_unix_filedescr_of_fd(x) { return x }
  function re_string_match(re, s, pos) {
    if (pos < 0 || pos > caml_ml_string_length(s))
      caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0]
  }
  function BigStringReader(bs, i) { this.s = bs; this.i = i }
  BigStringReader.prototype
    =
  {
    read8u: function () { return caml_ba_get_1(this.s, this.i++) },
    read8s: function () { return caml_ba_get_1(this.s, this.i++) << 24 >> 24 },
    read16u:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 2;
        return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1)
      },
    read16s:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 2;
        return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1)
      },
    read32u:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 4;
        return (caml_ba_get_1(s, i)
          <<
          24
          |
          caml_ba_get_1(s, i + 1)
          <<
          16
          |
          caml_ba_get_1(s, i + 2)
          <<
          8
          |
          caml_ba_get_1(s, i + 3))
          >>>
          0
      },
    read32s:
      function () {
        var s = this.s, i = this.i;
        this.i = i + 4;
        return caml_ba_get_1(s, i)
          <<
          24
          |
          caml_ba_get_1(s, i + 1)
          <<
          16
          |
          caml_ba_get_1(s, i + 2)
          <<
          8
          |
          caml_ba_get_1(s, i + 3)
      },
    readstr:
      function (len) {
        var i = this.i, arr = new Array(len);
        for (var j = 0; j < len; j++)arr[j] = caml_ba_get_1(this.s, i + j);
        this.i = i + len;
        return caml_string_of_array(arr)
      }
  };
  function caml_gr_dump_image(im) {
    var data = [0];
    for (var i = 0; i < im.height; i++) {
      data[i + 1] = [0];
      for (var j = 0; j < im.width; j++) {
        var
        o = i * (im.width * 4) + j * 4,
        r = im.data[o + 0],
        g = im.data[o + 1],
        b = im.data[o + 2];
        data[i + 1][j + 1] = (r << 16) + (g << 8) + b
      }
    }
    return data
  }
  function caml_ba_get_generic(ba, i) { var ofs = ba.offset(caml_js_from_array(i)); return ba.get(ofs) }
  function caml_unix_startup() { }
  function caml_get_exception_backtrace() { return 0 }
  function caml_format_float(fmt, x) {
    function toFixed(x, dp) {
      if (Math.abs(x) < 1.0)
        return x.toFixed(dp);
      else {
        var e = parseInt(x.toString().split("+")[1]);
        if (e > 20) {
          e -= 20;
          x /= Math.pow(10, e);
          x += new Array(e + 1).join("0");
          if (dp > 0) x = x + "." + new Array(dp + 1).join("0");
          return x
        }
        else
          return x.toFixed(dp)
      }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if (x < 0 || x == 0 && 1 / x == - Infinity) { f.sign = - 1; x = - x }
    if (isNaN(x)) { s = "nan"; f.filler = " " }
    else
      if (!isFinite(x)) { s = "inf"; f.filler = " " }
      else
        switch (f.conv) {
          case "e":
            var s = x.toExponential(prec), i = s.length;
            if (s.charAt(i - 3) == "e")
              s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
            break;
          case "f": s = toFixed(x, prec); break;
          case "g":
            prec = prec ? prec : 1;
            s = x.toExponential(prec - 1);
            var j = s.indexOf("e"), exp = + s.slice(j + 1);
            if (exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec) {
              var i = j - 1;
              while (s.charAt(i) == "0") i--;
              if (s.charAt(i) == ".") i--;
              s = s.slice(0, i + 1) + s.slice(j);
              i = s.length;
              if (s.charAt(i - 3) == "e")
                s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
              break
            }
            else {
              var p = prec;
              if (exp < 0) { p -= exp + 1; s = x.toFixed(p) }
              else
                while (s = x.toFixed(p), s.length > prec + 1) p--;
              if (p) {
                var i = s.length - 1;
                while (s.charAt(i) == "0") i--;
                if (s.charAt(i) == ".") i--;
                s = s.slice(0, i + 1)
              }
            }
            break
        }
    return caml_finish_formatting(f, s)
  }
  function caml_mount_autoload(name, f) {
    var path = caml_make_path(name), name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({ path: name, device: new MlFakeDevice(name, f) });
    return 0
  }
  function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len) {
    if (12 != ba1.kind)
      caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if (12 != ba2.kind)
      caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if (len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if (ofs1 + len > ba1.data.length) caml_array_bound_error();
    if (ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0
  }
  var caml_blit_bigstring_to_bigstring = caml_bigstring_blit_ba_to_ba;
  function caml_string_lessthan(s1, s2) { return caml_bytes_lessthan(s1, s2) }
  function caml_string_greaterthan(s1, s2) { return caml_string_lessthan(s2, s1) }
  function caml_div(x, y) { if (y == 0) caml_raise_zero_divide(); return x / y | 0 }
  function caml_obj_dup(x) {
    var l = x.length, a = new Array(l);
    for (var i = 0; i < l; i++)a[i] = x[i];
    return a
  }
  function caml_ephe_get_data_copy(x) {
    return x[caml_ephe_data_offset] === undefined
      ? 0
      : [0, caml_obj_dup(x[caml_ephe_data_offset])]
  }
  function caml_memprof_start(rate, stack_size, tracker) { return 0 }
  function caml_sys_get_argv(a) { return [0, caml_argv[1], caml_argv] }
  function caml_ml_domain_set_name(_name) { return 0 }
  function caml_js_to_bool(x) { return + x }
  function caml_gr_create_image(x, y) { var s = caml_gr_state_get(); return s.context.createImageData(x, y) }
  function caml_ephe_get_key_copy(x, i) {
    if (i < 0 || caml_ephe_key_offset + i >= x.length)
      caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if (y === 0) return y;
    var z = y[1];
    if (z instanceof Array) return [0, caml_obj_dup(z)];
    return y
  }
  function caml_lessthan(x, y) { return + (caml_compare_val(x, y, false) < 0) }
  function caml_raw_backtrace_next_slot() { return 0 }
  function caml_register_global(n, v, name_opt) {
    if (name_opt && globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name_opt]);
    caml_global_data[n + 1] = v;
    if (name_opt) caml_global_data[name_opt] = v
  }
  function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3) {
    var carry = 0;
    for (var i = 0; i < len3; i++)
      carry
        +=
        mult_digit_nat(nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry
  }
  function square_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry
  }
  function caml_js_from_float(x) { return x }
  function caml_floatarray_create(len) {
    if (len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for (var i = 1; i < len; i++)b[i] = 0;
    return b
  }
  function caml_gc_stat() { return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
  function caml_get_major_credit(n) { return 0 }
  function caml_sys_modify_argv(arg) { caml_argv = arg; return 0 }
  var caml_method_cache = [];
  function caml_get_public_method(obj, tag, cacheid) {
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if (ofs === undefined)
      for (var i = caml_method_cache.length; i < cacheid; i++)
        caml_method_cache[i] = 0;
    else
      if (meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while (li < hi) { mi = li + hi >> 1 | 1; if (tag < meths[mi + 1]) hi = mi - 2; else li = mi }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0
  }
  function caml_js_get_console() {
    var
    c = console,
    m =
      ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f() { }
    for (var i = 0; i < m.length; i++)if (!c[m[i]]) c[m[i]] = f;
    return c
  }
  function caml_sys_unsafe_getenv(name) { return caml_sys_getenv(name) }
  function caml_ml_open_descriptor_in(fd) {
    var file = caml_sys_fds[fd];
    if (file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
      refill = null,
      channel =
      {
        file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill
      };
    caml_ml_channels[channel.fd] = channel;
    return channel.fd
  }
  function bigstring_of_typed_array(ba) {
    var
    ta =
      new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta)
  }
  function caml_round_float(x) { return Math.round(x) }
  function caml_ojs_new_arr(c, a) {
    switch (a.length) {
      case 0: return new c();
      case 1: return new c(a[0]);
      case 2: return new c(a[0], a[1]);
      case 3: return new c(a[0], a[1], a[2]);
      case 4: return new c(a[0], a[1], a[2], a[3]);
      case 5: return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6: return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7: return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6])
    }
    function F() { return c.apply(this, a) }
    F.prototype = c.prototype;
    return new F()
  }
  function complement_nat(nat, ofs, len) {
    for (var i = 0; i < len; i++)
      nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)
  }
  var caml_domain_dls = [0];
  function caml_domain_dls_set(a) { caml_domain_dls = a }
  function caml_lazy_read_result(o) { return caml_obj_tag(o) == 250 ? o[1] : o }
  var caml_js_regexps = { amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/ };
  function caml_js_html_escape(s) {
    if (!caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
      (caml_js_regexps.lt, "&lt;").replace
      (caml_js_regexps.quot, "&quot;")
  }
  function caml_ba_dim_2(ba) { return caml_ba_dim(ba, 1) }
  function caml_js_wrap_meth_callback_arguments(f) {
    return function () {
      var len = arguments.length, args = new Array(len);
      for (var i = 0; i < len; i++)args[i] = arguments[i];
      return caml_callback(f, [this, args])
    }
  }
  function caml_sinh_float(x) { return Math.sinh(x) }
  function caml_ldexp_float(x, exp) {
    exp |= 0;
    if (exp > 1023) {
      exp -= 1023;
      x *= Math.pow(2, 1023);
      if (exp > 1023) { exp -= 1023; x *= Math.pow(2, 1023) }
    }
    if (exp < - 1023) { exp += 1023; x *= Math.pow(2, - 1023) }
    x *= Math.pow(2, exp);
    return x
  }
  function caml_gr_state_set(ctx) { caml_gr_state = ctx; caml_gr_state_init(); return 0 }
  function caml_js_wrap_callback_strict(arity, f) {
    return function () {
      var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
      for (var i = 0; i < len; i++)args[i] = arguments[i];
      return caml_callback(f, args)
    }
  }
  function caml_gc_minor_words(unit) { return 0 }
  function caml_get_current_callstack() { return [0] }
  function land_digit_nat(nat1, ofs1, nat2, ofs2) { nat1.data[ofs1] &= nat2.data[ofs2]; return 0 }
  function caml_int64_mod(x, y) { return x.mod(y) }
  function caml_obj_set_tag(x, tag) { x[0] = tag; return 0 }
  function caml_int32_bswap(x) {
    return (x & 0x000000FF)
      <<
      24
      |
      (x & 0x0000FF00)
      <<
      8
      |
      (x & 0x00FF0000)
      >>>
      8
      |
      (x & 0xFF000000)
      >>>
      24
  }
  function caml_ba_set_3(ba, i0, i1, i2, v) { ba.set(ba.offset([i0, i1, i2]), v); return 0 }
  function caml_js_instanceof(o, c) { return o instanceof c ? 1 : 0 }
  function caml_get_major_bucket(n) { return 0 }
  var caml_blit_bigstring_to_string = caml_bigstring_blit_ba_to_bytes;
  function set_digit_nat_native(nat, ofs, digit) { nat.data[ofs] = digit; return 0 }
  function nth_digit_nat_native(nat, ofs) { return nat.data[ofs] }
  function caml_string_set64(s, i, i64) { return caml_bytes_set64(s, i, i64) }
  function caml_gr_state_create(canvas, w, h) {
    var context = canvas.getContext("2d");
    return {
      context: context,
      canvas: canvas,
      x: 0,
      y: 0,
      width: w,
      height: h,
      line_width: 1,
      font: caml_string_of_jsbytes("fixed"),
      text_size: 26,
      color: 0x000000,
      title: caml_string_of_jsbytes("")
    }
  }
  function caml_gr_draw_arc(x, y, rx, ry, a1, a2) {
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0
  }
  function caml_ba_map_file(vfd, kind, layout, shared, dims, pos) { caml_failwith("caml_ba_map_file not implemented") }
  function caml_ba_map_file_bytecode(argv, argn) { return caml_ba_map_file(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]) }
  function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims) {
    if (data2 || caml_ba_get_size_per_element(kind) == 2)
      caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1)
  }
  function caml_tanh_float(x) { return Math.tanh(x) }
  function caml_gr_draw_str(str) {
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0
  }
  function caml_gr_draw_string(str) { caml_gr_draw_str(caml_jsstring_of_string(str)); return 0 }
  function caml_gr_draw_char(c) { caml_gr_draw_str(String.fromCharCode(c)); return 0 }
  function caml_unmount(name) {
    var
    path = caml_make_path(name),
    name = caml_trailing_slash(path.join("/")),
    idx = - 1;
    for (var i = 0; i < jsoo_mount_point.length; i++)
      if (jsoo_mount_point[i].path == name) idx = i;
    if (idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0
  }
  function caml_input_value_from_string(s, ofs) {
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs)
  }
  function caml_ml_pos_in_64(chanid) { return caml_int64_of_float(caml_pos_in(chanid)) }
  function caml_gr_draw_image(im, x, y) {
    var s = caml_gr_state_get();
    if (!im.image) {
      var canvas = document.createElement("canvas");
      canvas.width = s.width;
      canvas.height = s.height;
      canvas.getContext("2d").putImageData(im, 0, 0);
      var image = new (globalThis.Image)();
      image.onload
        =
        function () {
          s.context.drawImage(image, x, s.height - im.height - y);
          im.image = image
        };
      image.src = canvas.toDataURL("image/png")
    }
    else
      s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0
  }
  function caml_register_channel_for_spacetime(_channel) { return 0 }
  function caml_string_set(s, i, c) {
    if (i >>> 0 >= s.l) caml_string_bound_error();
    return caml_string_unsafe_set(s, i, c)
  }
  function caml_sys_rmdir(name) { var root = resolve_fs_device(name); root.device.rmdir(root.rest); return 0 }
  function caml_unix_symlink(to_dir, src, dst) {
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if (src_root.device != dst_root.device)
      caml_failwith
        ("caml_unix_symlink: cannot symlink between two filesystems");
    if (!src_root.device.symlink)
      caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true)
  }
  function caml_ml_pos_out(chanid) { return caml_pos_out(chanid) }
  function caml_spacetime_enabled(_unit) { return 0 }
  function caml_bytes_notequal(s1, s2) { return 1 - caml_bytes_equal(s1, s2) }
  function caml_runtime_parameters(_unit) { return caml_string_of_jsbytes("") }
  function caml_js_object(a) {
    var o = {};
    for (var i = 1; i < a.length; i++) { var p = a[i]; o[caml_jsstring_of_string(p[1])] = p[2] }
    return o
  }
  function caml_ba_create(kind, layout, dims_ml) {
    var
    dims = caml_js_from_array(dims_ml),
    data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data)
  }
  function caml_gr_remember_mode() { caml_failwith("caml_gr_remember_mode not Implemented") }
  function caml_fma_float(x, y, z) {
    var
    SPLIT = Math.pow(2, 27) + 1,
    MIN_VALUE = Math.pow(2, - 1022),
    EPSILON = Math.pow(2, - 52),
    C = 416,
    A = Math.pow(2, + C),
    B = Math.pow(2, - C);
    function multiply(a, b) {
      var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
      return { p: p, e: e }
    }
    function add(a, b) { var s = a + b, v = s - a, e = a - (s - v) + (b - v); return { s: s, e: e } }
    function adjust(x, y) {
      return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
        ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
        : x
    }
    if
      (x
      ===
      0
      ||
      x
      !==
      x
      ||
      x
      ===
      +
      (1 / 0)
      ||
      x
      ===
      -
      (1 / 0)
      ||
      y
      ===
      0
      ||
      y
      !==
      y
      ||
      y
      ===
      +
      (1 / 0)
      ||
      y
      ===
      -
      (1 / 0))
      return x * y + z;
    if (z === 0) return x * y;
    if (z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while (Math.abs(x) > A) { scale *= A; x *= B }
    while (Math.abs(y) > A) { scale *= A; y *= B }
    if (scale === 1 / 0) return x * y * scale;
    while (Math.abs(x) < B) { scale *= B; x *= A }
    while (Math.abs(y) < B) { scale *= B; y *= A }
    if (scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if (Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if (Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
      zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
      xy = multiply(xs, ys),
      s = add(xy.p, zs),
      u = add(xy.e, s.e),
      i = add(s.s, u.s),
      f = i.s + adjust(i.e, u.e);
    if (f === 0) return f;
    var fs = f * scale;
    if (Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale
  }
  function caml_recommended_domain_count(unit) { return 1 }
  function caml_bswap16(x) { return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8 }
  function caml_ml_set_binary_mode(chanid, mode) {
    var chan = caml_ml_channels[chanid];
    chan.file.flags.text = !mode;
    chan.file.flags.binary = mode;
    return 0
  }
  function caml_final_register() { return 0 }
  function caml_gr_draw_rect(x, y, w, h) {
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0
  }
  function caml_string_get16(s, i) {
    if (i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var b1 = caml_string_unsafe_get(s, i), b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1
  }
  function caml_output_value(chanid, v, flags) {
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0
  }
  function caml_ba_get_3(ba, i0, i1, i2) { return ba.get(ba.offset([i0, i1, i2])) }
  function caml_ephe_blit_key(a1, i1, a2, i2, len) {
    caml_array_blit
      (a1, caml_ephe_key_offset + i1 - 1, a2, caml_ephe_key_offset + i2 - 1, len);
    return 0
  }
  var caml_initial_time = new Date().getTime() * 0.001;
  function caml_sys_time() { var now = new Date().getTime(); return now * 0.001 - caml_initial_time }
  function caml_sys_time_include_children(b) { return caml_sys_time() }
  function caml_check_bound(array, index) {
    if (index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array
  }
  function caml_unix_getpwuid(unit) { caml_raise_not_found() }
  function caml_hash(count, limit, seed, obj) {
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if (sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while (rd < wr && num > 0) {
      v = queue[rd++];
      if (v && v.caml_custom) {
        if
          (caml_custom_ops[v.caml_custom]
          &&
          caml_custom_ops[v.caml_custom].hash) {
          var hh = caml_custom_ops[v.caml_custom].hash(v);
          h = caml_hash_mix_int(h, hh);
          num--
        }
      }
      else
        if (v instanceof Array && v[0] === (v[0] | 0))
          switch (v[0]) {
            case 248: h = caml_hash_mix_int(h, v[2]); num--; break;
            case 250: queue[--rd] = v[1]; break;
            default:
              if (caml_is_continuation_tag(v[0])) break;
              var tag = v.length - 1 << 10 | v[0];
              h = caml_hash_mix_int(h, tag);
              for (i = 1, len = v.length; i < len; i++) { if (wr >= sz) break; queue[wr++] = v[i] }
              break
          }
        else
          if (caml_is_ml_bytes(v)) { h = caml_hash_mix_bytes(h, v); num-- }
          else
            if (caml_is_ml_string(v)) { h = caml_hash_mix_string(h, v); num-- }
            else
              if (typeof v === "string") { h = caml_hash_mix_jsbytes(h, v); num-- }
              else
                if (v === (v | 0)) { h = caml_hash_mix_int(h, v + v + 1); num-- }
                else
                  if (v === + v) { h = caml_hash_mix_float(h, v); num-- }
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF
  }
  function caml_ba_to_typed_array(ba) { return ba.data }
  function caml_domain_dls_get(unit) { return caml_domain_dls }
  function caml_bytes_get32(s, i) {
    if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
      b1 = caml_bytes_unsafe_get(s, i),
      b2 = caml_bytes_unsafe_get(s, i + 1),
      b3 = caml_bytes_unsafe_get(s, i + 2),
      b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1
  }
  function caml_frexp_float(x) {
    if (x == 0 || !isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if (neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while (x < 0.5) { x *= 2; exp-- }
    while (x >= 1) { x *= 0.5; exp++ }
    if (neg) x = - x;
    return [0, x, exp]
  }
  function caml_string_get64(s, i) {
    if (i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for (var j = 0; j < 8; j++)a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a)
  }
  function caml_js_error_option_of_exception(exn) { if (exn.js_error) return [0, exn.js_error]; return 0 }
  function caml_ml_pos_out_64(chanid) { return caml_int64_of_float(caml_pos_out(chanid)) }
  function caml_unix_findclose(dir_handle) { return caml_unix_closedir(dir_handle) }
  function caml_gr_close_subwindow(a) { caml_failwith("caml_gr_close_subwindow not Implemented") }
  function caml_floatarray_blit(a1, i1, a2, i2, len) {
    if (i2 <= i1)
      for (var j = 1; j <= len; j++)a2[i2 + j] = a1[i1 + j];
    else
      for (var j = len; j >= 1; j--)a2[i2 + j] = a1[i1 + j];
    return 0
  }
  function caml_get_minor_free(unit) { return 0 }
  function caml_set_static_env(k, v) {
    if (!globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0
  }
  function caml_ba_change_layout(ba, layout) {
    if (ba.layout == layout) return ba;
    var new_dims = [];
    for (var i = 0; i < ba.dims.length; i++)
      new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data)
  }
  function caml_js_new(c, a) {
    switch (a.length) {
      case 1: return new c();
      case 2: return new c(a[1]);
      case 3: return new c(a[1], a[2]);
      case 4: return new c(a[1], a[2], a[3]);
      case 5: return new c(a[1], a[2], a[3], a[4]);
      case 6: return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7: return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8: return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7])
    }
    function F() { return c.apply(this, caml_js_from_array(a)) }
    F.prototype = c.prototype;
    return new F()
  }
  function caml_gr_current_y() { var s = caml_gr_state_get(); return s.y }
  function caml_format_int(fmt, i) {
    if (caml_jsbytes_of_string(fmt) == "%d")
      return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if (i < 0) if (f.signedconv) { f.sign = - 1; i = - i } else i >>>= 0;
    var s = i.toString(f.base);
    if (f.prec >= 0) {
      f.filler = " ";
      var n = f.prec - s.length;
      if (n > 0) s = caml_str_repeat(n, "0") + s
    }
    return caml_finish_formatting(f, s)
  }
  function jsoo_effect_not_supported() { caml_failwith("Effect handlers are not supported") }
  function caml_continuation_use_and_update_handler_noexc
    (cont, hval, hexn, heff) {
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack
  }
  function caml_obj_truncate(x, s) {
    if (s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if (x.length != s + 1) x.length = s + 1;
    return 0
  }
  function caml_js_to_string(s) { return caml_string_of_jsstring(s) }
  function is_digit_odd(nat, ofs) { if (nat.data[ofs] & 1) return 1; return 0 }
  function caml_runtime_variant(_unit) { return caml_string_of_jsbytes("") }
  function caml_ml_open_descriptor_out(fd) {
    var file = caml_sys_fds[fd];
    if (file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
      buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
      channel =
      {
        file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered
      };
    caml_ml_channels[channel.fd] = channel;
    return channel.fd
  }
  function caml_array_concat(l) {
    var a = [0];
    while (l !== 0) { var b = l[1]; for (var i = 1; i < b.length; i++)a.push(b[i]); l = l[2] }
    return a
  }
  function caml_gr_open_graph(info) {
    var info = caml_jsstring_of_string(info);
    function get(name) {
      var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
      if (res) return res[2]
    }
    var specs = [];
    if (!(info == "")) specs.push(info);
    var target = get("target");
    if (!target) target = "";
    var status = get("status");
    if (!status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if (!win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function (title) { doc.title = title };
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0
  }
  function caml_make_float_vect(len) {
    if (len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for (var i = 1; i < len; i++)b[i] = 0;
    return b
  }
  function caml_cbrt_float(x) { return Math.cbrt(x) }
  function caml_memprof_stop(unit) { return 0 }
  function caml_eventlog_pause(unit) { return 0 }
  function caml_greaterequal(x, y) { return + (caml_compare_val(x, y, false) >= 0) }
  function caml_get_exception_raw_backtrace() { return [0] }
  function caml_log1p_float(x) { return Math.log1p(x) }
  function caml_lazy_make_forward(v) { return [250, v] }
  function lor_digit_nat(nat1, ofs1, nat2, ofs2) { nat1.data[ofs1] |= nat2.data[ofs2]; return 0 }
  function caml_gr_blit_image(im, x, y) {
    var
    s = caml_gr_state_get(),
    im2 =
      s.context.getImageData(x, s.height - im.height - y, im.width, im.height);
    for (var i = 0; i < im2.data.length; i += 4) {
      im.data[i] = im2.data[i];
      im.data[i + 1] = im2.data[i + 1];
      im.data[i + 2] = im2.data[i + 2];
      im.data[i + 3] = im2.data[i + 3]
    }
    return 0
  }
  function caml_gr_window_id(a) { caml_failwith("caml_gr_window_id not Implemented") }
  function caml_js_on_ie() {
    var ua = globalThis.navigator ? globalThis.navigator.userAgent : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0
  }
  function caml_int64_shift_right(x, s) { return x.shift_right(s) }
  function caml_ba_layout(ba) { return ba.layout }
  function caml_convert_raw_backtrace() { return [0] }
  function caml_array_set(array, index, newval) {
    if (index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0
  }
  function caml_alloc_stack(hv, hx, hf) { return 0 }
  function caml_bytes_greaterequal(s1, s2) { return caml_bytes_lessequal(s2, s1) }
  function set_digit_nat(nat, ofs, digit) { nat.data[ofs] = digit; return 0 }
  function caml_gr_doc_of_state(state) { if (state.canvas.ownerDocument) return state.canvas.ownerDocument }
  function caml_ml_output_int(chanid, i) {
    var
    arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
    s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0
  }
  function caml_obj_with_tag(tag, x) {
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for (var i = 1; i < l; i++)a[i] = x[i];
    return a
  }
  function caml_ml_channel_size(chanid) { var chan = caml_ml_channels[chanid]; return chan.file.length() }
  function caml_raw_backtrace_slot() {
    caml_invalid_argument
      ("Printexc.get_raw_backtrace_slot: index out of bounds")
  }
  function caml_hexstring_of_float(x, prec, style) {
    if (!isFinite(x)) {
      if (isNaN(x)) return caml_string_of_jsstring("nan");
      return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity")
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if (sign) x = - x;
    var exp = 0;
    if (x == 0)
      ;
    else
      if (x < 1)
        while (x < 1 && exp > - 1022) { x *= 2; exp-- }
      else
        while (x >= 2) { x /= 2; exp++ }
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if (sign)
      sign_str = "-";
    else
      switch (style) {
        case 43: sign_str = "+"; break;
        case 32: sign_str = " "; break;
        default: break
      }
    if (prec >= 0 && prec < 13) { var cst = Math.pow(2, prec * 4); x = Math.round(x * cst) / cst }
    var x_str = x.toString(16);
    if (prec >= 0) {
      var idx = x_str.indexOf(".");
      if (idx < 0)
        x_str += "." + caml_str_repeat(prec, "0");
      else {
        var size = idx + 1 + prec;
        if (x_str.length < size)
          x_str += caml_str_repeat(size - x_str.length, "0");
        else
          x_str = x_str.substr(0, size)
      }
    }
    return caml_string_of_jsstring
      (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))
  }
  function caml_js_wrap_meth_callback_strict(arity, f) {
    return function () {
      var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
      args[0] = this;
      for (var i = 0; i < len; i++)args[i + 1] = arguments[i];
      return caml_callback(f, args)
    }
  }
  function caml_unix_readlink(name) {
    var root = resolve_fs_device(name);
    if (!root.device.readlink)
      caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true)
  }
  function caml_backtrace_status() { return 0 }
  function caml_sys_argv(a) { return caml_argv }
  function caml_install_signal_handler() { return 0 }
  function caml_ba_fill(ba, v) { ba.fill(v); return 0 }
  function caml_modf_float(x) {
    if (isFinite(x)) {
      var neg = 1 / x < 0;
      x = Math.abs(x);
      var i = Math.floor(x), f = x - i;
      if (neg) { i = - i; f = - f }
      return [0, f, i]
    }
    if (isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x]
  }
  function caml_gc_get() { return [0, 0, 0, 0, 0, 0, 0, 0, 0] }
  function caml_float_compare(x, y) {
    if (x === y) return 0;
    if (x < y) return - 1;
    if (x > y) return 1;
    if (x === x) return 1;
    if (y === y) return - 1;
    return 0
  }
  function caml_string_set32(s, i, i32) { return caml_bytes_set32(s, i, i32) }
  function caml_parse_engine(tables, env, cmd, arg) {
    var
    ERRCODE = 256,
    loop = 6,
    testshift = 7,
    shift = 8,
    shift_recover = 9,
    reduce = 10,
    READ_TOKEN = 0,
    RAISE_PARSE_ERROR = 1,
    GROW_STACKS_1 = 2,
    GROW_STACKS_2 = 3,
    COMPUTE_SEMANTIC_ACTION = 4,
    CALL_ERROR_FUNCTION = 5,
    env_s_stack = 1,
    env_v_stack = 2,
    env_symb_start_stack = 3,
    env_symb_end_stack = 4,
    env_stacksize = 5,
    env_stackbase = 6,
    env_curr_char = 7,
    env_lval = 8,
    env_symb_start = 9,
    env_symb_end = 10,
    env_asp = 11,
    env_rule_len = 12,
    env_rule_number = 13,
    env_sp = 14,
    env_state = 15,
    env_errflag = 16,
    tbl_transl_const = 2,
    tbl_transl_block = 3,
    tbl_lhs = 4,
    tbl_len = 5,
    tbl_defred = 6,
    tbl_dgoto = 7,
    tbl_sindex = 8,
    tbl_rindex = 9,
    tbl_gindex = 10,
    tbl_tablesize = 11,
    tbl_table = 12,
    tbl_check = 13,
    tbl_names_const = 15,
    tbl_names_block = 16;
    function log(x) {
      var s = caml_string_of_jsbytes(x + "\n");
      caml_ml_output(2, s, 0, caml_ml_string_length(s))
    }
    function token_name(names, number) {
      var str = caml_jsstring_of_string(names);
      if (str[0] == "\x00") return "<unknown token>";
      return str.split("\x00")[number]
    }
    function print_token(state, tok) {
      var token, kind;
      if (tok instanceof Array) {
        token = token_name(tables[tbl_names_block], tok[0]);
        if (typeof tok[1] == "number")
          kind = "" + tok[1];
        else
          if (typeof tok[1] == "string")
            kind = tok[1];
          else
            if (tok[1] instanceof MlBytes)
              kind = caml_jsbytes_of_string(tok[1]);
            else
              kind = "_";
        log("State " + state + ": read token " + token + "(" + kind + ")")
      }
      else {
        token = token_name(tables[tbl_names_const], tok);
        log("State " + state + ": read token " + token)
      }
    }
    if (!tables.dgoto) {
      tables.defred = caml_lex_array(tables[tbl_defred]);
      tables.sindex = caml_lex_array(tables[tbl_sindex]);
      tables.check = caml_lex_array(tables[tbl_check]);
      tables.rindex = caml_lex_array(tables[tbl_rindex]);
      tables.table = caml_lex_array(tables[tbl_table]);
      tables.len = caml_lex_array(tables[tbl_len]);
      tables.lhs = caml_lex_array(tables[tbl_lhs]);
      tables.gindex = caml_lex_array(tables[tbl_gindex]);
      tables.dgoto = caml_lex_array(tables[tbl_dgoto])
    }
    var
      res = 0,
      n,
      n1,
      n2,
      state1,
      sp = env[env_sp],
      state = env[env_state],
      errflag = env[env_errflag];
    exit:
    for (; ;)
      next:
      switch (cmd) {
        case 0: state = 0; errflag = 0;
        case 6:
          n = tables.defred[state];
          if (n != 0) { cmd = reduce; break }
          if (env[env_curr_char] >= 0) { cmd = testshift; break }
          res = READ_TOKEN;
          break exit;
        case 1:
          if (arg instanceof Array) {
            env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]
          }
          else {
            env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0
          }
          if (caml_parser_trace) print_token(state, arg);
        case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
            (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char]) { cmd = shift; break }
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
            (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char]) { n = tables.table[n2]; cmd = reduce; break }
          if (errflag <= 0) { res = CALL_ERROR_FUNCTION; break exit }
        case 5:
          if (errflag < 3) {
            errflag = 3;
            for (; ;) {
              state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
                (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE) {
                if (caml_parser_trace) log("Recovering in state " + state1);
                cmd = shift_recover;
                break next
              }
              else {
                if (caml_parser_trace) log("Discarding state " + state1);
                if (sp <= env[env_stackbase]) {
                  if (caml_parser_trace) log("No more states to discard");
                  return RAISE_PARSE_ERROR
                }
                sp--
              }
            }
          }
          else {
            if (env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
            if (caml_parser_trace) log("Discarding last token read");
            env[env_curr_char] = - 1;
            cmd = loop;
            break
          }
        case 8: env[env_curr_char] = - 1; if (errflag > 0) errflag--;
        case 9:
          if (caml_parser_trace)
            log("State " + state + ": shift to state " + tables.table[n2]);
          state = tables.table[n2];
          sp++;
          if (sp >= env[env_stacksize]) { res = GROW_STACKS_1; break exit }
        case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
        case 10:
          if (caml_parser_trace)
            log("State " + state + ": reduce by rule " + n);
          var m = tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
            (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
            state = tables.table[n2];
          else
            state = tables.dgoto[m];
          if (sp >= env[env_stacksize]) { res = GROW_STACKS_2; break exit }
        case 3: res = COMPUTE_SEMANTIC_ACTION; break exit;
        case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp = env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if (sp > asp)
            env[env_symb_start_stack][sp + 1]
              =
              env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
        default: return RAISE_PARSE_ERROR
      }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res
  }
  function caml_jsoo_flags_effects(unit) { return 0 }
  function caml_update_dummy(x, y) {
    if (typeof y === "function") { x.fun = y; return 0 }
    if (y.fun) { x.fun = y.fun; return 0 }
    var i = y.length;
    while (i--) x[i] = y[i];
    return 0
  }
  function caml_array_fill(array, ofs, len, v) { for (var i = 0; i < len; i++)array[ofs + i + 1] = v; return 0 }
  function caml_sys_mkdir(name, perm) {
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0
  }
  function caml_string_notequal(s1, s2) { return 1 - caml_string_equal(s1, s2) }
  function caml_bytes_greaterthan(s1, s2) { return caml_bytes_lessthan(s2, s1) }
  function caml_gr_make_image(arr) {
    var
    s = caml_gr_state_get(),
    h = arr.length - 1,
    w = arr[1].length - 1,
    im = s.context.createImageData(w, h);
    for (var i = 0; i < h; i++)
      for (var j = 0; j < w; j++) {
        var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
        if (c == - 1) {
          im.data[o + 0] = 0;
          im.data[o + 1] = 0;
          im.data[o + 2] = 0;
          im.data[o + 3] = 0
        }
        else {
          im.data[o + 0] = c >> 16 & 0xff;
          im.data[o + 1] = c >> 8 & 0xff;
          im.data[o + 2] = c >> 0 & 0Xff;
          im.data[o + 3] = 0xff
        }
      }
    return im
  }
  function caml_ml_set_channel_output(chanid, f) {
    var chan = caml_ml_channels[chanid];
    chan.output = function (s) { f(s) };
    return 0
  }
  function caml_read_file_content(name) {
    var
    name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
    root = resolve_fs_device(name);
    if (root.device.exists(root.rest)) {
      var
      file = root.device.open(root.rest, { rdonly: 1 }),
      len = file.length(),
      buf = new Uint8Array(len);
      file.read(0, buf, 0, len);
      return caml_string_of_array(buf)
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name))
  }
  function caml_js_to_float(x) { return x }
  function caml_setup_uncaught_exception_handler() {
    var process = globalThis.process;
    if (process && process.on)
      process.on
        ("uncaughtException",
          function (err, origin) { caml_fatal_uncaught_exception(err); process.exit(2) });
    else
      if (globalThis.addEventListener)
        globalThis.addEventListener
          ("error",
            function (event) { if (event.error) caml_fatal_uncaught_exception(event.error) })
  }
  caml_setup_uncaught_exception_handler();
  globalThis.jsoo_runtime
    =
  {
    caml_alloc_stack: caml_alloc_stack,
    caml_continuation_use_noexc: caml_continuation_use_noexc,
    caml_continuation_use_and_update_handler_noexc:
      caml_continuation_use_and_update_handler_noexc,
    caml_get_continuation_callstack: caml_get_continuation_callstack,
    caml_ml_condition_new: caml_ml_condition_new,
    caml_ml_condition_wait: caml_ml_condition_wait,
    caml_ml_condition_broadcast: caml_ml_condition_broadcast,
    caml_ml_condition_signal: caml_ml_condition_signal,
    jsoo_effect_not_supported: jsoo_effect_not_supported,
    MlMutex: MlMutex,
    caml_ml_mutex_new: caml_ml_mutex_new,
    caml_ml_mutex_lock: caml_ml_mutex_lock,
    caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
    caml_ml_mutex_unlock: caml_ml_mutex_unlock,
    caml_lxm_next: caml_lxm_next,
    caml_domain_dls: caml_domain_dls,
    caml_domain_dls_set: caml_domain_dls_set,
    caml_domain_dls_get: caml_domain_dls_get,
    caml_atomic_load: caml_atomic_load,
    caml_atomic_cas: caml_atomic_cas,
    caml_atomic_fetch_add: caml_atomic_fetch_add,
    caml_atomic_exchange: caml_atomic_exchange,
    caml_ml_domain_unique_token: caml_ml_domain_unique_token,
    caml_ml_domain_set_name: caml_ml_domain_set_name,
    caml_recommended_domain_count: caml_recommended_domain_count,
    caml_domain_id: caml_domain_id,
    caml_domain_spawn: caml_domain_spawn,
    caml_ml_domain_id: caml_ml_domain_id,
    caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
    caml_ephe_key_offset: caml_ephe_key_offset,
    caml_ephe_data_offset: caml_ephe_data_offset,
    caml_ephe_set_key: caml_ephe_set_key,
    caml_ephe_unset_key: caml_ephe_unset_key,
    caml_ephe_create: caml_ephe_create,
    caml_weak_create: caml_weak_create,
    caml_weak_set: caml_weak_set,
    caml_ephe_get_key: caml_ephe_get_key,
    caml_ephe_get_key_copy: caml_ephe_get_key_copy,
    caml_ephe_check_key: caml_ephe_check_key,
    caml_ephe_blit_key: caml_ephe_blit_key,
    caml_ephe_blit_data: caml_ephe_blit_data,
    caml_ephe_get_data: caml_ephe_get_data,
    caml_ephe_get_data_copy: caml_ephe_get_data_copy,
    caml_ephe_set_data: caml_ephe_set_data,
    caml_ephe_unset_data: caml_ephe_unset_data,
    caml_ephe_check_data: caml_ephe_check_data,
    caml_unix_gettimeofday: caml_unix_gettimeofday,
    caml_unix_time: caml_unix_time,
    caml_unix_gmtime: caml_unix_gmtime,
    caml_unix_localtime: caml_unix_localtime,
    caml_unix_mktime: caml_unix_mktime,
    caml_unix_startup: caml_unix_startup,
    caml_unix_cleanup: caml_unix_cleanup,
    caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
    caml_unix_isatty: caml_unix_isatty,
    make_unix_err_args: make_unix_err_args,
    caml_unix_stat: caml_unix_stat,
    caml_unix_stat_64: caml_unix_stat_64,
    caml_unix_lstat: caml_unix_lstat,
    caml_unix_lstat_64: caml_unix_lstat_64,
    caml_unix_mkdir: caml_unix_mkdir,
    caml_unix_rmdir: caml_unix_rmdir,
    caml_unix_symlink: caml_unix_symlink,
    caml_unix_readlink: caml_unix_readlink,
    caml_unix_unlink: caml_unix_unlink,
    caml_unix_getuid: caml_unix_getuid,
    caml_unix_getpwuid: caml_unix_getpwuid,
    caml_unix_has_symlink: caml_unix_has_symlink,
    caml_unix_opendir: caml_unix_opendir,
    caml_unix_readdir: caml_unix_readdir,
    caml_unix_closedir: caml_unix_closedir,
    caml_unix_rewinddir: caml_unix_rewinddir,
    caml_unix_findfirst: caml_unix_findfirst,
    caml_unix_findnext: caml_unix_findnext,
    caml_unix_findclose: caml_unix_findclose,
    caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
    re_match: re_match,
    re_search_forward: re_search_forward,
    re_search_backward: re_search_backward,
    re_string_match: re_string_match,
    re_partial_match: re_partial_match,
    re_replacement_text: re_replacement_text,
    caml_str_initialize: caml_str_initialize,
    caml_raise_sys_error: caml_raise_sys_error,
    caml_sys_exit: caml_sys_exit,
    caml_is_special_exception: caml_is_special_exception,
    caml_format_exception: caml_format_exception,
    caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
    caml_set_static_env: caml_set_static_env,
    caml_sys_getenv: caml_sys_getenv,
    caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
    caml_argv: caml_argv,
    caml_executable_name: caml_executable_name,
    caml_sys_get_argv: caml_sys_get_argv,
    caml_sys_argv: caml_sys_argv,
    caml_sys_modify_argv: caml_sys_modify_argv,
    caml_sys_executable_name: caml_sys_executable_name,
    caml_sys_system_command: caml_sys_system_command,
    caml_sys_time: caml_sys_time,
    caml_sys_time_include_children: caml_sys_time_include_children,
    caml_sys_random_seed: caml_sys_random_seed,
    caml_sys_const_big_endian: caml_sys_const_big_endian,
    caml_sys_const_word_size: caml_sys_const_word_size,
    caml_sys_const_int_size: caml_sys_const_int_size,
    caml_sys_const_max_wosize: caml_sys_const_max_wosize,
    caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
    caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
    caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
    caml_sys_const_backend_type: caml_sys_const_backend_type,
    os_type: os_type,
    caml_sys_get_config: caml_sys_get_config,
    caml_sys_isatty: caml_sys_isatty,
    caml_runtime_variant: caml_runtime_variant,
    caml_runtime_parameters: caml_runtime_parameters,
    caml_install_signal_handler: caml_install_signal_handler,
    caml_runtime_warnings: caml_runtime_warnings,
    caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
    caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
    caml_spacetime_enabled: caml_spacetime_enabled,
    caml_sys_const_naked_pointers_checked:
      caml_sys_const_naked_pointers_checked,
    caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
    caml_spacetime_only_works_for_native_code:
      caml_spacetime_only_works_for_native_code,
    caml_call_gen: caml_call_gen,
    caml_named_values: caml_named_values,
    caml_register_named_value: caml_register_named_value,
    caml_named_value: caml_named_value,
    caml_global_data: caml_global_data,
    caml_register_global: caml_register_global,
    caml_get_global_data: caml_get_global_data,
    caml_is_printable: caml_is_printable,
    caml_maybe_print_stats: caml_maybe_print_stats,
    caml_parser_trace: caml_parser_trace,
    caml_parse_engine: caml_parse_engine,
    caml_set_parser_trace: caml_set_parser_trace,
    caml_update_dummy: caml_update_dummy,
    caml_obj_is_block: caml_obj_is_block,
    caml_obj_tag: caml_obj_tag,
    caml_obj_set_tag: caml_obj_set_tag,
    caml_obj_block: caml_obj_block,
    caml_obj_with_tag: caml_obj_with_tag,
    caml_obj_dup: caml_obj_dup,
    caml_obj_truncate: caml_obj_truncate,
    caml_obj_make_forward: caml_obj_make_forward,
    caml_obj_compare_and_swap: caml_obj_compare_and_swap,
    caml_obj_is_shared: caml_obj_is_shared,
    caml_lazy_make_forward: caml_lazy_make_forward,
    caml_get_public_method: caml_get_public_method,
    caml_oo_last_id: caml_oo_last_id,
    caml_set_oo_id: caml_set_oo_id,
    caml_fresh_oo_id: caml_fresh_oo_id,
    caml_obj_raw_field: caml_obj_raw_field,
    caml_obj_set_raw_field: caml_obj_set_raw_field,
    caml_obj_reachable_words: caml_obj_reachable_words,
    caml_obj_add_offset: caml_obj_add_offset,
    caml_obj_update_tag: caml_obj_update_tag,
    caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
    caml_lazy_update_to_forward: caml_lazy_update_to_forward,
    caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
    caml_lazy_read_result: caml_lazy_read_result,
    caml_is_continuation_tag: caml_is_continuation_tag,
    initialize_nat: initialize_nat,
    MlNat: MlNat,
    caml_hash_nat: caml_hash_nat,
    nat_of_array: nat_of_array,
    create_nat: create_nat,
    set_to_zero_nat: set_to_zero_nat,
    blit_nat: blit_nat,
    set_digit_nat: set_digit_nat,
    nth_digit_nat: nth_digit_nat,
    set_digit_nat_native: set_digit_nat_native,
    nth_digit_nat_native: nth_digit_nat_native,
    num_digits_nat: num_digits_nat,
    num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
    is_digit_int: is_digit_int,
    is_digit_zero: is_digit_zero,
    is_digit_odd: is_digit_odd,
    incr_nat: incr_nat,
    add_nat: add_nat,
    complement_nat: complement_nat,
    decr_nat: decr_nat,
    sub_nat: sub_nat,
    mult_digit_nat: mult_digit_nat,
    mult_nat: mult_nat,
    square_nat: square_nat,
    shift_left_nat: shift_left_nat,
    div_helper: div_helper,
    div_digit_nat: div_digit_nat,
    div_nat: div_nat,
    shift_right_nat: shift_right_nat,
    compare_digits_nat: compare_digits_nat,
    compare_nat: compare_nat,
    compare_nat_real: compare_nat_real,
    land_digit_nat: land_digit_nat,
    lor_digit_nat: lor_digit_nat,
    lxor_digit_nat: lxor_digit_nat,
    serialize_nat: serialize_nat,
    deserialize_nat: deserialize_nat,
    caml_str_repeat: caml_str_repeat,
    caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
    caml_utf8_of_utf16: caml_utf8_of_utf16,
    caml_utf16_of_utf8: caml_utf16_of_utf8,
    jsoo_is_ascii: jsoo_is_ascii,
    caml_bytes_unsafe_get: caml_bytes_unsafe_get,
    caml_bytes_unsafe_set: caml_bytes_unsafe_set,
    caml_string_bound_error: caml_string_bound_error,
    caml_bytes_bound_error: caml_bytes_bound_error,
    caml_string_get: caml_string_get,
    caml_string_get16: caml_string_get16,
    caml_bytes_get16: caml_bytes_get16,
    caml_string_get32: caml_string_get32,
    caml_bytes_get32: caml_bytes_get32,
    caml_string_get64: caml_string_get64,
    caml_bytes_get64: caml_bytes_get64,
    caml_bytes_get: caml_bytes_get,
    caml_string_set: caml_string_set,
    caml_bytes_set16: caml_bytes_set16,
    caml_string_set16: caml_string_set16,
    caml_bytes_set32: caml_bytes_set32,
    caml_string_set32: caml_string_set32,
    caml_bytes_set64: caml_bytes_set64,
    caml_string_set64: caml_string_set64,
    caml_bytes_set: caml_bytes_set,
    caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
    MlBytes: MlBytes,
    caml_convert_string_to_bytes: caml_convert_string_to_bytes,
    caml_convert_bytes_to_array: caml_convert_bytes_to_array,
    caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
    caml_uint8_array_of_string: caml_uint8_array_of_string,
    caml_create_string: caml_create_string,
    caml_create_bytes: caml_create_bytes,
    caml_string_of_array: caml_string_of_array,
    caml_bytes_of_array: caml_bytes_of_array,
    caml_bytes_compare: caml_bytes_compare,
    caml_bytes_equal: caml_bytes_equal,
    caml_string_notequal: caml_string_notequal,
    caml_bytes_notequal: caml_bytes_notequal,
    caml_bytes_lessequal: caml_bytes_lessequal,
    caml_bytes_lessthan: caml_bytes_lessthan,
    caml_string_greaterequal: caml_string_greaterequal,
    caml_bytes_greaterequal: caml_bytes_greaterequal,
    caml_string_greaterthan: caml_string_greaterthan,
    caml_bytes_greaterthan: caml_bytes_greaterthan,
    caml_fill_bytes: caml_fill_bytes,
    caml_blit_bytes: caml_blit_bytes,
    caml_blit_string: caml_blit_string,
    caml_ml_bytes_length: caml_ml_bytes_length,
    caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
    caml_string_unsafe_get: caml_string_unsafe_get,
    caml_string_unsafe_set: caml_string_unsafe_set,
    caml_ml_string_length: caml_ml_string_length,
    caml_string_compare: caml_string_compare,
    caml_string_equal: caml_string_equal,
    caml_string_lessequal: caml_string_lessequal,
    caml_string_lessthan: caml_string_lessthan,
    caml_string_of_bytes: caml_string_of_bytes,
    caml_bytes_of_string: caml_bytes_of_string,
    caml_string_of_jsbytes: caml_string_of_jsbytes,
    caml_jsbytes_of_string: caml_jsbytes_of_string,
    caml_jsstring_of_string: caml_jsstring_of_string,
    caml_string_of_jsstring: caml_string_of_jsstring,
    caml_is_ml_bytes: caml_is_ml_bytes,
    caml_ml_bytes_content: caml_ml_bytes_content,
    caml_is_ml_string: caml_is_ml_string,
    caml_js_to_byte_string: caml_js_to_byte_string,
    caml_new_string: caml_new_string,
    caml_js_from_string: caml_js_from_string,
    caml_to_js_string: caml_to_js_string,
    caml_js_to_string: caml_js_to_string,
    caml_array_of_string: caml_array_of_string,
    caml_array_of_bytes: caml_array_of_bytes,
    caml_md5_chan: caml_md5_chan,
    caml_md5_string: caml_md5_string,
    caml_MD5Transform: caml_MD5Transform,
    caml_MD5Init: caml_MD5Init,
    caml_MD5Update: caml_MD5Update,
    caml_MD5Final: caml_MD5Final,
    caml_md5_bytes: caml_md5_bytes,
    caml_marshal_constants: caml_marshal_constants,
    MlStringReader: MlStringReader,
    BigStringReader: BigStringReader,
    caml_float_of_bytes: caml_float_of_bytes,
    caml_input_value_from_string: caml_input_value_from_string,
    caml_input_value_from_bytes: caml_input_value_from_bytes,
    caml_int64_unmarshal: caml_int64_unmarshal,
    caml_int64_marshal: caml_int64_marshal,
    caml_int32_unmarshal: caml_int32_unmarshal,
    caml_nativeint_unmarshal: caml_nativeint_unmarshal,
    caml_custom_ops: caml_custom_ops,
    caml_input_value_from_reader: caml_input_value_from_reader,
    caml_marshal_data_size: caml_marshal_data_size,
    MlObjectTable: MlObjectTable,
    caml_legacy_custom_code: caml_legacy_custom_code,
    caml_output_val: caml_output_val,
    caml_output_value_to_string: caml_output_value_to_string,
    caml_output_value_to_bytes: caml_output_value_to_bytes,
    caml_output_value_to_buffer: caml_output_value_to_buffer,
    caml_lex_array: caml_lex_array,
    caml_lex_engine: caml_lex_engine,
    caml_new_lex_engine: caml_new_lex_engine,
    caml_js_on_ie: caml_js_on_ie,
    caml_js_html_escape: caml_js_html_escape,
    caml_js_html_entities: caml_js_html_entities,
    caml_js_get_console: caml_js_get_console,
    caml_xmlhttprequest_create: caml_xmlhttprequest_create,
    caml_js_error_of_exception: caml_js_error_of_exception,
    caml_js_pure_expr: caml_js_pure_expr,
    caml_js_set: caml_js_set,
    caml_js_get: caml_js_get,
    caml_js_delete: caml_js_delete,
    caml_js_instanceof: caml_js_instanceof,
    caml_js_typeof: caml_js_typeof,
    caml_trampoline: caml_trampoline,
    caml_trampoline_return: caml_trampoline_return,
    caml_callback: caml_callback,
    caml_is_js: caml_is_js,
    caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
    caml_jsoo_flags_effects: caml_jsoo_flags_effects,
    caml_wrap_exception: caml_wrap_exception,
    caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
    caml_js_error_option_of_exception: caml_js_error_option_of_exception,
    caml_js_from_bool: caml_js_from_bool,
    caml_js_to_bool: caml_js_to_bool,
    caml_js_from_float: caml_js_from_float,
    caml_js_to_float: caml_js_to_float,
    caml_js_from_array: caml_js_from_array,
    caml_js_to_array: caml_js_to_array,
    caml_list_of_js_array: caml_list_of_js_array,
    caml_list_to_js_array: caml_list_to_js_array,
    caml_js_var: caml_js_var,
    caml_js_call: caml_js_call,
    caml_js_fun_call: caml_js_fun_call,
    caml_js_meth_call: caml_js_meth_call,
    caml_js_new: caml_js_new,
    caml_ojs_new_arr: caml_ojs_new_arr,
    caml_js_wrap_callback: caml_js_wrap_callback,
    caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
    caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
    caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
    caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
    caml_js_wrap_meth_callback_arguments: caml_js_wrap_meth_callback_arguments,
    caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
    caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
    caml_js_function_arity: caml_js_function_arity,
    caml_js_equals: caml_js_equals,
    caml_js_eval_string: caml_js_eval_string,
    caml_js_expr: caml_js_expr,
    caml_pure_js_expr: caml_pure_js_expr,
    caml_js_object: caml_js_object,
    caml_sys_fds: caml_sys_fds,
    caml_sys_close: caml_sys_close,
    caml_sys_open: caml_sys_open,
    caml_ml_set_channel_name: caml_ml_set_channel_name,
    caml_ml_channels: caml_ml_channels,
    caml_ml_out_channels_list: caml_ml_out_channels_list,
    caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
    caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
    caml_channel_descriptor: caml_channel_descriptor,
    caml_ml_set_binary_mode: caml_ml_set_binary_mode,
    caml_ml_close_channel: caml_ml_close_channel,
    caml_ml_channel_size: caml_ml_channel_size,
    caml_ml_channel_size_64: caml_ml_channel_size_64,
    caml_ml_set_channel_output: caml_ml_set_channel_output,
    caml_ml_set_channel_refill: caml_ml_set_channel_refill,
    caml_refill: caml_refill,
    caml_ml_input: caml_ml_input,
    caml_ml_input_block: caml_ml_input_block,
    caml_input_value: caml_input_value,
    caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
    caml_ml_input_char: caml_ml_input_char,
    caml_ml_input_int: caml_ml_input_int,
    caml_seek_in: caml_seek_in,
    caml_ml_seek_in: caml_ml_seek_in,
    caml_ml_seek_in_64: caml_ml_seek_in_64,
    caml_pos_in: caml_pos_in,
    caml_ml_pos_in: caml_ml_pos_in,
    caml_ml_pos_in_64: caml_ml_pos_in_64,
    caml_ml_input_scan_line: caml_ml_input_scan_line,
    caml_ml_flush: caml_ml_flush,
    caml_ml_output_bytes: caml_ml_output_bytes,
    caml_ml_output: caml_ml_output,
    caml_ml_output_char: caml_ml_output_char,
    caml_output_value: caml_output_value,
    caml_seek_out: caml_seek_out,
    caml_ml_seek_out: caml_ml_seek_out,
    caml_ml_seek_out_64: caml_ml_seek_out_64,
    caml_pos_out: caml_pos_out,
    caml_ml_pos_out: caml_ml_pos_out,
    caml_ml_pos_out_64: caml_ml_pos_out_64,
    caml_ml_output_int: caml_ml_output_int,
    caml_ml_is_buffered: caml_ml_is_buffered,
    caml_ml_set_buffered: caml_ml_set_buffered,
    caml_format_int: caml_format_int,
    caml_parse_sign_and_base: caml_parse_sign_and_base,
    caml_parse_digit: caml_parse_digit,
    caml_int_of_string: caml_int_of_string,
    caml_mul: caml_mul,
    caml_div: caml_div,
    caml_mod: caml_mod,
    caml_bswap16: caml_bswap16,
    caml_int32_bswap: caml_int32_bswap,
    caml_int64_bswap: caml_int64_bswap,
    caml_int64_offset: caml_int64_offset,
    MlInt64: MlInt64,
    caml_int64_ult: caml_int64_ult,
    caml_int64_compare: caml_int64_compare,
    caml_int64_neg: caml_int64_neg,
    caml_int64_add: caml_int64_add,
    caml_int64_sub: caml_int64_sub,
    caml_int64_mul: caml_int64_mul,
    caml_int64_is_zero: caml_int64_is_zero,
    caml_int64_is_negative: caml_int64_is_negative,
    caml_int64_and: caml_int64_and,
    caml_int64_or: caml_int64_or,
    caml_int64_xor: caml_int64_xor,
    caml_int64_shift_left: caml_int64_shift_left,
    caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
    caml_int64_shift_right: caml_int64_shift_right,
    caml_int64_div: caml_int64_div,
    caml_int64_mod: caml_int64_mod,
    caml_int64_of_int32: caml_int64_of_int32,
    caml_int64_to_int32: caml_int64_to_int32,
    caml_int64_to_float: caml_int64_to_float,
    caml_int64_of_float: caml_int64_of_float,
    caml_int64_format: caml_int64_format,
    caml_int64_of_string: caml_int64_of_string,
    caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
    caml_int64_create_lo_hi: caml_int64_create_lo_hi,
    caml_int64_lo32: caml_int64_lo32,
    caml_int64_hi32: caml_int64_hi32,
    caml_int64_of_bytes: caml_int64_of_bytes,
    caml_int64_to_bytes: caml_int64_to_bytes,
    caml_int64_hash: caml_int64_hash,
    jsoo_floor_log2: jsoo_floor_log2,
    caml_int64_bits_of_float: caml_int64_bits_of_float,
    caml_int32_bits_of_float: caml_int32_bits_of_float,
    caml_hexstring_of_float: caml_hexstring_of_float,
    caml_int64_float_of_bits: caml_int64_float_of_bits,
    caml_nextafter_float: caml_nextafter_float,
    caml_trunc_float: caml_trunc_float,
    caml_int32_float_of_bits: caml_int32_float_of_bits,
    caml_classify_float: caml_classify_float,
    caml_modf_float: caml_modf_float,
    caml_ldexp_float: caml_ldexp_float,
    caml_frexp_float: caml_frexp_float,
    caml_float_compare: caml_float_compare,
    caml_copysign_float: caml_copysign_float,
    caml_signbit_float: caml_signbit_float,
    caml_expm1_float: caml_expm1_float,
    caml_exp2_float: caml_exp2_float,
    caml_log1p_float: caml_log1p_float,
    caml_log2_float: caml_log2_float,
    caml_hypot_float: caml_hypot_float,
    caml_log10_float: caml_log10_float,
    caml_cosh_float: caml_cosh_float,
    caml_acosh_float: caml_acosh_float,
    caml_sinh_float: caml_sinh_float,
    caml_asinh_float: caml_asinh_float,
    caml_tanh_float: caml_tanh_float,
    caml_atanh_float: caml_atanh_float,
    caml_round_float: caml_round_float,
    caml_cbrt_float: caml_cbrt_float,
    caml_erf_float: caml_erf_float,
    caml_erfc_float: caml_erfc_float,
    caml_fma_float: caml_fma_float,
    caml_format_float: caml_format_float,
    caml_float_of_string: caml_float_of_string,
    caml_hash_mix_int: caml_hash_mix_int,
    caml_hash_mix_final: caml_hash_mix_final,
    caml_hash_mix_float: caml_hash_mix_float,
    caml_hash_mix_int64: caml_hash_mix_int64,
    caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
    caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
    caml_hash_mix_bytes: caml_hash_mix_bytes,
    caml_hash_mix_string: caml_hash_mix_string,
    caml_hash: caml_hash,
    caml_string_hash: caml_string_hash,
    caml_gr_state: caml_gr_state,
    caml_gr_state_get: caml_gr_state_get,
    caml_gr_state_set: caml_gr_state_set,
    caml_gr_open_graph: caml_gr_open_graph,
    caml_gr_state_init: caml_gr_state_init,
    caml_gr_state_create: caml_gr_state_create,
    caml_gr_doc_of_state: caml_gr_doc_of_state,
    caml_gr_close_graph: caml_gr_close_graph,
    caml_gr_set_window_title: caml_gr_set_window_title,
    caml_gr_resize_window: caml_gr_resize_window,
    caml_gr_clear_graph: caml_gr_clear_graph,
    caml_gr_size_x: caml_gr_size_x,
    caml_gr_size_y: caml_gr_size_y,
    caml_gr_set_color: caml_gr_set_color,
    caml_gr_plot: caml_gr_plot,
    caml_gr_point_color: caml_gr_point_color,
    caml_gr_moveto: caml_gr_moveto,
    caml_gr_current_x: caml_gr_current_x,
    caml_gr_current_y: caml_gr_current_y,
    caml_gr_lineto: caml_gr_lineto,
    caml_gr_draw_rect: caml_gr_draw_rect,
    caml_gr_arc_aux: caml_gr_arc_aux,
    caml_gr_draw_arc: caml_gr_draw_arc,
    caml_gr_set_line_width: caml_gr_set_line_width,
    caml_gr_fill_rect: caml_gr_fill_rect,
    caml_gr_fill_poly: caml_gr_fill_poly,
    caml_gr_fill_arc: caml_gr_fill_arc,
    caml_gr_draw_str: caml_gr_draw_str,
    caml_gr_draw_char: caml_gr_draw_char,
    caml_gr_draw_string: caml_gr_draw_string,
    caml_gr_set_font: caml_gr_set_font,
    caml_gr_set_text_size: caml_gr_set_text_size,
    caml_gr_text_size: caml_gr_text_size,
    caml_gr_make_image: caml_gr_make_image,
    caml_gr_dump_image: caml_gr_dump_image,
    caml_gr_draw_image: caml_gr_draw_image,
    caml_gr_create_image: caml_gr_create_image,
    caml_gr_blit_image: caml_gr_blit_image,
    caml_gr_sigio_handler: caml_gr_sigio_handler,
    caml_gr_sigio_signal: caml_gr_sigio_signal,
    caml_gr_wait_event: caml_gr_wait_event,
    caml_gr_synchronize: caml_gr_synchronize,
    caml_gr_remember_mode: caml_gr_remember_mode,
    caml_gr_display_mode: caml_gr_display_mode,
    caml_gr_window_id: caml_gr_window_id,
    caml_gr_open_subwindow: caml_gr_open_subwindow,
    caml_gr_close_subwindow: caml_gr_close_subwindow,
    caml_gc_minor: caml_gc_minor,
    caml_gc_major: caml_gc_major,
    caml_gc_full_major: caml_gc_full_major,
    caml_gc_compaction: caml_gc_compaction,
    caml_gc_counters: caml_gc_counters,
    caml_gc_quick_stat: caml_gc_quick_stat,
    caml_gc_stat: caml_gc_stat,
    caml_gc_set: caml_gc_set,
    caml_gc_get: caml_gc_get,
    caml_memprof_set: caml_memprof_set,
    caml_final_register: caml_final_register,
    caml_final_register_called_without_value:
      caml_final_register_called_without_value,
    caml_final_release: caml_final_release,
    caml_memprof_start: caml_memprof_start,
    caml_memprof_stop: caml_memprof_stop,
    caml_eventlog_resume: caml_eventlog_resume,
    caml_eventlog_pause: caml_eventlog_pause,
    caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
    caml_gc_major_slice: caml_gc_major_slice,
    caml_gc_minor_words: caml_gc_minor_words,
    caml_get_minor_free: caml_get_minor_free,
    caml_get_major_bucket: caml_get_major_bucket,
    caml_get_major_credit: caml_get_major_credit,
    fs_node_supported: fs_node_supported,
    MlNodeDevice: MlNodeDevice,
    MlNodeFd: MlNodeFd,
    caml_sys_open_for_node: caml_sys_open_for_node,
    MlFakeDevice: MlFakeDevice,
    MlFakeFile: MlFakeFile,
    MlFakeFd_out: MlFakeFd_out,
    MlFakeFd: MlFakeFd,
    caml_trailing_slash: caml_trailing_slash,
    caml_current_dir: caml_current_dir,
    caml_get_root: caml_get_root,
    caml_root: caml_root,
    MlFile: MlFile,
    path_is_absolute: path_is_absolute,
    caml_make_path: caml_make_path,
    jsoo_mount_point: jsoo_mount_point,
    caml_list_mount_point: caml_list_mount_point,
    resolve_fs_device: resolve_fs_device,
    caml_mount_autoload: caml_mount_autoload,
    caml_unmount: caml_unmount,
    caml_sys_getcwd: caml_sys_getcwd,
    caml_sys_chdir: caml_sys_chdir,
    caml_raise_no_such_file: caml_raise_no_such_file,
    caml_raise_not_a_dir: caml_raise_not_a_dir,
    caml_sys_file_exists: caml_sys_file_exists,
    caml_sys_read_directory: caml_sys_read_directory,
    caml_sys_remove: caml_sys_remove,
    caml_sys_is_directory: caml_sys_is_directory,
    caml_sys_rename: caml_sys_rename,
    caml_sys_mkdir: caml_sys_mkdir,
    caml_sys_rmdir: caml_sys_rmdir,
    caml_ba_map_file: caml_ba_map_file,
    caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
    jsoo_create_file_extern: jsoo_create_file_extern,
    caml_fs_init: caml_fs_init,
    caml_create_file: caml_create_file,
    jsoo_create_file: jsoo_create_file,
    caml_read_file_content: caml_read_file_content,
    caml_parse_format: caml_parse_format,
    caml_finish_formatting: caml_finish_formatting,
    caml_raise_constant: caml_raise_constant,
    caml_return_exn_constant: caml_return_exn_constant,
    caml_raise_with_arg: caml_raise_with_arg,
    caml_raise_with_args: caml_raise_with_args,
    caml_raise_with_string: caml_raise_with_string,
    caml_failwith: caml_failwith,
    caml_invalid_argument: caml_invalid_argument,
    caml_raise_end_of_file: caml_raise_end_of_file,
    caml_raise_zero_divide: caml_raise_zero_divide,
    caml_raise_not_found: caml_raise_not_found,
    caml_array_bound_error: caml_array_bound_error,
    caml_compare_val_tag: caml_compare_val_tag,
    caml_compare_val_get_custom: caml_compare_val_get_custom,
    caml_compare_val_number_custom: caml_compare_val_number_custom,
    caml_compare_val: caml_compare_val,
    caml_compare: caml_compare,
    caml_int_compare: caml_int_compare,
    caml_equal: caml_equal,
    caml_notequal: caml_notequal,
    caml_greaterequal: caml_greaterequal,
    caml_greaterthan: caml_greaterthan,
    caml_lessequal: caml_lessequal,
    caml_lessthan: caml_lessthan,
    caml_blit_bigstring_to_bigstring: caml_blit_bigstring_to_bigstring,
    caml_blit_bigstring_to_string: caml_blit_bigstring_to_string,
    caml_blit_string_to_bigstring: caml_blit_string_to_bigstring,
    caml_hash_mix_bigstring: caml_hash_mix_bigstring,
    bigstring_to_array_buffer: bigstring_to_array_buffer,
    bigstring_to_typed_array: bigstring_to_typed_array,
    bigstring_of_array_buffer: bigstring_of_array_buffer,
    bigstring_of_typed_array: bigstring_of_typed_array,
    caml_bigstring_memcmp: caml_bigstring_memcmp,
    caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
    caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
    caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
    caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
    caml_ba_init: caml_ba_init,
    caml_ba_get_size: caml_ba_get_size,
    caml_ba_get_size_per_element: caml_ba_get_size_per_element,
    caml_ba_create_buffer: caml_ba_create_buffer,
    caml_ba_custom_name: caml_ba_custom_name,
    Ml_Bigarray: Ml_Bigarray,
    Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
    caml_ba_compare: caml_ba_compare,
    caml_ba_create_unsafe: caml_ba_create_unsafe,
    caml_ba_create: caml_ba_create,
    caml_ba_change_layout: caml_ba_change_layout,
    caml_ba_kind: caml_ba_kind,
    caml_ba_layout: caml_ba_layout,
    caml_ba_num_dims: caml_ba_num_dims,
    caml_ba_dim: caml_ba_dim,
    caml_ba_dim_1: caml_ba_dim_1,
    caml_ba_dim_2: caml_ba_dim_2,
    caml_ba_dim_3: caml_ba_dim_3,
    caml_ba_get_generic: caml_ba_get_generic,
    caml_ba_uint8_get16: caml_ba_uint8_get16,
    caml_ba_uint8_get32: caml_ba_uint8_get32,
    caml_ba_uint8_get64: caml_ba_uint8_get64,
    caml_ba_get_1: caml_ba_get_1,
    caml_ba_get_2: caml_ba_get_2,
    caml_ba_get_3: caml_ba_get_3,
    caml_ba_set_generic: caml_ba_set_generic,
    caml_ba_uint8_set16: caml_ba_uint8_set16,
    caml_ba_uint8_set32: caml_ba_uint8_set32,
    caml_ba_uint8_set64: caml_ba_uint8_set64,
    caml_ba_set_1: caml_ba_set_1,
    caml_ba_set_2: caml_ba_set_2,
    caml_ba_set_3: caml_ba_set_3,
    caml_ba_fill: caml_ba_fill,
    caml_ba_blit: caml_ba_blit,
    caml_ba_sub: caml_ba_sub,
    caml_ba_slice: caml_ba_slice,
    caml_ba_reshape: caml_ba_reshape,
    caml_ba_serialize: caml_ba_serialize,
    caml_ba_deserialize: caml_ba_deserialize,
    caml_ba_create_from: caml_ba_create_from,
    caml_ba_hash: caml_ba_hash,
    caml_ba_to_typed_array: caml_ba_to_typed_array,
    caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
    caml_ba_from_typed_array: caml_ba_from_typed_array,
    caml_ml_debug_info_status: caml_ml_debug_info_status,
    caml_backtrace_status: caml_backtrace_status,
    caml_get_exception_backtrace: caml_get_exception_backtrace,
    caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
    caml_record_backtrace: caml_record_backtrace,
    caml_convert_raw_backtrace: caml_convert_raw_backtrace,
    caml_raw_backtrace_length: caml_raw_backtrace_length,
    caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
    caml_raw_backtrace_slot: caml_raw_backtrace_slot,
    caml_restore_raw_backtrace: caml_restore_raw_backtrace,
    caml_get_current_callstack: caml_get_current_callstack,
    caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
    caml_array_sub: caml_array_sub,
    caml_array_append: caml_array_append,
    caml_array_concat: caml_array_concat,
    caml_array_blit: caml_array_blit,
    caml_floatarray_blit: caml_floatarray_blit,
    caml_array_set: caml_array_set,
    caml_array_get: caml_array_get,
    caml_array_fill: caml_array_fill,
    caml_check_bound: caml_check_bound,
    caml_make_vect: caml_make_vect,
    caml_make_float_vect: caml_make_float_vect,
    caml_floatarray_create: caml_floatarray_create
  };
  caml_fs_init();
  caml_register_global
    (0, [248, caml_string_of_jsbytes("Out_of_memory"), -1], "Out_of_memory");
  caml_register_global
    (1, [248, caml_string_of_jsbytes("Sys_error"), -2], "Sys_error");
  caml_register_global
    (2, [248, caml_string_of_jsbytes("Failure"), -3], "Failure");
  caml_register_global
    (3,
      [248, caml_string_of_jsbytes("Invalid_argument"), -4],
      "Invalid_argument");
  caml_register_global
    (4, [248, caml_string_of_jsbytes("End_of_file"), -5], "End_of_file");
  caml_register_global
    (5,
      [248, caml_string_of_jsbytes("Division_by_zero"), -6],
      "Division_by_zero");
  caml_register_global
    (6, [248, caml_string_of_jsbytes("Not_found"), -7], "Not_found");
  caml_register_global
    (7, [248, caml_string_of_jsbytes("Match_failure"), -8], "Match_failure");
  caml_register_global
    (8, [248, caml_string_of_jsbytes("Stack_overflow"), -9], "Stack_overflow");
  caml_register_global
    (9, [248, caml_string_of_jsbytes("Sys_blocked_io"), -10], "Sys_blocked_io");
  caml_register_global
    (10, [248, caml_string_of_jsbytes("Assert_failure"), -11], "Assert_failure");
  caml_register_global
    (11,
      [248, caml_string_of_jsbytes("Undefined_recursive_module"), -12],
      "Undefined_recursive_module");
  return
}
  (globalThis));


//# 1 ".js/stdlib/stdlib.cma.js"
// Generated by js_of_ocaml
(function
  (globalThis) {
  "use strict";
  var
    runtime = globalThis.jsoo_runtime,
    caml_array_concat = runtime.caml_array_concat,
    caml_array_get = runtime.caml_array_get,
    caml_array_set = runtime.caml_array_set,
    caml_array_sub = runtime.caml_array_sub,
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_div = runtime.caml_div,
    caml_ephe_blit_key = runtime.caml_ephe_blit_key,
    caml_ephe_check_key = runtime.caml_ephe_check_key,
    caml_ephe_get_key = runtime.caml_ephe_get_key,
    caml_ephe_get_key_copy = runtime.caml_ephe_get_key_copy,
    caml_ephe_set_key = runtime.caml_ephe_set_key,
    caml_ephe_unset_key = runtime.caml_ephe_unset_key,
    caml_equal = runtime.caml_equal,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_float_compare = runtime.caml_float_compare,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_floatarray_blit = runtime.caml_floatarray_blit,
    caml_floatarray_create = runtime.caml_floatarray_create,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_hash = runtime.caml_hash,
    caml_input_value = runtime.caml_input_value,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_format = runtime.caml_int64_format,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int_compare = runtime.caml_int_compare,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_make_vect = runtime.caml_make_vect,
    caml_marshal_data_size = runtime.caml_marshal_data_size,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_pos_in = runtime.caml_ml_pos_in,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mod = runtime.caml_mod,
    caml_mul = runtime.caml_mul,
    caml_nextafter_float = runtime.caml_nextafter_float,
    caml_notequal = runtime.caml_notequal,
    caml_obj_block = runtime.caml_obj_block,
    caml_obj_make_forward = runtime.caml_obj_make_forward,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_output_value = runtime.caml_output_value,
    caml_register_global = runtime.caml_register_global,
    caml_register_named_value = runtime.caml_register_named_value,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_signbit_float = runtime.caml_signbit_float,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_string_of_jsbytes = runtime.caml_string_of_jsbytes,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_sys_open = runtime.caml_sys_open,
    caml_sys_random_seed = runtime.caml_sys_random_seed,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
  function caml_call1(f, a0) { return f.length == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]) }
  function caml_call2(f, a0, a1) { return f.length == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]) }
  function caml_call3(f, a0, a1, a2) { return f.length == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]) }
  function caml_call4(f, a0, a1, a2, a3) {
    return f.length == 4
      ? f(a0, a1, a2, a3)
      : runtime.caml_call_gen(f, [a0, a1, a2, a3])
  }
  function caml_call5(f, a0, a1, a2, a3, a4) {
    return f.length == 5
      ? f(a0, a1, a2, a3, a4)
      : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4])
  }
  function caml_call7(f, a0, a1, a2, a3, a4, a5, a6) {
    return f.length == 7
      ? f(a0, a1, a2, a3, a4, a5, a6)
      : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6])
  }
  var
    global_data = runtime.caml_get_global_data(),
    cst$0 = caml_string_of_jsbytes("%,"),
    cst_really_input = caml_string_of_jsbytes("really_input"),
    cst_input = caml_string_of_jsbytes("input"),
    cst_output_substring = caml_string_of_jsbytes("output_substring"),
    cst_output = caml_string_of_jsbytes("output"),
    cst_12g = caml_string_of_jsbytes("%.12g"),
    cst = caml_string_of_jsbytes("."),
    cst_false$1 = caml_string_of_jsbytes("false"),
    cst_true$1 = caml_string_of_jsbytes("true"),
    cst_false$0 = caml_string_of_jsbytes("false"),
    cst_true$0 = caml_string_of_jsbytes("true"),
    cst_bool_of_string = caml_string_of_jsbytes("bool_of_string"),
    cst_true = caml_string_of_jsbytes("true"),
    cst_false = caml_string_of_jsbytes("false"),
    cst_char_of_int = caml_string_of_jsbytes("char_of_int"),
    cst_Stdlib_Exit = caml_string_of_jsbytes("Stdlib.Exit"),
    cst_Stdlib_Pervasives_Exit =
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
    cst_Stdlib_Sys_Break = caml_string_of_jsbytes("Stdlib.Sys.Break"),
    ocaml_version = caml_string_of_jsbytes("4.14.0"),
    ocaml_release = [0, 4, 14, 0, 0],
    cst_Obj_Ephemeron_blit_key =
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
    cst_Obj_Ephemeron_check_key =
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
    cst_Obj_Ephemeron_unset_key =
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
    cst_Obj_Ephemeron_set_key = caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
    cst_Obj_Ephemeron_get_key_copy =
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
    cst_Obj_Ephemeron_get_key = caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
    cst_Obj_Ephemeron_create = caml_string_of_jsbytes("Obj.Ephemeron.create"),
    cst_Obj_extension_constructor$0 =
      caml_string_of_jsbytes("Obj.extension_constructor"),
    cst_Obj_extension_constructor =
      caml_string_of_jsbytes("Obj.extension_constructor"),
    cst_CamlinternalLazy_Undefined =
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
    cst_Seq_drop = caml_string_of_jsbytes("Seq.drop"),
    cst_Seq_take = caml_string_of_jsbytes("Seq.take"),
    cst_Seq_init = caml_string_of_jsbytes("Seq.init"),
    cst_Stdlib_Seq_Forced_twice =
      caml_string_of_jsbytes("Stdlib.Seq.Forced_twice"),
    cst_option_is_None = caml_string_of_jsbytes("option is None"),
    cst_result_is_Ok = caml_string_of_jsbytes("result is Ok _"),
    cst_result_is_Error = caml_string_of_jsbytes("result is Error _"),
    cst_true$2 = caml_string_of_jsbytes("true"),
    cst_false$2 = caml_string_of_jsbytes("false"),
    cst$1 = caml_string_of_jsbytes("\\\\"),
    cst$2 = caml_string_of_jsbytes("\\'"),
    cst_b = caml_string_of_jsbytes("\\b"),
    cst_t = caml_string_of_jsbytes("\\t"),
    cst_n = caml_string_of_jsbytes("\\n"),
    cst_r = caml_string_of_jsbytes("\\r"),
    cst_Char_chr = caml_string_of_jsbytes("Char.chr"),
    cst_is_not_a_latin1_character =
      caml_string_of_jsbytes(" is not a latin1 character"),
    cst_04X = caml_string_of_jsbytes("%04X"),
    cst_U = caml_string_of_jsbytes("U+"),
    cst_is_not_an_Unicode_scalar_v =
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
    cst_X = caml_string_of_jsbytes("%X"),
    err_no_pred = caml_string_of_jsbytes("U+0000 has no predecessor"),
    err_no_succ = caml_string_of_jsbytes("U+10FFFF has no successor"),
    cst_List_map2 = caml_string_of_jsbytes("List.map2"),
    cst_List_iter2 = caml_string_of_jsbytes("List.iter2"),
    cst_List_fold_left2 = caml_string_of_jsbytes("List.fold_left2"),
    cst_List_fold_right2 = caml_string_of_jsbytes("List.fold_right2"),
    cst_List_for_all2 = caml_string_of_jsbytes("List.for_all2"),
    cst_List_exists2 = caml_string_of_jsbytes("List.exists2"),
    cst_List_combine = caml_string_of_jsbytes("List.combine"),
    cst_List_rev_map2 = caml_string_of_jsbytes("List.rev_map2"),
    cst_List_init = caml_string_of_jsbytes("List.init"),
    cst_List_nth$0 = caml_string_of_jsbytes("List.nth"),
    cst_nth = caml_string_of_jsbytes("nth"),
    cst_List_nth = caml_string_of_jsbytes("List.nth"),
    cst_tl = caml_string_of_jsbytes("tl"),
    cst_hd = caml_string_of_jsbytes("hd"),
    cst_index_out_of_bounds$2 = caml_string_of_jsbytes("index out of bounds"),
    cst_index_out_of_bounds$1 = caml_string_of_jsbytes("index out of bounds"),
    cst_index_out_of_bounds$0 = caml_string_of_jsbytes("index out of bounds"),
    cst_index_out_of_bounds = caml_string_of_jsbytes("index out of bounds"),
    cst_Bytes_of_seq_cannot_grow_b =
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
    cst_String_rcontains_from_Byte =
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
    cst_String_contains_from_Bytes =
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
    cst_String_rindex_from_opt_Byt =
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
    cst_String_rindex_from_Bytes_r =
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
    cst_String_index_from_opt_Byte =
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
    cst_String_index_from_Bytes_in =
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
    cst_Bytes_concat = caml_string_of_jsbytes("Bytes.concat"),
    cst_String_blit_Bytes_blit_str =
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
    cst_Bytes_blit = caml_string_of_jsbytes("Bytes.blit"),
    cst_String_fill_Bytes_fill =
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
    cst_Bytes_extend = caml_string_of_jsbytes("Bytes.extend"),
    cst_String_sub_Bytes_sub = caml_string_of_jsbytes("String.sub / Bytes.sub"),
    cst_String_rcontains_from_Byte$0 =
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
    cst_String_contains_from_Bytes$0 =
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
    cst_String_rindex_from_opt_Byt$0 =
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
    cst_String_rindex_from_Bytes_r$0 =
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
    cst_String_index_from_opt_Byte$0 =
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
    cst_String_index_from_Bytes_in$0 =
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
    cst$4 = caml_string_of_jsbytes(""),
    cst$3 = caml_string_of_jsbytes(""),
    cst_String_concat = caml_string_of_jsbytes("String.concat"),
    empty$1 = caml_string_of_jsbytes(""),
    cst$5 = caml_string_of_jsbytes("()"),
    cst_Marshal_from_bytes = caml_string_of_jsbytes("Marshal.from_bytes"),
    cst_Marshal_from_bytes$0 = caml_string_of_jsbytes("Marshal.from_bytes"),
    cst_Marshal_data_size = caml_string_of_jsbytes("Marshal.data_size"),
    cst_Marshal_to_buffer_substrin =
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
    cst_Array_combine = caml_string_of_jsbytes("Array.combine"),
    cst_Array_exists2 = caml_string_of_jsbytes("Array.exists2"),
    cst_Array_for_all2 = caml_string_of_jsbytes("Array.for_all2"),
    cst_Array_map2_arrays_must_hav =
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
    cst_Array_iter2_arrays_must_ha =
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
    cst_Array_blit = caml_string_of_jsbytes("Array.blit"),
    cst_Array_fill = caml_string_of_jsbytes("Array.fill"),
    cst_Array_sub = caml_string_of_jsbytes("Array.sub"),
    cst_Array_init = caml_string_of_jsbytes("Array.init"),
    cst_Stdlib_Array_Bottom = caml_string_of_jsbytes("Stdlib.Array.Bottom"),
    cst_Float_Array_map2_arrays_mu =
      caml_string_of_jsbytes
        ("Float.Array.map2: arrays must have the same length"),
    cst_Float_Array_iter2_arrays_m =
      caml_string_of_jsbytes
        ("Float.Array.iter2: arrays must have the same length"),
    cst_Float_array_blit = caml_string_of_jsbytes("Float.array.blit"),
    cst_Float_array_blit$0 = caml_string_of_jsbytes("Float.array.blit"),
    cst_Float_Array_fill = caml_string_of_jsbytes("Float.Array.fill"),
    cst_Float_Array_sub = caml_string_of_jsbytes("Float.Array.sub"),
    cst_Float_Array_concat = caml_string_of_jsbytes("Float.Array.concat"),
    cst_Float_Array_init = caml_string_of_jsbytes("Float.Array.init"),
    cst_Stdlib_Float_Array_Bottom =
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
    cst_d = caml_string_of_jsbytes("%d"),
    cst_d$0 = caml_string_of_jsbytes("%d"),
    zero$2 = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one$2 = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one$2 = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int$2 = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int$2 = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    cst_d$1 = caml_string_of_jsbytes("%d"),
    cst_Lexing_lex_refill_cannot_g =
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
    dummy_pos = [0, caml_string_of_jsbytes(""), 0, 0, -1],
    zero_pos = [0, caml_string_of_jsbytes(""), 1, 0, 0],
    cst_syntax_error = caml_string_of_jsbytes("syntax error"),
    cst_Stdlib_Parsing_YYexit = caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
    cst_Stdlib_Parsing_Parse_error =
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
    cst_Set_remove_min_elt = caml_string_of_jsbytes("Set.remove_min_elt"),
    cst_Set_bal = caml_string_of_jsbytes("Set.bal"),
    cst_Set_bal$0 = caml_string_of_jsbytes("Set.bal"),
    cst_Set_bal$1 = caml_string_of_jsbytes("Set.bal"),
    cst_Set_bal$2 = caml_string_of_jsbytes("Set.bal"),
    cst_Map_remove_min_elt = caml_string_of_jsbytes("Map.remove_min_elt"),
    cst_Map_bal = caml_string_of_jsbytes("Map.bal"),
    cst_Map_bal$0 = caml_string_of_jsbytes("Map.bal"),
    cst_Map_bal$1 = caml_string_of_jsbytes("Map.bal"),
    cst_Map_bal$2 = caml_string_of_jsbytes("Map.bal"),
    cst_Stdlib_Stack_Empty = caml_string_of_jsbytes("Stdlib.Stack.Empty"),
    cst_Stdlib_Queue_Empty = caml_string_of_jsbytes("Stdlib.Queue.Empty"),
    cst_count = caml_string_of_jsbytes("{count = "),
    cst_data = caml_string_of_jsbytes("; data = "),
    cst$6 = caml_string_of_jsbytes("}"),
    cst_Sempty = caml_string_of_jsbytes("Sempty"),
    cst_Scons = caml_string_of_jsbytes("Scons ("),
    cst$7 = caml_string_of_jsbytes(", "),
    cst$8 = caml_string_of_jsbytes(")"),
    cst_Sapp = caml_string_of_jsbytes("Sapp ("),
    cst$9 = caml_string_of_jsbytes(", "),
    cst$10 = caml_string_of_jsbytes(")"),
    cst_Slazy = caml_string_of_jsbytes("Slazy"),
    cst_Sgen = caml_string_of_jsbytes("Sgen"),
    cst_Sbuffio = caml_string_of_jsbytes("Sbuffio"),
    cst_Stdlib_Stream_Failure = caml_string_of_jsbytes("Stdlib.Stream.Failure"),
    cst_Stdlib_Stream_Error = caml_string_of_jsbytes("Stdlib.Stream.Error"),
    cst_Buffer_truncate = caml_string_of_jsbytes("Buffer.truncate"),
    cst_Buffer_add_channel = caml_string_of_jsbytes("Buffer.add_channel"),
    cst_Buffer_add_substring_add_s =
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
    cst_Buffer_add_cannot_grow_buf =
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
    cst_Buffer_nth = caml_string_of_jsbytes("Buffer.nth"),
    cst_Buffer_blit = caml_string_of_jsbytes("Buffer.blit"),
    cst_Buffer_sub = caml_string_of_jsbytes("Buffer.sub"),
    cst_c = caml_string_of_jsbytes("%c"),
    cst_s = caml_string_of_jsbytes("%s"),
    cst_i = caml_string_of_jsbytes("%i"),
    cst_li = caml_string_of_jsbytes("%li"),
    cst_ni = caml_string_of_jsbytes("%ni"),
    cst_Li = caml_string_of_jsbytes("%Li"),
    cst_f = caml_string_of_jsbytes("%f"),
    cst_B = caml_string_of_jsbytes("%B"),
    cst$21 = caml_string_of_jsbytes("%{"),
    cst$22 = caml_string_of_jsbytes("%}"),
    cst$23 = caml_string_of_jsbytes("%("),
    cst$24 = caml_string_of_jsbytes("%)"),
    cst_a = caml_string_of_jsbytes("%a"),
    cst_t$0 = caml_string_of_jsbytes("%t"),
    cst$25 = caml_string_of_jsbytes("%?"),
    cst_r$0 = caml_string_of_jsbytes("%r"),
    cst_r$1 = caml_string_of_jsbytes("%_r"),
    cst_u$0 = caml_string_of_jsbytes("%u"),
    cst_Printf_bad_conversion =
      caml_string_of_jsbytes("Printf: bad conversion %["),
    cst_Printf_bad_conversion$0 =
      caml_string_of_jsbytes("Printf: bad conversion %_"),
    cst$30 = caml_string_of_jsbytes("@{"),
    cst$31 = caml_string_of_jsbytes("@["),
    cst$32 = caml_string_of_jsbytes("@{"),
    cst$33 = caml_string_of_jsbytes("@["),
    cst$34 = caml_string_of_jsbytes("@{"),
    cst$35 = caml_string_of_jsbytes("@["),
    cst_0 = caml_string_of_jsbytes("0"),
    cst_padding = caml_string_of_jsbytes("padding"),
    cst_precision = caml_string_of_jsbytes("precision"),
    cst$40 = caml_string_of_jsbytes("'*'"),
    cst$38 = caml_string_of_jsbytes("'-'"),
    cst_0$2 = caml_string_of_jsbytes("'0'"),
    cst$39 = caml_string_of_jsbytes("'*'"),
    cst_0$0 = caml_string_of_jsbytes("0"),
    cst_0$1 = caml_string_of_jsbytes("0"),
    cst_precision$0 = caml_string_of_jsbytes("precision"),
    cst_precision$1 = caml_string_of_jsbytes("precision"),
    cst$41 = caml_string_of_jsbytes("'+'"),
    cst$42 = caml_string_of_jsbytes("'#'"),
    cst$43 = caml_string_of_jsbytes("' '"),
    cst_padding$0 = caml_string_of_jsbytes("`padding'"),
    cst_precision$2 = caml_string_of_jsbytes("`precision'"),
    cst$44 = caml_string_of_jsbytes("'+'"),
    cst$45 = caml_string_of_jsbytes("'_'"),
    sub_format = [0, 0, caml_string_of_jsbytes("")],
    formatting_lit = [0, caml_string_of_jsbytes("@;"), 1, 0],
    cst_digit = caml_string_of_jsbytes("digit"),
    cst_character = caml_string_of_jsbytes("character ')'"),
    cst_character$0 = caml_string_of_jsbytes("character '}'"),
    cst$49 = caml_string_of_jsbytes("'#'"),
    cst$46 = caml_string_of_jsbytes("'+'"),
    cst$47 = caml_string_of_jsbytes("'+'"),
    cst$48 = caml_string_of_jsbytes("' '"),
    cst$50 = caml_string_of_jsbytes("'+'"),
    cst_non_zero_widths_are_unsupp =
      caml_string_of_jsbytes
        ("non-zero widths are unsupported for %c conversions"),
    cst_unexpected_end_of_format =
      caml_string_of_jsbytes("unexpected end of format"),
    cst$36 = caml_string_of_jsbytes(""),
    cst$37 = caml_string_of_jsbytes(""),
    cst_b$0 = caml_string_of_jsbytes("b"),
    cst_h = caml_string_of_jsbytes("h"),
    cst_hov = caml_string_of_jsbytes("hov"),
    cst_hv = caml_string_of_jsbytes("hv"),
    cst_v = caml_string_of_jsbytes("v"),
    cst_nan = caml_string_of_jsbytes("nan"),
    cst_neg_infinity = caml_string_of_jsbytes("neg_infinity"),
    cst_infinity = caml_string_of_jsbytes("infinity"),
    cst$29 = caml_string_of_jsbytes("."),
    cst_nd$0 = caml_string_of_jsbytes("%+nd"),
    cst_nd$1 = caml_string_of_jsbytes("% nd"),
    cst_ni$1 = caml_string_of_jsbytes("%+ni"),
    cst_ni$2 = caml_string_of_jsbytes("% ni"),
    cst_nx = caml_string_of_jsbytes("%nx"),
    cst_nx$0 = caml_string_of_jsbytes("%#nx"),
    cst_nX = caml_string_of_jsbytes("%nX"),
    cst_nX$0 = caml_string_of_jsbytes("%#nX"),
    cst_no = caml_string_of_jsbytes("%no"),
    cst_no$0 = caml_string_of_jsbytes("%#no"),
    cst_nd = caml_string_of_jsbytes("%nd"),
    cst_ni$0 = caml_string_of_jsbytes("%ni"),
    cst_nu = caml_string_of_jsbytes("%nu"),
    cst_ld$0 = caml_string_of_jsbytes("%+ld"),
    cst_ld$1 = caml_string_of_jsbytes("% ld"),
    cst_li$1 = caml_string_of_jsbytes("%+li"),
    cst_li$2 = caml_string_of_jsbytes("% li"),
    cst_lx = caml_string_of_jsbytes("%lx"),
    cst_lx$0 = caml_string_of_jsbytes("%#lx"),
    cst_lX = caml_string_of_jsbytes("%lX"),
    cst_lX$0 = caml_string_of_jsbytes("%#lX"),
    cst_lo = caml_string_of_jsbytes("%lo"),
    cst_lo$0 = caml_string_of_jsbytes("%#lo"),
    cst_ld = caml_string_of_jsbytes("%ld"),
    cst_li$0 = caml_string_of_jsbytes("%li"),
    cst_lu = caml_string_of_jsbytes("%lu"),
    cst_Ld$0 = caml_string_of_jsbytes("%+Ld"),
    cst_Ld$1 = caml_string_of_jsbytes("% Ld"),
    cst_Li$1 = caml_string_of_jsbytes("%+Li"),
    cst_Li$2 = caml_string_of_jsbytes("% Li"),
    cst_Lx = caml_string_of_jsbytes("%Lx"),
    cst_Lx$0 = caml_string_of_jsbytes("%#Lx"),
    cst_LX = caml_string_of_jsbytes("%LX"),
    cst_LX$0 = caml_string_of_jsbytes("%#LX"),
    cst_Lo = caml_string_of_jsbytes("%Lo"),
    cst_Lo$0 = caml_string_of_jsbytes("%#Lo"),
    cst_Ld = caml_string_of_jsbytes("%Ld"),
    cst_Li$0 = caml_string_of_jsbytes("%Li"),
    cst_Lu = caml_string_of_jsbytes("%Lu"),
    cst_d$3 = caml_string_of_jsbytes("%+d"),
    cst_d$4 = caml_string_of_jsbytes("% d"),
    cst_i$1 = caml_string_of_jsbytes("%+i"),
    cst_i$2 = caml_string_of_jsbytes("% i"),
    cst_x = caml_string_of_jsbytes("%x"),
    cst_x$0 = caml_string_of_jsbytes("%#x"),
    cst_X$0 = caml_string_of_jsbytes("%X"),
    cst_X$1 = caml_string_of_jsbytes("%#X"),
    cst_o = caml_string_of_jsbytes("%o"),
    cst_o$0 = caml_string_of_jsbytes("%#o"),
    cst_d$2 = caml_string_of_jsbytes("%d"),
    cst_i$0 = caml_string_of_jsbytes("%i"),
    cst_u = caml_string_of_jsbytes("%u"),
    cst$26 = caml_string_of_jsbytes("%!"),
    cst$27 = caml_string_of_jsbytes("@{"),
    cst$28 = caml_string_of_jsbytes("@["),
    cst_0c = caml_string_of_jsbytes("0c"),
    cst$20 = caml_string_of_jsbytes("%%"),
    cst$12 = caml_string_of_jsbytes("@]"),
    cst$13 = caml_string_of_jsbytes("@}"),
    cst$14 = caml_string_of_jsbytes("@?"),
    cst$15 = caml_string_of_jsbytes("@\n"),
    cst$16 = caml_string_of_jsbytes("@."),
    cst$17 = caml_string_of_jsbytes("@@"),
    cst$18 = caml_string_of_jsbytes("@%"),
    cst$19 = caml_string_of_jsbytes("@"),
    cst$11 = caml_string_of_jsbytes(".*"),
    cst_CamlinternalFormat_Type_mi =
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
    cst$58 = caml_string_of_jsbytes(""),
    cst$59 = caml_string_of_jsbytes("\n"),
    cst_a_boolean = caml_string_of_jsbytes("a boolean"),
    cst_an_integer = caml_string_of_jsbytes("an integer"),
    cst_an_integer$0 = caml_string_of_jsbytes("an integer"),
    cst_a_float = caml_string_of_jsbytes("a float"),
    cst_a_float$0 = caml_string_of_jsbytes("a float"),
    cst$55 = caml_string_of_jsbytes(""),
    cst$56 = caml_string_of_jsbytes(" "),
    cst$57 = caml_string_of_jsbytes(""),
    cst_one_of = caml_string_of_jsbytes("one of: "),
    cst_Arg_Expand_is_is_only_allo =
      caml_string_of_jsbytes
        ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
    cst_no_argument = caml_string_of_jsbytes("no argument"),
    cst$54 = caml_string_of_jsbytes("(?)"),
    cst_help$3 = caml_string_of_jsbytes("--help"),
    cst_help$4 = caml_string_of_jsbytes("-help"),
    cst_help$2 = caml_string_of_jsbytes("-help"),
    cst_Display_this_list_of_optio =
      caml_string_of_jsbytes(" Display this list of options"),
    cst_help = caml_string_of_jsbytes("-help"),
    cst_help$1 = caml_string_of_jsbytes("--help"),
    cst_Display_this_list_of_optio$0 =
      caml_string_of_jsbytes(" Display this list of options"),
    cst_help$0 = caml_string_of_jsbytes("--help"),
    cst$51 = caml_string_of_jsbytes("}"),
    cst$52 = caml_string_of_jsbytes("|"),
    cst$53 = caml_string_of_jsbytes("{"),
    cst_none = caml_string_of_jsbytes("<none>"),
    cst_Stdlib_Arg_Bad = caml_string_of_jsbytes("Stdlib.Arg.Bad"),
    cst_Stdlib_Arg_Help = caml_string_of_jsbytes("Stdlib.Arg.Help"),
    cst_Stdlib_Arg_Stop = caml_string_of_jsbytes("Stdlib.Arg.Stop"),
    cst$61 = caml_string_of_jsbytes(""),
    cst_Fatal_error_out_of_memory_ =
      caml_string_of_jsbytes
        ("Fatal error: out of memory in uncaught exception handler"),
    cst$65 = caml_string_of_jsbytes(""),
    cst_Program_not_linked_with_g_ =
      caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n"),
    cst_Raised_at = caml_string_of_jsbytes("Raised at"),
    cst_Re_raised_at = caml_string_of_jsbytes("Re-raised at"),
    cst_Raised_by_primitive_operat =
      caml_string_of_jsbytes("Raised by primitive operation at"),
    cst_Called_from = caml_string_of_jsbytes("Called from"),
    cst_inlined = caml_string_of_jsbytes(" (inlined)"),
    cst$64 = caml_string_of_jsbytes(""),
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst_Out_of_memory = caml_string_of_jsbytes("Out of memory"),
    cst_Stack_overflow = caml_string_of_jsbytes("Stack overflow"),
    cst_Pattern_matching_failed =
      caml_string_of_jsbytes("Pattern matching failed"),
    cst_Assertion_failed = caml_string_of_jsbytes("Assertion failed"),
    cst_Undefined_recursive_module =
      caml_string_of_jsbytes("Undefined recursive module"),
    cst$62 = caml_string_of_jsbytes(""),
    cst$63 = caml_string_of_jsbytes(""),
    cst$60 = caml_string_of_jsbytes("_"),
    locfmt =
      [0,
        [11,
          caml_string_of_jsbytes('File "'),
          [2,
            0,
            [11,
              caml_string_of_jsbytes('", line '),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(", characters "),
                  [4,
                    0,
                    0,
                    0,
                    [12, 45, [4, 0, 0, 0, [11, caml_string_of_jsbytes(": "), [2, 0, 0]]]]]]]]]],
        caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
    cst_Fun_Finally_raised = caml_string_of_jsbytes("Fun.Finally_raised: "),
    cst_Stdlib_Fun_Finally_raised =
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
    cst_Digest_from_hex$0 = caml_string_of_jsbytes("Digest.from_hex"),
    cst_Digest_from_hex = caml_string_of_jsbytes("Digest.from_hex"),
    cst_Digest_to_hex = caml_string_of_jsbytes("Digest.to_hex"),
    cst_Digest_substring = caml_string_of_jsbytes("Digest.substring"),
    cst_Random_int64 = caml_string_of_jsbytes("Random.int64"),
    cst_Random_int32 = caml_string_of_jsbytes("Random.int32"),
    cst_Random_full_int = caml_string_of_jsbytes("Random.full_int"),
    cst_Random_int = caml_string_of_jsbytes("Random.int"),
    cst_x$1 = caml_string_of_jsbytes("x"),
    cst_Hashtbl_unsupported_hash_t =
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
    cst_OCAMLRUNPARAM = caml_string_of_jsbytes("OCAMLRUNPARAM"),
    cst_CAMLRUNPARAM = caml_string_of_jsbytes("CAMLRUNPARAM"),
    cst$66 = caml_string_of_jsbytes(""),
    cst_Weak_Make_hash_bucket_cann =
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
    cst_Weak_fill = caml_string_of_jsbytes("Weak.fill"),
    cst_Weak_blit = caml_string_of_jsbytes("Weak.blit"),
    cst_Weak_check = caml_string_of_jsbytes("Weak.check"),
    cst_Weak_get_copy = caml_string_of_jsbytes("Weak.get_copy"),
    cst_Weak_get = caml_string_of_jsbytes("Weak.get"),
    cst_Weak_set = caml_string_of_jsbytes("Weak.set"),
    cst_Weak_create = caml_string_of_jsbytes("Weak.create"),
    cst$84 = caml_string_of_jsbytes(""),
    cst$85 = caml_string_of_jsbytes(""),
    cst$83 = caml_string_of_jsbytes("."),
    cst$80 = caml_string_of_jsbytes(">"),
    cst$81 = caml_string_of_jsbytes("<\/"),
    cst$82 = caml_string_of_jsbytes(""),
    cst$77 = caml_string_of_jsbytes(">"),
    cst$78 = caml_string_of_jsbytes("<"),
    cst$79 = caml_string_of_jsbytes(""),
    cst$76 = caml_string_of_jsbytes("\n"),
    cst_Format_pp_set_geometry =
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
    cst$72 = caml_string_of_jsbytes(""),
    cst$73 = caml_string_of_jsbytes(""),
    cst$74 = caml_string_of_jsbytes(""),
    cst$75 = caml_string_of_jsbytes(""),
    cst$68 = caml_string_of_jsbytes(""),
    cst$69 = caml_string_of_jsbytes(""),
    cst$70 = caml_string_of_jsbytes(""),
    cst$71 = caml_string_of_jsbytes(""),
    cst$67 = caml_string_of_jsbytes(""),
    cst_Stdlib_Format_String_tag =
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
    cst_end_of_input_not_found =
      caml_string_of_jsbytes("end of input not found"),
    cst_scanf_bad_conversion_a =
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
    cst_scanf_bad_conversion_t =
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
    cst_scanf_missing_reader = caml_string_of_jsbytes("scanf: missing reader"),
    cst_scanf_bad_conversion_custo =
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
    cst_scanf_bad_conversion =
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
    cst_scanf_bad_conversion$0 =
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
    cst_scanf_bad_conversion$1 =
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
    cst_scanf_bad_conversion$2 =
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
    cst$91 = caml_string_of_jsbytes('"'),
    cst$92 = caml_string_of_jsbytes('"'),
    cst$89 = caml_string_of_jsbytes('"'),
    cst$90 = caml_string_of_jsbytes('"'),
    cst$88 = caml_string_of_jsbytes('"'),
    cst_in_format = caml_string_of_jsbytes(' in format "'),
    cst_an = caml_string_of_jsbytes("an"),
    cst_x$2 = caml_string_of_jsbytes("x"),
    cst_nfinity = caml_string_of_jsbytes("nfinity"),
    cst_digits = caml_string_of_jsbytes("digits"),
    cst_decimal_digits = caml_string_of_jsbytes("decimal digits"),
    cst_0b = caml_string_of_jsbytes("0b"),
    cst_0o = caml_string_of_jsbytes("0o"),
    cst_0u = caml_string_of_jsbytes("0u"),
    cst_0x = caml_string_of_jsbytes("0x"),
    cst_false$3 = caml_string_of_jsbytes("false"),
    cst_true$3 = caml_string_of_jsbytes("true"),
    cst_not_a_valid_float_in_hexad =
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
    cst_no_dot_or_exponent_part_fo =
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
    cst$87 = caml_string_of_jsbytes("-"),
    cst_unnamed_function = caml_string_of_jsbytes("unnamed function"),
    cst_unnamed_character_string =
      caml_string_of_jsbytes("unnamed character string"),
    cst_unnamed_Stdlib_input_chann =
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
    cst$86 = caml_string_of_jsbytes("-"),
    cst_Stdlib_Scanf_Scan_failure =
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
    cst_binary = caml_string_of_jsbytes("binary"),
    cst_octal = caml_string_of_jsbytes("octal"),
    cst_hexadecimal = caml_string_of_jsbytes("hexadecimal"),
    cst_a_Char = caml_string_of_jsbytes("a Char"),
    cst_a_String = caml_string_of_jsbytes("a String"),
    cst$93 = caml_string_of_jsbytes(""),
    cst_CamlinternalMod_update_mod =
      caml_string_of_jsbytes("CamlinternalMod.update_mod: not a module"),
    cst_CamlinternalMod_init_mod_n =
      caml_string_of_jsbytes("CamlinternalMod.init_mod: not a module"),
    cst$94 = caml_string_of_jsbytes(""),
    cst$95 = caml_string_of_jsbytes(""),
    cst$96 = caml_string_of_jsbytes(""),
    cst$97 = caml_string_of_jsbytes(""),
    cst$99 = caml_string_of_jsbytes(""),
    cst$98 = caml_string_of_jsbytes(""),
    cst_Illegal_character = caml_string_of_jsbytes("Illegal character "),
    cst_Filename_chop_extension =
      caml_string_of_jsbytes("Filename.chop_extension"),
    cst$127 = caml_string_of_jsbytes(""),
    cst_Filename_chop_suffix = caml_string_of_jsbytes("Filename.chop_suffix"),
    cst$126 = caml_string_of_jsbytes(""),
    cst_2_1$0 = caml_string_of_jsbytes(" 2>&1"),
    cst_2$0 = caml_string_of_jsbytes(" 2>"),
    cst$125 = caml_string_of_jsbytes(""),
    cst$117 = caml_string_of_jsbytes(" >"),
    cst$124 = caml_string_of_jsbytes(""),
    cst$118 = caml_string_of_jsbytes(" <"),
    cst$123 = caml_string_of_jsbytes(""),
    cst$119 = caml_string_of_jsbytes(" "),
    cst$120 = caml_string_of_jsbytes(" "),
    cst$121 = caml_string_of_jsbytes('"'),
    cst$122 = caml_string_of_jsbytes(""),
    cst_Filename_quote_command_bad =
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
    cst$115 = caml_string_of_jsbytes('"'),
    cst$116 = caml_string_of_jsbytes('"'),
    cst$113 = caml_string_of_jsbytes("./"),
    cst$112 = caml_string_of_jsbytes(".\\"),
    cst$111 = caml_string_of_jsbytes("../"),
    cst$110 = caml_string_of_jsbytes("..\\"),
    cst_2_1 = caml_string_of_jsbytes(" 2>&1"),
    cst_2 = caml_string_of_jsbytes(" 2>"),
    cst$109 = caml_string_of_jsbytes(""),
    cst$104 = caml_string_of_jsbytes(" >"),
    cst$108 = caml_string_of_jsbytes(""),
    cst$105 = caml_string_of_jsbytes(" <"),
    cst$107 = caml_string_of_jsbytes(""),
    cst$106 = caml_string_of_jsbytes(" "),
    cst$103 = caml_string_of_jsbytes("./"),
    cst$102 = caml_string_of_jsbytes("../"),
    cst$101 = caml_string_of_jsbytes(""),
    cst$100 = caml_string_of_jsbytes(""),
    null$0 = caml_string_of_jsbytes("/dev/null"),
    current_dir_name = caml_string_of_jsbytes("."),
    parent_dir_name = caml_string_of_jsbytes(".."),
    dir_sep = caml_string_of_jsbytes("/"),
    cst_TMPDIR = caml_string_of_jsbytes("TMPDIR"),
    cst_tmp = caml_string_of_jsbytes("/tmp"),
    quotequote = caml_string_of_jsbytes("'\\''"),
    null$1 = caml_string_of_jsbytes("NUL"),
    current_dir_name$0 = caml_string_of_jsbytes("."),
    parent_dir_name$0 = caml_string_of_jsbytes(".."),
    dir_sep$0 = caml_string_of_jsbytes("\\"),
    cst_TEMP = caml_string_of_jsbytes("TEMP"),
    cst$114 = caml_string_of_jsbytes("."),
    null$2 = caml_string_of_jsbytes("/dev/null"),
    current_dir_name$1 = caml_string_of_jsbytes("."),
    parent_dir_name$1 = caml_string_of_jsbytes(".."),
    dir_sep$1 = caml_string_of_jsbytes("/"),
    cst_Cygwin = caml_string_of_jsbytes("Cygwin"),
    cst_Win32 = caml_string_of_jsbytes("Win32"),
    zero$4 = [254, 0., 0.],
    one$4 = [254, 1., 0.],
    i = [254, 0., 1.],
    cst_Bigarray_array3_of_genarra =
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
    cst_Bigarray_array2_of_genarra =
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
    cst_Bigarray_array1_of_genarra =
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
    cst_Bigarray_array0_of_genarra =
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
    cst_Bigarray_Array3_of_array_n =
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
    cst_Bigarray_Array3_of_array_n$0 =
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
    cst_Bigarray_Array2_of_array_n =
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
    cst_In_channel_input_all_chann =
      caml_string_of_jsbytes
        ("In_channel.input_all: channel content is larger than maximum string length"),
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module,
    _l_ = [0, 0, [0, 6, 0]],
    _k_ = [0, 0, [0, 7, 0]],
    _j_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    _i_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _g_ = [0, 1],
    _h_ = [0, 0],
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 32752),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 65520),
    _c_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 32752),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 16),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 15536),
    _n_ = [0, caml_string_of_jsbytes("obj.ml"), 95, 4],
    _p_ = [0, caml_string_of_jsbytes("seq.ml"), 596, 4],
    _v_ = [0, caml_string_of_jsbytes("uchar.ml"), 88, 18],
    _u_ = [0, caml_string_of_jsbytes("uchar.ml"), 91, 7],
    _t_ = [0, caml_string_of_jsbytes("uchar.ml"), 80, 18],
    _s_ = [0, caml_string_of_jsbytes("uchar.ml"), 85, 7],
    _y_ = [0, 0, 0],
    _E_ = [0, caml_string_of_jsbytes("bytes.ml"), 808, 20],
    _D_ = [0, caml_string_of_jsbytes("bytes.ml"), 819, 9],
    _C_ = [0, caml_string_of_jsbytes("bytes.ml"), 754, 20],
    _B_ = [0, caml_string_of_jsbytes("bytes.ml"), 765, 9],
    _A_ = [0, caml_string_of_jsbytes("bytes.ml"), 642, 20],
    _z_ = [0, caml_string_of_jsbytes("bytes.ml"), 667, 9],
    _F_ = [0, caml_string_of_jsbytes("array.ml"), 322, 4],
    _H_ = [0, caml_string_of_jsbytes("float.ml"), 395, 6],
    _G_ = [0, caml_string_of_jsbytes("float.ml"), 222, 14],
    _S_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _R_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _Q_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _P_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _T_ = [0, 0, 0, 0],
    _U_ = [0, 0, 0],
    _V_ = [0, caml_string_of_jsbytes("set.ml"), 570, 18],
    _W_ = [0, 0, 0, 0],
    _X_ = [0, caml_string_of_jsbytes("map.ml"), 400, 10],
    _Y_ = [0, 0, 0],
    _Z_ = [0, caml_string_of_jsbytes("stream.ml"), 53, 12],
    ___ = [0, 0],
    _$_ = [0, caml_string_of_jsbytes("stream.ml"), 82, 12],
    _ad_ = [0, caml_string_of_jsbytes("buffer.ml"), 231, 9],
    _ac_ = [0, caml_string_of_jsbytes("buffer.ml"), 212, 2],
    _ab_ = [0, caml_string_of_jsbytes("buffer.ml"), 93, 2],
    _aa_ = [0, caml_string_of_jsbytes("buffer.ml"), 94, 2],
    _af_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 850, 23],
    _aq_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 814, 21],
    _ai_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 815, 21],
    _ar_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 818, 21],
    _aj_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 819, 21],
    _as_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 822, 19],
    _ak_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 823, 19],
    _at_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 826, 22],
    _al_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 827, 22],
    _au_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 831, 30],
    _am_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 832, 30],
    _ao_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 836, 26],
    _ag_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 837, 26],
    _ap_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 846, 28],
    _ah_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 847, 28],
    _an_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 851, 23],
    _aw_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 1558, 4],
    _ax_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 1626, 39],
    _ay_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 1649, 31],
    _az_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 1650, 31],
    _aA_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 1830, 8],
    _a4_ =
      [0,
        [11,
          caml_string_of_jsbytes("bad input: format type mismatch between "),
          [3, 0, [11, caml_string_of_jsbytes(" and "), [3, 0, 0]]]],
        caml_string_of_jsbytes
          ("bad input: format type mismatch between %S and %S")],
    _a3_ =
      [0,
        [11,
          caml_string_of_jsbytes("bad input: format type mismatch between "),
          [3, 0, [11, caml_string_of_jsbytes(" and "), [3, 0, 0]]]],
        caml_string_of_jsbytes
          ("bad input: format type mismatch between %S and %S")],
    _aG_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4, 0, 0, 0, [11, caml_string_of_jsbytes(", duplicate flag "), [1, 0]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: at character number %d, duplicate flag %C")],
    _aH_ = [0, 1, 0],
    _aI_ = [0, 0],
    _aJ_ = [1, 0],
    _aK_ = [1, 1],
    _aM_ = [1, 1],
    _aL_ = [1, 1],
    _aQ_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(", flag "),
                  [1,
                    [11,
                      caml_string_of_jsbytes(" is only allowed after the '"),
                      [12,
                        37,
                        [11,
                          caml_string_of_jsbytes("', before padding and precision"),
                          0]]]]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
    _aN_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(', invalid conversion "'),
                  [12, 37, [0, [12, 34, 0]]]]]]]],
        caml_string_of_jsbytes
          ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
    _aO_ = [0, 0],
    _aP_ = [0, 0],
    _aR_ = [0, [12, 64, 0]],
    _aS_ = [0, caml_string_of_jsbytes("@ "), 1, 0],
    _aT_ = [0, caml_string_of_jsbytes("@,"), 0, 0],
    _aU_ = [2, 60],
    _aV_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": '"),
              [12,
                37,
                [11,
                  caml_string_of_jsbytes
                    ("' alone is not accepted in character sets, use "),
                  [12,
                    37,
                    [12,
                      37,
                      [11,
                        caml_string_of_jsbytes(" instead at position "),
                        [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
    _aW_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": integer "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(" is greater than the limit "),
                  [4, 0, 0, 0, 0]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: integer %d is greater than the limit %d")],
    _aX_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 2837, 11],
    _aY_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(': unclosed sub-format, expected "'),
              [12,
                37,
                [0,
                  [11, caml_string_of_jsbytes('" at character number '), [4, 0, 0, 0, 0]]]]]]],
        caml_string_of_jsbytes
          ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
    _aZ_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 2899, 34],
    _a0_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 2935, 28],
    _a1_ = [0, caml_string_of_jsbytes("camlinternalFormat.ml"), 2957, 11],
    _a2_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(", "),
                  [2,
                    0,
                    [11,
                      caml_string_of_jsbytes(" is incompatible with '"),
                      [0, [11, caml_string_of_jsbytes("' in sub-format "), [3, 0, 0]]]]]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
    _aF_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(", "),
                  [2, 0, [11, caml_string_of_jsbytes(" expected, read "), [1, 0]]]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: at character number %d, %s expected, read %C")],
    _aE_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4,
                0,
                0,
                0,
                [11,
                  caml_string_of_jsbytes(", '"),
                  [0, [11, caml_string_of_jsbytes("' without "), [2, 0, 0]]]]]]]],
        caml_string_of_jsbytes
          ("invalid format %S: at character number %d, '%c' without %s")],
    _aD_ =
      [0,
        [11,
          caml_string_of_jsbytes("invalid format "),
          [3,
            0,
            [11,
              caml_string_of_jsbytes(": at character number "),
              [4, 0, 0, 0, [11, caml_string_of_jsbytes(", "), [2, 0, 0]]]]]],
        caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
    _aC_ =
      [0,
        [11, caml_string_of_jsbytes("invalid box description "), [3, 0, 0]],
        caml_string_of_jsbytes("invalid box description %S")],
    _aB_ = [0, 0, 4],
    _av_ = [0, 103],
    _ae_ = [0, 0, 0],
    _bo_ = [0, [2, 0, [0, 0]], caml_string_of_jsbytes("%s%c")],
    _bi_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _bj_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _bg_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _bh_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _be_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _bf_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _a__ =
      [0,
        [2,
          0,
          [11,
            caml_string_of_jsbytes(": unknown option '"),
            [2, 0, [11, caml_string_of_jsbytes("'.\n"), 0]]]],
        caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
    _bb_ =
      [0,
        [2,
          0,
          [11,
            caml_string_of_jsbytes(": wrong argument '"),
            [2,
              0,
              [11,
                caml_string_of_jsbytes("'; option '"),
                [2,
                  0,
                  [11,
                    caml_string_of_jsbytes("' expects "),
                    [2, 0, [11, caml_string_of_jsbytes(".\n"), 0]]]]]]]],
        caml_string_of_jsbytes
          ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
    _bc_ =
      [0,
        [2,
          0,
          [11,
            caml_string_of_jsbytes(": option '"),
            [2, 0, [11, caml_string_of_jsbytes("' needs an argument.\n"), 0]]]],
        caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
    _bd_ =
      [0,
        [2,
          0,
          [11,
            caml_string_of_jsbytes(": "),
            [2, 0, [11, caml_string_of_jsbytes(".\n"), 0]]]],
        caml_string_of_jsbytes("%s: %s.\n")],
    _a$_ = [0, caml_string_of_jsbytes("-help")],
    _ba_ = [0, caml_string_of_jsbytes("--help")],
    _a9_ = [0, [2, 0, 0], caml_string_of_jsbytes("%s")],
    _a8_ = [0, [2, 0, [12, 10, 0]], caml_string_of_jsbytes("%s\n")],
    _a7_ = [0, caml_string_of_jsbytes("-help")],
    _a5_ =
      [0,
        [11, caml_string_of_jsbytes("  "), [2, 0, [12, 32, [2, 0, [12, 10, 0]]]]],
        caml_string_of_jsbytes("  %s %s\n")],
    _a6_ =
      [0,
        [11, caml_string_of_jsbytes("  "), [2, 0, [12, 32, [2, 0, [2, 0, [12, 10, 0]]]]]],
        caml_string_of_jsbytes("  %s %s%s\n")],
    _bt_ =
      [0,
        [11, caml_string_of_jsbytes(", "), [2, 0, [2, 0, 0]]],
        caml_string_of_jsbytes(", %s%s")],
    _bF_ =
      [0,
        [11, caml_string_of_jsbytes("Fatal error: exception "), [2, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("Fatal error: exception %s\n")],
    _bG_ =
      [0,
        [11,
          caml_string_of_jsbytes
            ("Fatal error in uncaught exception handler: exception "),
          [2, 0, [12, 10, 0]]],
        caml_string_of_jsbytes
          ("Fatal error in uncaught exception handler: exception %s\n")],
    _bE_ =
      [0,
        [11, caml_string_of_jsbytes("Fatal error: exception "), [2, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("Fatal error: exception %s\n")],
    _bC_ = [0, [2, 0, [12, 10, 0]], caml_string_of_jsbytes("%s\n")],
    _bA_ = [0, [2, 0, [12, 10, 0]], caml_string_of_jsbytes("%s\n")],
    _bB_ =
      [0,
        [11,
          caml_string_of_jsbytes
            ("(Program not linked with -g, cannot print stack backtrace)\n"),
          0],
        caml_string_of_jsbytes
          ("(Program not linked with -g, cannot print stack backtrace)\n")],
    _by_ =
      [0,
        [2,
          0,
          [12,
            32,
            [2,
              0,
              [11,
                caml_string_of_jsbytes(' in file "'),
                [2,
                  0,
                  [12,
                    34,
                    [2,
                      0,
                      [11,
                        caml_string_of_jsbytes(", line "),
                        [4, 0, 0, 0, [11, caml_string_of_jsbytes(", characters "), partial]]]]]]]]]],
        caml_string_of_jsbytes
          ('%s %s in file "%s"%s, line %d, characters %d-%d')],
    _bz_ =
      [0,
        [2, 0, [11, caml_string_of_jsbytes(" unknown location"), 0]],
        caml_string_of_jsbytes("%s unknown location")],
    _bx_ =
      [0,
        [11, caml_string_of_jsbytes("Uncaught exception: "), [2, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("Uncaught exception: %s\n")],
    _bw_ =
      [0,
        [11, caml_string_of_jsbytes("Uncaught exception: "), [2, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("Uncaught exception: %s\n")],
    _bu_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], caml_string_of_jsbytes("(%s%s)")],
    _bv_ = [0, [12, 40, [2, 0, [12, 41, 0]]], caml_string_of_jsbytes("(%s)")],
    _bs_ = [0, [4, 0, 0, 0, 0], caml_string_of_jsbytes("%d")],
    _br_ = [0, [3, 0, 0], caml_string_of_jsbytes("%S")],
    _bD_ =
      [0,
        caml_string_of_jsbytes(""),
        caml_string_of_jsbytes
          ("(Cannot print locations:\n bytecode executable program file not found)"),
        caml_string_of_jsbytes
          ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
        caml_string_of_jsbytes
          ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
        caml_string_of_jsbytes
          ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
    _bN_ =
      [0,
        [11,
          caml_string_of_jsbytes("minor_collections:      "),
          [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("minor_collections:      %d\n")],
    _bO_ =
      [0,
        [11,
          caml_string_of_jsbytes("major_collections:      "),
          [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("major_collections:      %d\n")],
    _bP_ =
      [0,
        [11,
          caml_string_of_jsbytes("compactions:            "),
          [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("compactions:            %d\n")],
    _bQ_ =
      [0,
        [11,
          caml_string_of_jsbytes("forced_major_collections: "),
          [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("forced_major_collections: %d\n")],
    _bR_ = [0, [12, 10, 0], caml_string_of_jsbytes("\n")],
    _bS_ = [0, [8, [0, 0, 0], 0, [0, 0], 0], caml_string_of_jsbytes("%.0f")],
    _bT_ =
      [0,
        [11,
          caml_string_of_jsbytes("minor_words:    "),
          [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
        caml_string_of_jsbytes("minor_words:    %*.0f\n")],
    _bU_ =
      [0,
        [11,
          caml_string_of_jsbytes("promoted_words: "),
          [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
        caml_string_of_jsbytes("promoted_words: %*.0f\n")],
    _bV_ =
      [0,
        [11,
          caml_string_of_jsbytes("major_words:    "),
          [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
        caml_string_of_jsbytes("major_words:    %*.0f\n")],
    _bW_ = [0, [12, 10, 0], caml_string_of_jsbytes("\n")],
    _bX_ = [0, [4, 0, 0, 0, 0], caml_string_of_jsbytes("%d")],
    _bY_ =
      [0,
        [11, caml_string_of_jsbytes("top_heap_words: "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("top_heap_words: %*d\n")],
    _bZ_ =
      [0,
        [11, caml_string_of_jsbytes("heap_words:     "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("heap_words:     %*d\n")],
    _b0_ =
      [0,
        [11, caml_string_of_jsbytes("live_words:     "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("live_words:     %*d\n")],
    _b1_ =
      [0,
        [11, caml_string_of_jsbytes("free_words:     "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("free_words:     %*d\n")],
    _b2_ =
      [0,
        [11, caml_string_of_jsbytes("largest_free:   "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("largest_free:   %*d\n")],
    _b3_ =
      [0,
        [11, caml_string_of_jsbytes("fragments:      "), [4, 0, [1, 1], 0, [12, 10, 0]]],
        caml_string_of_jsbytes("fragments:      %*d\n")],
    _b4_ = [0, [12, 10, 0], caml_string_of_jsbytes("\n")],
    _b5_ =
      [0,
        [11, caml_string_of_jsbytes("live_blocks: "), [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("live_blocks: %d\n")],
    _b6_ =
      [0,
        [11, caml_string_of_jsbytes("free_blocks: "), [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("free_blocks: %d\n")],
    _b7_ =
      [0,
        [11, caml_string_of_jsbytes("heap_chunks: "), [4, 0, 0, 0, [12, 10, 0]]],
        caml_string_of_jsbytes("heap_chunks: %d\n")],
    _cd_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _ce_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _cf_ =
      [0,
        987910699,
        495797812,
        364182224,
        414272206,
        318284740,
        990407751,
        383018966,
        270373319,
        840823159,
        24560019,
        536292337,
        512266505,
        189156120,
        730249596,
        143776328,
        51606627,
        140166561,
        366354223,
        1003410265,
        700563762,
        981890670,
        913149062,
        526082594,
        1021425055,
        784300257,
        667753350,
        630144451,
        949649812,
        48546892,
        415514493,
        258888527,
        511570777,
        89983870,
        283659902,
        308386020,
        242688715,
        482270760,
        865188196,
        1027664170,
        207196989,
        193777847,
        619708188,
        671350186,
        149669678,
        257044018,
        87658204,
        558145612,
        183450813,
        28133145,
        901332182,
        710253903,
        510646120,
        652377910,
        409934019,
        801085050],
    _ci_ = [0, 0],
    _co_ = [3, 0, 3],
    _cn_ = [1, caml_string_of_jsbytes("max_indent < 2")],
    _cl_ = [1, caml_string_of_jsbytes("margin <= max_indent")],
    _cm_ = [0, 0],
    _ck_ = [0, caml_string_of_jsbytes("")],
    _cj_ = [0, caml_string_of_jsbytes(""), 0, caml_string_of_jsbytes("")],
    _cE_ = [0, 91],
    _cD_ = [0, 123],
    _cF_ = [0, caml_string_of_jsbytes("scanf.ml"), 1453, 13],
    _cG_ = [0, [3, 0, [10, 0]], caml_string_of_jsbytes("%S%!")],
    _cC_ = [0, 37, caml_string_of_jsbytes("")],
    _cB_ =
      [0,
        [11,
          caml_string_of_jsbytes("scanf: bad input at char number "),
          [4, 3, 0, 0, [11, caml_string_of_jsbytes(": "), [2, 0, 0]]]],
        caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
    _cA_ =
      [0,
        [11,
          caml_string_of_jsbytes("the character "),
          [1, [11, caml_string_of_jsbytes(" cannot start a boolean"), 0]]],
        caml_string_of_jsbytes("the character %C cannot start a boolean")],
    _cz_ =
      [0,
        [11,
          caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
          [0, [0, 0]]],
        caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
    _cy_ =
      [0,
        [11,
          caml_string_of_jsbytes("bad character decimal encoding \\"),
          [0, [0, [0, 0]]]],
        caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
    _cx_ =
      [0,
        [11,
          caml_string_of_jsbytes("character "),
          [1,
            [11,
              caml_string_of_jsbytes(" is not a valid "),
              [2, 0, [11, caml_string_of_jsbytes(" digit"), 0]]]]],
        caml_string_of_jsbytes("character %C is not a valid %s digit")],
    _cw_ =
      [0,
        [11,
          caml_string_of_jsbytes("character "),
          [1, [11, caml_string_of_jsbytes(" is not a decimal digit"), 0]]],
        caml_string_of_jsbytes("character %C is not a decimal digit")],
    _cv_ = [0, caml_string_of_jsbytes("scanf.ml"), 555, 9],
    _cu_ =
      [0,
        [11, caml_string_of_jsbytes("invalid boolean '"), [2, 0, [12, 39, 0]]],
        caml_string_of_jsbytes("invalid boolean '%s'")],
    _ct_ =
      [0,
        [11,
          caml_string_of_jsbytes("looking for "),
          [1, [11, caml_string_of_jsbytes(", found "), [1, 0]]]],
        caml_string_of_jsbytes("looking for %C, found %C")],
    _cs_ =
      [0,
        [11,
          caml_string_of_jsbytes("scanning of "),
          [2,
            0,
            [11,
              caml_string_of_jsbytes
                (" failed: premature end of file occurred before end of token"),
              0]]],
        caml_string_of_jsbytes
          ("scanning of %s failed: premature end of file occurred before end of token")],
    _cr_ =
      [0,
        [11,
          caml_string_of_jsbytes("scanning of "),
          [2,
            0,
            [11,
              caml_string_of_jsbytes
                (" failed: the specified length was too short for token"),
              0]]],
        caml_string_of_jsbytes
          ("scanning of %s failed: the specified length was too short for token")],
    _cq_ =
      [0,
        [11, caml_string_of_jsbytes("illegal escape character "), [1, 0]],
        caml_string_of_jsbytes("illegal escape character %C")],
    _cN_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 439, 17],
    _cM_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 421, 13],
    _cL_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 418, 13],
    _cK_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 415, 13],
    _cJ_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 412, 13],
    _cI_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 409, 13],
    _cH_ = [0, caml_string_of_jsbytes("camlinternalOO.ml"), 281, 50],
    _cO_ = [0, caml_string_of_jsbytes("camlinternalMod.ml"), 72, 5],
    _cP_ = [0, caml_string_of_jsbytes("camlinternalMod.ml"), 81, 2],
    _cS_ = [0, 0],
    _cR_ = [0, 0],
    _cQ_ = [0, 0],
    _cX_ = [0, 7, 0],
    _cW_ = [0, 1, [0, 3, [0, 5, 0]]],
    _cV_ = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], caml_string_of_jsbytes("%s%06x%s")],
    _cU_ = [0, caml_string_of_jsbytes('"'), 0],
    _cY_ = [254, 0., 0.],
    _cZ_ = [0, 0];
  function erase_rel(param) {
    if (typeof param === "number") return 0;
    switch (param[0]) {
      case 0: var rest = param[1]; return [0, erase_rel(rest)];
      case 1: var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2: var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3: var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4: var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5: var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6: var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7: var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
        var rest$7 = param[2], ty = param[1]; return [8, ty, erase_rel(rest$7)];
      case 9:
        var rest$8 = param[3], ty1 = param[1];
        return [9, ty1, ty1, erase_rel(rest$8)];
      case 10: var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11: var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12: var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13: var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)]
    }
  }
  function concat_fmtty(fmtty1, fmtty2) {
    if (typeof fmtty1 === "number") return fmtty2;
    switch (fmtty1[0]) {
      case 0: var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1: var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2: var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3: var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4: var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5: var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6: var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7: var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
        var rest$7 = fmtty1[2], ty = fmtty1[1];
        return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
        var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
        return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10: var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
        var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
        var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
        var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default: var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)]
    }
  }
  function concat_fmt(fmt1, fmt2) {
    if (typeof fmt1 === "number") return fmt2;
    switch (fmt1[0]) {
      case 0: var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1: var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
        var rest$1 = fmt1[2], pad = fmt1[1];
        return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
        var rest$2 = fmt1[2], pad$0 = fmt1[1];
        return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
        var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
        return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
        var rest$4 = fmt1[4], prec$0 = fmt1[3], pad$2 = fmt1[2], iconv$0 = fmt1[1];
        return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
        var rest$5 = fmt1[4], prec$1 = fmt1[3], pad$3 = fmt1[2], iconv$1 = fmt1[1];
        return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
        var rest$6 = fmt1[4], prec$2 = fmt1[3], pad$4 = fmt1[2], iconv$2 = fmt1[1];
        return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
        var rest$7 = fmt1[4], prec$3 = fmt1[3], pad$5 = fmt1[2], fconv = fmt1[1];
        return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
        var rest$8 = fmt1[2], pad$6 = fmt1[1];
        return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10: var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
        var rest$10 = fmt1[2], str = fmt1[1];
        return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
        var rest$11 = fmt1[2], chr = fmt1[1];
        return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
        var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
        return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
        var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
        return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15: var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16: var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
        var rest$16 = fmt1[2], fmting_lit = fmt1[1];
        return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
        var rest$17 = fmt1[2], fmting_gen = fmt1[1];
        return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19: var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
        var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
        return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
        var rest$20 = fmt1[2], counter = fmt1[1];
        return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22: var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
        var rest$22 = fmt1[2], ign = fmt1[1];
        return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
        var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
        return [24, arity, f, concat_fmt(rest$23, fmt2)]
    }
  }
  var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
  caml_register_global
    (761, CamlinternalFormatBasics, "CamlinternalFormatBasics");
  function make(v) { return [0, v] }
  function get(r) { return r[1] }
  function set(r, v) { r[1] = v; return 0 }
  function exchange(r, v) { var cur = r[1]; r[1] = v; return cur }
  function compare_and_set(r, seen, v) { var cur = r[1]; return cur === seen ? (r[1] = v, 1) : 0 }
  function fetch_and_add(r, n) { var cur = r[1]; r[1] = cur + n | 0; return cur }
  function incr(r) { fetch_and_add(r, 1); return 0 }
  function decr(r) { fetch_and_add(r, -1); return 0 }
  var
    include =
      [0, make, get, set, exchange, compare_and_set, fetch_and_add, incr, decr];
  caml_register_global(762, include, "CamlinternalAtomic");
  function failwith(s) { throw [0, Failure, s] }
  function invalid_arg(s) { throw [0, Invalid_argument, s] }
  var Exit = [248, cst_Stdlib_Exit, caml_fresh_oo_id(0)];
  function min(x, y) { return caml_lessequal(x, y) ? x : y }
  function max(x, y) { return caml_greaterequal(x, y) ? x : y }
  function abs(x) { return 0 <= x ? x : - x | 0 }
  function lnot(x) { return x ^ -1 }
  var
    infinity = caml_int64_float_of_bits(_a_),
    neg_infinity = caml_int64_float_of_bits(_b_),
    nan = caml_int64_float_of_bits(_c_),
    max_float = caml_int64_float_of_bits(_d_),
    min_float = caml_int64_float_of_bits(_e_),
    epsilon = caml_int64_float_of_bits(_f_),
    max_int = 2147483647,
    min_int = -2147483648;
  function cat(s1, s2) {
    var
    l1 = caml_ml_string_length(s1),
    l2 = caml_ml_string_length(s2),
    s = caml_create_bytes(l1 + l2 | 0);
    caml_blit_string(s1, 0, s, 0, l1);
    caml_blit_string(s2, 0, s, l1, l2);
    return caml_string_of_bytes(s)
  }
  function char_of_int(n) { if (0 <= n && 255 >= n) return n; return invalid_arg(cst_char_of_int) }
  function string_of_bool(b) { return b ? cst_true : cst_false }
  function bool_of_string(param) {
    return caml_string_notequal(param, cst_false$0)
      ? caml_string_notequal(param, cst_true$0)
        ? invalid_arg(cst_bool_of_string)
        : 1
      : 0
  }
  function bool_of_string_opt(param) {
    return caml_string_notequal(param, cst_false$1)
      ? caml_string_notequal(param, cst_true$1) ? 0 : _g_
      : _h_
  }
  function string_of_int(n) { return caml_string_of_jsbytes("" + n) }
  function int_of_string_opt(s) {
    try { var _Et_ = [0, caml_int_of_string(s)]; return _Et_ }
    catch (_Eu_) {
      _Eu_ = caml_wrap_exception(_Eu_);
      if (_Eu_[1] === Failure) return 0;
      throw _Eu_
    }
  }
  function valid_float_lexem(s) {
    var l = caml_ml_string_length(s), i = 0;
    for (; ;) {
      if (l <= i) return cat(s, cst);
      var match = caml_string_get(s, i), switch$0 = 0;
      if (48 <= match) { if (58 > match) switch$0 = 1 }
      else
        if (45 === match) switch$0 = 1;
      if (!switch$0) return s;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function to_string(f) { return valid_float_lexem(caml_format_float(cst_12g, f)) }
  function of_string_opt(s) {
    try { var _Er_ = [0, caml_float_of_string(s)]; return _Er_ }
    catch (_Es_) {
      _Es_ = caml_wrap_exception(_Es_);
      if (_Es_[1] === Failure) return 0;
      throw _Es_
    }
  }
  function append(l1, l2) { if (!l1) return l2; var tl = l1[2], hd = l1[1]; return [0, hd, append(tl, l2)] }
  var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2);
  function open_gen(mode, perm, name) {
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c
  }
  function open_text(name) { return open_gen(_i_, 438, name) }
  function open_bin(name) { return open_gen(_j_, 438, name) }
  function flush_all(param) {
    function iter(param) {
      var param$0 = param;
      for (; ;) {
        if (!param$0) return 0;
        var l = param$0[2], a = param$0[1];
        try { caml_ml_flush(a) }
        catch (_Eq_) {
          _Eq_ = caml_wrap_exception(_Eq_);
          if (_Eq_[1] !== Sys_error) throw _Eq_
        }
        var param$0 = l
      }
    }
    return iter(runtime.caml_ml_out_channels_list(0))
  }
  function output_bytes(oc, s) { return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s)) }
  function output_string(oc, s) { return caml_ml_output(oc, s, 0, caml_ml_string_length(s)) }
  function output(oc, s, ofs, len) {
    if (0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
      return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output)
  }
  function output_substring(oc, s, ofs, len) {
    if (0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
      return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring)
  }
  function output_value(chan, v) { return caml_output_value(chan, v, 0) }
  function close(oc) { caml_ml_flush(oc); return caml_ml_close_channel(oc) }
  function close_noerr(oc) {
    try { caml_ml_flush(oc) } catch (_Ep_) { }
    try { var _En_ = caml_ml_close_channel(oc); return _En_ }
    catch (_Eo_) { return 0 }
  }
  function open_gen$0(mode, perm, name) {
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c
  }
  function open_text$0(name) { return open_gen$0(_k_, 0, name) }
  function open_bin$0(name) { return open_gen$0(_l_, 0, name) }
  function input(ic, s, ofs, len) {
    if (0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
      return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input)
  }
  function unsafe_really_input(ic, s, ofs, len) {
    var ofs$0 = ofs, len$0 = len;
    for (; ;) {
      if (0 >= len$0) return 0;
      var r = caml_ml_input(ic, s, ofs$0, len$0);
      if (0 === r) throw End_of_file;
      var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0, ofs$0 = ofs$1, len$0 = len$1
    }
  }
  function really_input(ic, s, ofs, len) {
    if (0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
      return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input)
  }
  function really_input_string(ic, len) {
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s)
  }
  function input_line(chan) {
    function build_result(buf, pos, param) {
      var pos$0 = pos, param$0 = param;
      for (; ;) {
        if (!param$0) return buf;
        var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
        caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
        var pos$1 = pos$0 - len | 0, pos$0 = pos$1, param$0 = tl
      }
    }
    var accu = 0, len = 0;
    for (; ;) {
      var n = runtime.caml_ml_input_scan_line(chan);
      if (0 === n) {
        if (!accu) throw End_of_file;
        var _Em_ = build_result(caml_create_bytes(len), len, accu)
      }
      else {
        if (0 >= n) {
          var beg = caml_create_bytes(- n | 0);
          caml_ml_input(chan, beg, 0, - n | 0);
          var len$1 = len - n | 0, accu$0 = [0, beg, accu], accu = accu$0, len = len$1;
          continue
        }
        var res = caml_create_bytes(n - 1 | 0);
        caml_ml_input(chan, res, 0, n - 1 | 0);
        caml_ml_input_char(chan);
        if (accu)
          var
            len$0 = (len + n | 0) - 1 | 0,
            _Em_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
        else
          var _Em_ = res
      }
      return caml_string_of_bytes(_Em_)
    }
  }
  function close_noerr$0(ic) {
    try { var _Ek_ = caml_ml_close_channel(ic); return _Ek_ }
    catch (_El_) { return 0 }
  }
  function print_char(c) { return caml_ml_output_char(stdout, c) }
  function print_string(s) { return output_string(stdout, s) }
  function print_bytes(s) { return output_bytes(stdout, s) }
  function print_int(i) { return output_string(stdout, caml_string_of_jsbytes("" + i)) }
  function print_float(f) { return output_string(stdout, to_string(f)) }
  function print_endline(s) {
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout)
  }
  function print_newline(param) { caml_ml_output_char(stdout, 10); return caml_ml_flush(stdout) }
  function prerr_char(c) { return caml_ml_output_char(stderr, c) }
  function prerr_string(s) { return output_string(stderr, s) }
  function prerr_bytes(s) { return output_bytes(stderr, s) }
  function prerr_int(i) { return output_string(stderr, caml_string_of_jsbytes("" + i)) }
  function prerr_float(f) { return output_string(stderr, to_string(f)) }
  function prerr_endline(s) {
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr)
  }
  function prerr_newline(param) { caml_ml_output_char(stderr, 10); return caml_ml_flush(stderr) }
  function read_line(param) { caml_ml_flush(stdout); return input_line(stdin) }
  function read_int(param) { return caml_int_of_string(read_line(0)) }
  function read_int_opt(param) { return int_of_string_opt(read_line(0)) }
  function read_float(param) { return caml_float_of_string(read_line(0)) }
  function read_float_opt(param) { return of_string_opt(read_line(0)) }
  function string_of_format(param) { var str = param[2]; return str }
  function symbol(param, _Ei_) {
    var
    str2 = _Ei_[2],
    fmt2 = _Ei_[1],
    str1 = param[2],
    fmt1 = param[1],
    _Ej_ = cat(str1, cat(cst$0, str2));
    return [0, concat_fmt(fmt1, fmt2), _Ej_]
  }
  var exit_function = [0, flush_all];
  function at_exit(f) {
    for (; ;) {
      var
      f_yet_to_run = [0, 1],
      old_exit = exit_function[1],
      new_exit$0 =
        function (f_yet_to_run, old_exit) {
          function new_exit(param) {
            if (compare_and_set(f_yet_to_run, 1, 0)) caml_call1(f, 0);
            return caml_call1(old_exit, 0)
          }
          return new_exit
        },
      new_exit = new_exit$0(f_yet_to_run, old_exit),
      success = compare_and_set(exit_function, old_exit, new_exit),
      _Eh_ = 1 - success;
      if (_Eh_) continue;
      return _Eh_
    }
  }
  function do_at_exit(param) { return caml_call1(exit_function[1], 0) }
  function exit(retcode) { do_at_exit(0); return runtime.caml_sys_exit(retcode) }
  caml_register_named_value
    (caml_string_of_jsbytes("Pervasives.do_at_exit"), do_at_exit);
  var
    _m_ =
      [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
    set_binary_mode = caml_ml_set_binary_mode,
    close$0 = caml_ml_close_channel,
    in_channel_length = caml_ml_channel_size,
    pos_in = caml_ml_pos_in,
    seek_in = runtime.caml_ml_seek_in,
    input_value = caml_input_value,
    input_binary_int = runtime.caml_ml_input_int,
    input_byte = caml_ml_input_char,
    input_char = caml_ml_input_char,
    set_binary_mode$0 = caml_ml_set_binary_mode,
    out_channel_length = caml_ml_channel_size,
    pos_out = runtime.caml_ml_pos_out,
    seek_out = runtime.caml_ml_seek_out,
    output_binary_int = runtime.caml_ml_output_int,
    output_byte = caml_ml_output_char,
    output_char = caml_ml_output_char,
    flush = caml_ml_flush,
    Stdlib =
      [0,
        invalid_arg,
        failwith,
        Exit,
        Match_failure,
        Assert_failure,
        Invalid_argument,
        Failure,
        Not_found,
        Out_of_memory,
        Stack_overflow,
        Sys_error,
        End_of_file,
        Division_by_zero,
        Sys_blocked_io,
        Undefined_recursive_module,
        min,
        max,
        abs,
        max_int,
        min_int,
        lnot,
        infinity,
        neg_infinity,
        nan,
        max_float,
        min_float,
        epsilon,
        cat,
        char_of_int,
        string_of_bool,
        bool_of_string_opt,
        bool_of_string,
        string_of_int,
        int_of_string_opt,
        to_string,
        of_string_opt,
        append,
        stdin,
        stdout,
        stderr,
        print_char,
        print_string,
        print_bytes,
        print_int,
        print_float,
        print_endline,
        print_newline,
        prerr_char,
        prerr_string,
        prerr_bytes,
        prerr_int,
        prerr_float,
        prerr_endline,
        prerr_newline,
        read_line,
        read_int_opt,
        read_int,
        read_float_opt,
        read_float,
        open_text,
        open_bin,
        open_gen,
        flush,
        flush_all,
        output_char,
        output_string,
        output_bytes,
        output,
        output_substring,
        output_byte,
        output_binary_int,
        output_value,
        seek_out,
        pos_out,
        out_channel_length,
        close,
        close_noerr,
        set_binary_mode$0,
        open_text$0,
        open_bin$0,
        open_gen$0,
        input_char,
        input_line,
        input,
        really_input,
        really_input_string,
        input_byte,
        input_binary_int,
        input_value,
        seek_in,
        pos_in,
        in_channel_length,
        close$0,
        close_noerr$0,
        set_binary_mode,
        _m_,
        string_of_format,
        symbol,
        exit,
        at_exit,
        valid_float_lexem,
        unsafe_really_input,
        do_at_exit];
  caml_register_global(775, Stdlib, "Stdlib");
  var
    Exit$0 = [248, cst_Stdlib_Pervasives_Exit, caml_fresh_oo_id(0)],
    Stdlib_Pervasives =
      [0,
        invalid_arg,
        failwith,
        Exit$0,
        min,
        max,
        abs,
        max_int,
        min_int,
        lnot,
        infinity,
        neg_infinity,
        nan,
        max_float,
        min_float,
        epsilon,
        cat,
        char_of_int,
        string_of_bool,
        bool_of_string,
        bool_of_string_opt,
        string_of_int,
        int_of_string_opt,
        to_string,
        of_string_opt,
        append,
        stdin,
        stdout,
        stderr,
        print_char,
        print_string,
        print_bytes,
        print_int,
        print_float,
        print_endline,
        print_newline,
        prerr_char,
        prerr_string,
        prerr_bytes,
        prerr_int,
        prerr_float,
        prerr_endline,
        prerr_newline,
        read_line,
        read_int,
        read_int_opt,
        read_float,
        read_float_opt,
        open_text,
        open_bin,
        open_gen,
        flush,
        flush_all,
        output_char,
        output_string,
        output_bytes,
        output,
        output_substring,
        output_byte,
        output_binary_int,
        output_value,
        seek_out,
        pos_out,
        out_channel_length,
        close,
        close_noerr,
        set_binary_mode$0,
        open_text$0,
        open_bin$0,
        open_gen$0,
        input_char,
        input_line,
        input,
        really_input,
        really_input_string,
        input_byte,
        input_binary_int,
        input_value,
        seek_in,
        pos_in,
        in_channel_length,
        close$0,
        close_noerr$0,
        set_binary_mode,
        string_of_format,
        symbol,
        exit,
        at_exit,
        valid_float_lexem,
        do_at_exit];
  caml_register_global(776, Stdlib_Pervasives, "Stdlib__Pervasives");
  function left(v) { return [0, v] }
  function right(v) { return [1, v] }
  function is_left(param) { return 0 === param[0] ? 1 : 0 }
  function is_right(param) { return 0 === param[0] ? 0 : 1 }
  function find_left(param) { if (0 !== param[0]) return 0; var v = param[1]; return [0, v] }
  function find_right(param) { if (0 === param[0]) return 0; var v = param[1]; return [0, v] }
  function map_left(f, e) { if (0 !== e[0]) return e; var v = e[1]; return [0, caml_call1(f, v)] }
  function map_right(f, e) { if (0 === e[0]) return e; var v = e[1]; return [1, caml_call1(f, v)] }
  function map(left, right, param) {
    if (0 === param[0]) { var v = param[1]; return [0, caml_call1(left, v)] }
    var v$0 = param[1];
    return [1, caml_call1(right, v$0)]
  }
  function fold(left, right, param) {
    if (0 === param[0]) { var v = param[1]; return caml_call1(left, v) }
    var v$0 = param[1];
    return caml_call1(right, v$0)
  }
  function equal(left, right, e1, e2) {
    if (0 === e1[0]) {
      var _Ef_ = e1[1];
      if (0 === e2[0]) { var v2 = e2[1]; return caml_call2(left, _Ef_, v2) }
    }
    else {
      var _Eg_ = e1[1];
      if (0 !== e2[0]) { var v2$0 = e2[1]; return caml_call2(right, _Eg_, v2$0) }
    }
    return 0
  }
  function compare(left, right, e1, e2) {
    if (0 === e1[0]) {
      var _Ed_ = e1[1];
      if (0 !== e2[0]) return -1;
      var v2 = e2[1];
      return caml_call2(left, _Ed_, v2)
    }
    var _Ee_ = e1[1];
    if (0 === e2[0]) return 1;
    var v2$0 = e2[1];
    return caml_call2(right, _Ee_, v2$0)
  }
  var
    Stdlib_Either =
      [0,
        left,
        right,
        is_left,
        is_right,
        find_left,
        find_right,
        map_left,
        map_right,
        map,
        fold,
        fold,
        fold,
        equal,
        compare];
  caml_register_global(777, Stdlib_Either, "Stdlib__Either");
  var
    executable_name = runtime.caml_sys_executable_name(0),
    match = runtime.caml_sys_get_config(0),
    os_type = match[1],
    match$0 = [0, caml_string_of_jsbytes("js_of_ocaml")],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0,
    big_endian = 0,
    match$1 = 32,
    int_size = 32;
  function getenv_opt(s) {
    try { var _Eb_ = [0, caml_sys_getenv(s)]; return _Eb_ }
    catch (_Ec_) {
      _Ec_ = caml_wrap_exception(_Ec_);
      if (_Ec_ === Not_found) return 0;
      throw _Ec_
    }
  }
  var interactive = [0, 0];
  function set_signal(sig_num, sig_beh) { return 0 }
  var
    Break = [248, cst_Stdlib_Sys_Break, caml_fresh_oo_id(0)],
    sigabrt = -1,
    sigalrm = -2,
    sigfpe = -3,
    sighup = -4,
    sigill = -5,
    sigint = -6,
    sigkill = -7,
    sigpipe = -8,
    sigquit = -9,
    sigsegv = -10,
    sigterm = -11,
    sigusr1 = -12,
    sigusr2 = -13,
    sigchld = -14,
    sigcont = -15,
    sigstop = -16,
    sigtstp = -17,
    sigttin = -18,
    sigttou = -19,
    sigvtalrm = -20,
    sigprof = -21,
    sigbus = -22,
    sigpoll = -23,
    sigsys = -24,
    sigtrap = -25,
    sigurg = -26,
    sigxcpu = -27,
    sigxfsz = -28;
  function catch_break(on) { return on ? 0 : 0 }
  var development_version = 0;
  function Make(_Ea_, _D$_) { return [0, 1] }
  var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
        executable_name,
        getenv_opt,
        interactive,
        os_type,
        match$0,
        unix,
        win32,
        cygwin,
        match$1,
        int_size,
        big_endian,
        max_string_length,
        max_array_length,
        max_floatarray_length,
        set_signal,
        sigabrt,
        sigalrm,
        sigfpe,
        sighup,
        sigill,
        sigint,
        sigkill,
        sigpipe,
        sigquit,
        sigsegv,
        sigterm,
        sigusr1,
        sigusr2,
        sigchld,
        sigcont,
        sigstop,
        sigtstp,
        sigttin,
        sigttou,
        sigvtalrm,
        sigprof,
        sigbus,
        sigpoll,
        sigsys,
        sigtrap,
        sigurg,
        sigxcpu,
        sigxfsz,
        Break,
        catch_break,
        ocaml_version,
        development_version,
        ocaml_release,
        runtime.caml_ml_enable_runtime_warnings,
        runtime.caml_ml_runtime_warnings_enabled,
        Immediate64];
  caml_register_global(778, Stdlib_Sys, "Stdlib__Sys");
  function is_block(a) { return 1 - (typeof a === "number" ? 1 : 0) }
  function double_field(x, i) { return caml_array_get(x, i) }
  function set_double_field(x, i, v) { return caml_array_set(x, i, v) }
  var
    first_non_constant_constructor = 0,
    last_non_constant_constructor_ = 245,
    lazy_tag = 246,
    closure_tag = 247,
    object_tag = 248,
    infix_tag = 249,
    forward_tag = 250,
    no_scan_tag = 251,
    abstract_tag = 251,
    string_tag = 252,
    double_tag = 253,
    double_array_tag = 254,
    custom_tag = 255,
    int_tag = 1000,
    out_of_heap_tag = 1001,
    unaligned_tag = 1002;
  function info(obj) {
    if (caml_obj_tag(obj) !== 247) throw [0, Assert_failure, _n_];
    var
      info = runtime.caml_obj_raw_field(obj, 1),
      arity = info >> 24,
      start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env]
  }
  function of_val(x) {
    var switch$0 = 0;
    if (is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1) { var slot = x[1]; switch$0 = 1 }
    if (!switch$0) var slot = x;
    var switch$1 = 0;
    if (is_block(slot) && caml_obj_tag(slot) === 248) { var name = slot[1]; switch$1 = 1 }
    if (!switch$1) var name = invalid_arg(cst_Obj_extension_constructor$0);
    return caml_obj_tag(name) === 252
      ? slot
      : invalid_arg(cst_Obj_extension_constructor)
  }
  function name(slot) { return slot[1] }
  function id(slot) { return slot[2] }
  var
    Extension_constructor = [0, of_val, name, id],
    extension_constructor = Extension_constructor[1],
    extension_name = Extension_constructor[2],
    extension_id = Extension_constructor[3],
    max_ephe_length = max_array_length - 2 | 0;
  function create(l) {
    var _D9_ = 0 <= l ? 1 : 0, _D__ = _D9_ ? l <= max_ephe_length ? 1 : 0 : _D9_;
    if (1 - _D__) invalid_arg(cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l)
  }
  function length(x) { return x.length - 1 - 2 | 0 }
  function raise_if_invalid_offset(e, o, msg) {
    var _D6_ = 0 <= o ? 1 : 0, _D7_ = _D6_ ? o < length(e) ? 1 : 0 : _D6_, _D8_ = 1 - _D7_;
    return _D8_ ? invalid_arg(msg) : _D8_
  }
  function get_key(e, o) {
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return caml_ephe_get_key(e, o)
  }
  function get_key_copy(e, o) {
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return caml_ephe_get_key_copy(e, o)
  }
  function set_key(e, o, x) {
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return caml_ephe_set_key(e, o, x)
  }
  function unset_key(e, o) {
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return caml_ephe_unset_key(e, o)
  }
  function check_key(e, o) {
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return caml_ephe_check_key(e, o)
  }
  function blit_key(e1, o1, e2, o2, l) {
    if
      (0
      <=
      l
      &&
      0
      <=
      o1
      &&
      (length(e1) - l | 0)
      >=
      o1
      &&
      0
      <=
      o2
      &&
      (length(e2) - l | 0)
      >=
      o2) {
      var _D4_ = 0 !== l ? 1 : 0, _D5_ = _D4_ ? caml_ephe_blit_key(e1, o1, e2, o2, l) : _D4_;
      return _D5_
    }
    return invalid_arg(cst_Obj_Ephemeron_blit_key)
  }
  var
    _o_ =
      [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length],
    Stdlib_Obj =
      [0,
        is_block,
        double_field,
        set_double_field,
        first_non_constant_constructor,
        last_non_constant_constructor_,
        lazy_tag,
        closure_tag,
        object_tag,
        infix_tag,
        forward_tag,
        no_scan_tag,
        abstract_tag,
        string_tag,
        double_tag,
        double_array_tag,
        custom_tag,
        custom_tag,
        int_tag,
        out_of_heap_tag,
        unaligned_tag,
        [0, info],
        Extension_constructor,
        extension_constructor,
        extension_name,
        extension_id,
        _o_];
  caml_register_global(779, Stdlib_Obj, "Stdlib__Obj");
  var Undefined = [248, cst_CamlinternalLazy_Undefined, caml_fresh_oo_id(0)];
  function raise_undefined(param) { throw Undefined }
  function force_lazy_block(blk) {
    var closure = blk[1];
    blk[1] = raise_undefined;
    try {
      var result = caml_call1(closure, 0);
      caml_obj_make_forward(blk, result);
      return result
    }
    catch (e) { e = caml_wrap_exception(e); blk[1] = function (param) { throw e }; throw e }
  }
  function force_val_lazy_block(blk) {
    var closure = blk[1];
    blk[1] = raise_undefined;
    var result = caml_call1(closure, 0);
    caml_obj_make_forward(blk, result);
    return result
  }
  function force(lzv) {
    var t = caml_obj_tag(lzv);
    return t === 250 ? lzv[1] : t !== 246 ? lzv : force_lazy_block(lzv)
  }
  function force_val(lzv) {
    var t = caml_obj_tag(lzv);
    return t === 250 ? lzv[1] : t !== 246 ? lzv : force_val_lazy_block(lzv)
  }
  var
    CamlinternalLazy =
      [0, Undefined, force_lazy_block, force_val_lazy_block, force, force_val];
  caml_register_global(780, CamlinternalLazy, "CamlinternalLazy");
  function to_lazy(f) { var x = caml_obj_block(246, 1); x[1] = f; return x }
  function from_val(v) {
    var t = caml_obj_tag(v);
    if (t !== 250 && t !== 246 && t !== 253) return v;
    return runtime.caml_lazy_make_forward(v)
  }
  function is_val(l) { return caml_obj_tag(l) !== 246 ? 1 : 0 }
  function map$0(f, x) {
    return [246,
      function (_D1_) {
        var
        _D2_ = caml_obj_tag(x),
        _D3_ = 250 === _D2_ ? x[1] : 246 === _D2_ ? force_lazy_block(x) : x;
        return caml_call1(f, _D3_)
      }]
  }
  function map_val(f, x) {
    if (!is_val(x))
      return [246,
        function (_DY_) {
          var
          _DZ_ = caml_obj_tag(x),
          _D0_ = 250 === _DZ_ ? x[1] : 246 === _DZ_ ? force_lazy_block(x) : x;
          return caml_call1(f, _D0_)
        }];
    var
      _DW_ = caml_obj_tag(x),
      _DX_ = 250 === _DW_ ? x[1] : 246 === _DW_ ? force_lazy_block(x) : x;
    return from_val(caml_call1(f, _DX_))
  }
  var
    Stdlib_Lazy =
      [0,
        Undefined,
        map$0,
        is_val,
        from_val,
        map_val,
        to_lazy,
        force_val,
        to_lazy,
        from_val,
        is_val];
  caml_register_global(781, Stdlib_Lazy, "Stdlib__Lazy");
  function empty(param) { return 0 }
  function return$0(x, param) { return [0, x, empty] }
  function cons(x, next, param) { return [0, x, next] }
  function append$0(seq1, seq2, param) {
    var match = caml_call1(seq1, 0);
    if (!match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function (_DV_) { return append$0(next, seq2, _DV_) }]
  }
  function map$1(f, seq, param) {
    var match = caml_call1(seq, 0);
    if (!match) return 0;
    var next = match[2], x = match[1];
    function _DT_(_DU_) { return map$1(f, next, _DU_) }
    return [0, caml_call1(f, x), _DT_]
  }
  function filter_map(f, seq, param) {
    var seq$0 = seq;
    for (; ;) {
      var match = caml_call1(seq$0, 0);
      if (!match) return 0;
      var next = match[2], x = match[1], match$0 = caml_call1(f, x);
      if (match$0) {
        var y = match$0[1];
        return [0, y, function (_DS_) { return filter_map(f, next, _DS_) }]
      }
      var seq$0 = next
    }
  }
  function filter(f, seq, param) {
    var seq$0 = seq;
    for (; ;) {
      var match = caml_call1(seq$0, 0);
      if (!match) return 0;
      var next = match[2], x = match[1];
      if (caml_call1(f, x))
        return [0, x, function (_DR_) { return filter(f, next, _DR_) }];
      var seq$0 = next
    }
  }
  function concat(seq, param) {
    var match = caml_call1(seq, 0);
    if (!match) return 0;
    var next = match[2], x = match[1], _DP_ = 0;
    return append$0(x, function (_DQ_) { return concat(next, _DQ_) }, _DP_)
  }
  function flat_map(f, seq, param) {
    var match = caml_call1(seq, 0);
    if (!match) return 0;
    var next = match[2], x = match[1], _DM_ = 0;
    function _DN_(_DO_) { return flat_map(f, next, _DO_) }
    return append$0(caml_call1(f, x), _DN_, _DM_)
  }
  function fold_left(f, acc, seq) {
    var acc$0 = acc, seq$0 = seq;
    for (; ;) {
      var match = caml_call1(seq$0, 0);
      if (!match) return acc$0;
      var
        next = match[2],
        x = match[1],
        acc$1 = caml_call2(f, acc$0, x),
        acc$0 = acc$1,
        seq$0 = next
    }
  }
  function iter(f, seq) {
    var seq$0 = seq;
    for (; ;) {
      var match = caml_call1(seq$0, 0);
      if (!match) return 0;
      var next = match[2], x = match[1];
      caml_call1(f, x);
      var seq$0 = next
    }
  }
  function unfold(f, u, param) {
    var match = caml_call1(f, u);
    if (!match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function (_DL_) { return unfold(f, u$0, _DL_) }]
  }
  function is_empty(xs) { var match = caml_call1(xs, 0); return match ? 0 : 1 }
  function uncons(xs) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]]
  }
  function length$0(xs$1) {
    var accu = 0, xs = xs$1;
    for (; ;) {
      var match = caml_call1(xs, 0);
      if (!match) return accu;
      var xs$0 = match[2], accu$0 = accu + 1 | 0, accu = accu$0, xs = xs$0
    }
  }
  function iteri(f, xs$1) {
    var i = 0, xs = xs$1;
    for (; ;) {
      var match = caml_call1(xs, 0);
      if (!match) return 0;
      var xs$0 = match[2], x = match[1];
      caml_call2(f, i, x);
      var i$0 = i + 1 | 0, i = i$0, xs = xs$0
    }
  }
  function fold_lefti(f, accu$1, xs$1) {
    var accu = accu$1, i = 0, xs = xs$1;
    for (; ;) {
      var match = caml_call1(xs, 0);
      if (!match) return accu;
      var
        xs$0 = match[2],
        x = match[1],
        accu$0 = caml_call3(f, accu, i, x),
        i$0 = i + 1 | 0,
        accu = accu$0,
        i = i$0,
        xs = xs$0
    }
  }
  function for_all(p, xs) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 1;
      var xs$1 = match[2], x = match[1], _DK_ = caml_call1(p, x);
      if (!_DK_) return _DK_;
      var xs$0 = xs$1
    }
  }
  function exists(p, xs) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], _DJ_ = caml_call1(p, x);
      if (_DJ_) return _DJ_;
      var xs$0 = xs$1
    }
  }
  function find(p, xs) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1];
      if (caml_call1(p, x)) return [0, x];
      var xs$0 = xs$1
    }
  }
  function find_map(f, xs) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
      if (result) return result;
      var xs$0 = xs$1
    }
  }
  function iter2(f, xs, ys) {
    var xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
      if (!match$0) return 0;
      var ys$1 = match$0[2], y = match$0[1];
      caml_call2(f, x, y);
      var xs$0 = xs$1, ys$0 = ys$1
    }
  }
  function fold_left2(f, accu, xs, ys) {
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return accu$0;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
      if (!match$0) return accu$0;
      var
        ys$1 = match$0[2],
        y = match$0[1],
        accu$1 = caml_call3(f, accu$0, x, y),
        accu$0 = accu$1,
        xs$0 = xs$1,
        ys$0 = ys$1
    }
  }
  function for_all2(f, xs, ys) {
    var xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 1;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
      if (!match$0) return 1;
      var ys$1 = match$0[2], y = match$0[1], _DI_ = caml_call2(f, x, y);
      if (!_DI_) return _DI_;
      var xs$0 = xs$1, ys$0 = ys$1
    }
  }
  function exists2(f, xs, ys) {
    var xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
      if (!match$0) return 0;
      var ys$1 = match$0[2], y = match$0[1], _DH_ = caml_call2(f, x, y);
      if (_DH_) return _DH_;
      var xs$0 = xs$1, ys$0 = ys$1
    }
  }
  function equal$0(eq, xs, ys) {
    var xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
      if (match) {
        if (match$0) {
          var
          ys$1 = match$0[2],
          y = match$0[1],
          xs$1 = match[2],
          x = match[1],
          _DG_ = caml_call2(eq, x, y);
          if (!_DG_) return _DG_;
          var xs$0 = xs$1, ys$0 = ys$1;
          continue
        }
      }
      else
        if (!match$0) return 1;
      return 0
    }
  }
  function compare$0(cmp, xs, ys) {
    var xs$0 = xs, ys$0 = ys;
    for (; ;) {
      var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
      if (!match) return match$0 ? -1 : 0;
      var _DE_ = match[2], _DF_ = match[1];
      if (!match$0) return 1;
      var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, _DF_, y);
      if (0 !== c) return c;
      var xs$0 = _DE_, ys$0 = ys$1
    }
  }
  function init_aux(f, i, j, param) {
    if (i >= j) return 0;
    var _DB_ = i + 1 | 0;
    function _DC_(_DD_) { return init_aux(f, _DB_, j, _DD_) }
    return [0, caml_call1(f, i), _DC_]
  }
  function init(n, f) {
    if (0 > n) return invalid_arg(cst_Seq_init);
    var _Dz_ = 0;
    return function (_DA_) { return init_aux(f, _Dz_, n, _DA_) }
  }
  function repeat(x, param) { return [0, x, function (_Dy_) { return repeat(x, _Dy_) }] }
  function forever(f, param) {
    function _Dw_(_Dx_) { return forever(f, _Dx_) }
    return [0, caml_call1(f, 0), _Dw_]
  }
  function cycle_nonempty(xs, param) {
    var _Du_ = 0;
    return append$0(xs, function (_Dv_) { return cycle_nonempty(xs, _Dv_) }, _Du_)
  }
  function cycle(xs, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1];
    function _Dr_(_Dt_) { return cycle_nonempty(xs, _Dt_) }
    return [0, x, function (_Ds_) { return append$0(xs$0, _Dr_, _Ds_) }]
  }
  function iterate1(f, x, param) {
    var y = caml_call1(f, x);
    return [0, y, function (_Dq_) { return iterate1(f, y, _Dq_) }]
  }
  function iterate(f, x) {
    function _Dn_(_Dp_) { return iterate1(f, x, _Dp_) }
    return function (_Do_) { return [0, x, _Dn_] }
  }
  function mapi_aux(f, i, xs, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1], _Dk_ = i + 1 | 0;
    function _Dl_(_Dm_) { return mapi_aux(f, _Dk_, xs$0, _Dm_) }
    return [0, caml_call2(f, i, x), _Dl_]
  }
  function mapi(f, xs) { var _Di_ = 0; return function (_Dj_) { return mapi_aux(f, _Di_, xs, _Dj_) } }
  function tail_scan(f, s, xs, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function (_Dh_) { return tail_scan(f, s$0, xs$0, _Dh_) }]
  }
  function scan(f, s, xs) {
    function _De_(_Dg_) { return tail_scan(f, s, xs, _Dg_) }
    return function (_Df_) { return [0, s, _De_] }
  }
  function take_aux(n, xs) {
    return 0 === n
      ? empty
      : function (param) {
        var match = caml_call1(xs, 0);
        if (!match) return 0;
        var xs$0 = match[2], x = match[1];
        return [0, x, take_aux(n - 1 | 0, xs$0)]
      }
  }
  function take(n, xs) { if (n < 0) invalid_arg(cst_Seq_take); return take_aux(n, xs) }
  function drop(n, xs) {
    return 0 <= n
      ? 0 === n
        ? xs
        : function (param) {
          var n$0 = n, xs$0 = xs;
          for (; ;) {
            var match = caml_call1(xs$0, 0);
            if (!match) return 0;
            var xs$1 = match[2], n$1 = n$0 - 1 | 0;
            if (0 === n$1) return caml_call1(xs$1, 0);
            var n$0 = n$1, xs$0 = xs$1
          }
        }
      : invalid_arg(cst_Seq_drop)
  }
  function take_while(p, xs, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
      ? [0, x, function (_Dd_) { return take_while(p, xs$0, _Dd_) }]
      : 0
  }
  function drop_while(p, xs, param) {
    var xs$0 = xs;
    for (; ;) {
      var node = caml_call1(xs$0, 0);
      if (!node) return 0;
      var xs$1 = node[2], x = node[1];
      if (!caml_call1(p, x)) return node;
      var xs$0 = xs$1
    }
  }
  function group(eq, xs, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1], _C6_ = caml_call1(eq, x);
    function _C7_(_Dc_) { return drop_while(_C6_, xs$0, _Dc_) }
    function _C8_(_Db_) { return group(eq, _C7_, _Db_) }
    var _C9_ = caml_call1(eq, x);
    function _C__(_Da_) { return take_while(_C9_, xs$0, _Da_) }
    return [0, function (_C$_) { return [0, x, _C__] }, _C8_]
  }
  var Forced_twice = [248, cst_Stdlib_Seq_Forced_twice, caml_fresh_oo_id(0)];
  function failure(param) { throw Forced_twice }
  function memoize(xs) {
    function s$0(param) {
      var match = caml_call1(xs, 0);
      if (!match) return 0;
      var xs$0 = match[2], x = match[1];
      return [0, x, memoize(xs$0)]
    }
    var s = to_lazy(s$0);
    return function (_C5_) {
      var _C4_ = caml_obj_tag(s);
      return 250 === _C4_ ? s[1] : 246 === _C4_ ? force_lazy_block(s) : s
    }
  }
  function once(xs) {
    function f(param) {
      var match = caml_call1(xs, 0);
      if (!match) return 0;
      var xs$0 = match[2], x = match[1];
      return [0, x, once(xs$0)]
    }
    var action = [0, f];
    return function (param) { var f = exchange(action, failure); return caml_call1(f, 0) }
  }
  function zip(xs, ys, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if (!match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function (_C3_) { return zip(xs$0, ys$0, _C3_) }]
  }
  function map2(f, xs, ys, param) {
    var match = caml_call1(xs, 0);
    if (!match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if (!match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    function _C1_(_C2_) { return map2(f, xs$0, ys$0, _C2_) }
    return [0, caml_call2(f, x, y), _C1_]
  }
  function interleave(xs, ys, param) {
    var match = caml_call1(xs, 0);
    if (!match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function (_C0_) { return interleave(ys, xs$0, _C0_) }]
  }
  function sorted_merge1(cmp, x, xs, y, ys) {
    return 0 < caml_call2(cmp, x, y)
      ? [0,
        y,
        function (_CY_) {
          var match = caml_call1(ys, 0);
          if (!match) return [0, x, xs];
          var ys$0 = match[2], y = match[1];
          return sorted_merge1(cmp, x, xs, y, ys$0)
        }]
      : [0,
        x,
        function (_CZ_) {
          var match = caml_call1(xs, 0);
          if (!match) return [0, y, ys];
          var xs$0 = match[2], x = match[1];
          return sorted_merge1(cmp, x, xs$0, y, ys)
        }]
  }
  function sorted_merge(cmp, xs, ys, param) {
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if (match) {
      if (match$0) {
        var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
        return sorted_merge1(cmp, x, xs$0, y, ys$0)
      }
      var c = match
    }
    else { if (!match$0) return 0; var c = match$0 }
    return c
  }
  function map_fst(xys, param) {
    var match = caml_call1(xys, 0);
    if (!match) return 0;
    var xys$0 = match[2], match$0 = match[1], x = match$0[1];
    return [0, x, function (_CX_) { return map_fst(xys$0, _CX_) }]
  }
  function map_snd(xys, param) {
    var match = caml_call1(xys, 0);
    if (!match) return 0;
    var xys$0 = match[2], match$0 = match[1], y = match$0[2];
    return [0, y, function (_CW_) { return map_snd(xys$0, _CW_) }]
  }
  function unzip(xys) {
    function _CT_(_CV_) { return map_snd(xys, _CV_) }
    return [0, function (_CU_) { return map_fst(xys, _CU_) }, _CT_]
  }
  function filter_map_find_left_map(f, xs, param) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
      if (0 === match$0[0]) {
        var y = match$0[1];
        return [0,
          y,
          function (_CS_) { return filter_map_find_left_map(f, xs$1, _CS_) }]
      }
      var xs$0 = xs$1
    }
  }
  function filter_map_find_right_map(f, xs, param) {
    var xs$0 = xs;
    for (; ;) {
      var match = caml_call1(xs$0, 0);
      if (!match) return 0;
      var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
      if (0 === match$0[0]) { var xs$0 = xs$1; continue }
      var z = match$0[1];
      return [0,
        z,
        function (_CR_) { return filter_map_find_right_map(f, xs$1, _CR_) }]
    }
  }
  function partition_map(f, xs) {
    function _CO_(_CQ_) { return filter_map_find_right_map(f, xs, _CQ_) }
    return [0,
      function (_CP_) { return filter_map_find_left_map(f, xs, _CP_) },
      _CO_]
  }
  function partition(p, xs) {
    function _CK_(x) { return 1 - caml_call1(p, x) }
    function _CL_(_CN_) { return filter(_CK_, xs, _CN_) }
    return [0, function (_CM_) { return filter(p, xs, _CM_) }, _CL_]
  }
  function peel(xss) { return unzip(function (_CJ_) { return filter_map(uncons, xss, _CJ_) }) }
  function transpose(xss, param) {
    var match = peel(xss), tails = match[2], heads = match[1];
    if (!is_empty(heads))
      return [0, heads, function (_CI_) { return transpose(tails, _CI_) }];
    if (is_empty(tails)) return 0;
    throw [0, Assert_failure, _p_]
  }
  function _q_(remainders, xss, param) {
    var match = caml_call1(xss, 0);
    if (!match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if (match$0) {
      var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _CC_ = function (_CH_) { return [0, xs$0, tails] },
      _CD_ = function (_CG_) { return _q_(_CC_, xss$0, _CG_) };
      return [0, function (_CF_) { return [0, x, heads] }, _CD_]
    }
    var match$2 = peel(remainders), tails$0 = match$2[2], heads$0 = match$2[1];
    return [0, heads$0, function (_CE_) { return _q_(tails$0, xss$0, _CE_) }]
  }
  function map_product(f, xs, ys) {
    function _Cw_(x) {
      function _CA_(y) { return caml_call2(f, x, y) }
      return function (_CB_) { return map$1(_CA_, ys, _CB_) }
    }
    function xss(_Cz_) { return map$1(_Cw_, xs, _Cz_) }
    function _Cv_(_Cy_) { return _q_(empty, xss, _Cy_) }
    return function (_Cx_) { return concat(_Cv_, _Cx_) }
  }
  function product(xs, ys) { return map_product(function (x, y) { return [0, x, y] }, xs, ys) }
  function of_dispenser(it) {
    function c(param) {
      var match = caml_call1(it, 0);
      if (!match) return 0;
      var x = match[1];
      return [0, x, c]
    }
    return c
  }
  function to_dispenser(xs) {
    var s = [0, xs];
    return function (param) {
      var match = caml_call1(s[1], 0);
      if (!match) return 0;
      var xs = match[2], x = match[1];
      s[1] = xs;
      return [0, x]
    }
  }
  function ints(i, param) { var _Ct_ = i + 1 | 0; return [0, i, function (_Cu_) { return ints(_Ct_, _Cu_) }] }
  var
    Stdlib_Seq =
      [0,
        is_empty,
        uncons,
        length$0,
        iter,
        fold_left,
        iteri,
        fold_lefti,
        for_all,
        exists,
        find,
        find_map,
        iter2,
        fold_left2,
        for_all2,
        exists2,
        equal$0,
        compare$0,
        empty,
        return$0,
        cons,
        init,
        unfold,
        repeat,
        forever,
        cycle,
        iterate,
        map$1,
        mapi,
        filter,
        filter_map,
        scan,
        take,
        drop,
        take_while,
        drop_while,
        group,
        memoize,
        Forced_twice,
        once,
        transpose,
        append$0,
        concat,
        flat_map,
        flat_map,
        zip,
        map2,
        interleave,
        sorted_merge,
        product,
        map_product,
        unzip,
        unzip,
        partition_map,
        partition,
        of_dispenser,
        to_dispenser,
        ints];
  caml_register_global(782, Stdlib_Seq, "Stdlib__Seq");
  var none = 0;
  function some(v) { return [0, v] }
  function value(o, default$0) { if (!o) return default$0; var v = o[1]; return v }
  function get$0(param) {
    if (!param) return invalid_arg(cst_option_is_None);
    var v = param[1];
    return v
  }
  function bind(o, f) { if (!o) return 0; var v = o[1]; return caml_call1(f, v) }
  function join(param) { if (!param) return 0; var o = param[1]; return o }
  function map$2(f, o) { if (!o) return 0; var v = o[1]; return [0, caml_call1(f, v)] }
  function fold$0(none, some, param) { if (!param) return none; var v = param[1]; return caml_call1(some, v) }
  function iter$0(f, param) { if (!param) return 0; var v = param[1]; return caml_call1(f, v) }
  function is_none(param) { return param ? 0 : 1 }
  function is_some(param) { return param ? 1 : 0 }
  function equal$1(eq, o0, o1) {
    if (o0) { if (o1) { var v1 = o1[1], v0 = o0[1]; return caml_call2(eq, v0, v1) } }
    else
      if (!o1) return 1;
    return 0
  }
  function compare$1(cmp, o0, o1) {
    if (!o0) return o1 ? -1 : 0;
    var _Cs_ = o0[1];
    if (!o1) return 1;
    var v1 = o1[1];
    return caml_call2(cmp, _Cs_, v1)
  }
  function to_result(none, param) { if (!param) return [1, none]; var v = param[1]; return [0, v] }
  function to_list(param) { if (!param) return 0; var v = param[1]; return [0, v, 0] }
  function to_seq(param) {
    if (!param) return empty;
    var v = param[1];
    return function (_Cr_) { return return$0(v, _Cr_) }
  }
  var
    Stdlib_Option =
      [0,
        none,
        some,
        value,
        get$0,
        bind,
        join,
        map$2,
        fold$0,
        iter$0,
        is_none,
        is_some,
        equal$1,
        compare$1,
        to_result,
        to_list,
        to_seq];
  caml_register_global(783, Stdlib_Option, "Stdlib__Option");
  function ok(v) { return [0, v] }
  function error(e) { return [1, e] }
  function value$0(r, default$0) { if (0 !== r[0]) return default$0; var v = r[1]; return v }
  function get_ok(param) {
    if (0 !== param[0]) return invalid_arg(cst_result_is_Error);
    var v = param[1];
    return v
  }
  function get_error(param) {
    if (0 === param[0]) return invalid_arg(cst_result_is_Ok);
    var e = param[1];
    return e
  }
  function bind$0(r, f) { if (0 !== r[0]) return r; var v = r[1]; return caml_call1(f, v) }
  function join$0(e) { if (0 !== e[0]) return e; var r = e[1]; return r }
  function map$3(f, e) { if (0 !== e[0]) return e; var v = e[1]; return [0, caml_call1(f, v)] }
  function map_error(f, v) { if (0 === v[0]) return v; var e = v[1]; return [1, caml_call1(f, e)] }
  function fold$1(ok, error, param) {
    if (0 === param[0]) { var v = param[1]; return caml_call1(ok, v) }
    var e = param[1];
    return caml_call1(error, e)
  }
  function iter$1(f, param) { if (0 !== param[0]) return 0; var v = param[1]; return caml_call1(f, v) }
  function iter_error(f, param) { if (0 === param[0]) return 0; var e = param[1]; return caml_call1(f, e) }
  function is_ok(param) { return 0 === param[0] ? 1 : 0 }
  function is_error(param) { return 0 === param[0] ? 0 : 1 }
  function equal$2(ok, error, r0, r1) {
    if (0 === r0[0]) {
      var _Cp_ = r0[1];
      if (0 === r1[0]) { var v1 = r1[1]; return caml_call2(ok, _Cp_, v1) }
    }
    else {
      var _Cq_ = r0[1];
      if (0 !== r1[0]) { var e1 = r1[1]; return caml_call2(error, _Cq_, e1) }
    }
    return 0
  }
  function compare$2(ok, error, r0, r1) {
    if (0 === r0[0]) {
      var _Cn_ = r0[1];
      if (0 !== r1[0]) return -1;
      var v1 = r1[1];
      return caml_call2(ok, _Cn_, v1)
    }
    var _Co_ = r0[1];
    if (0 === r1[0]) return 1;
    var e1 = r1[1];
    return caml_call2(error, _Co_, e1)
  }
  function to_option(param) { if (0 !== param[0]) return 0; var v = param[1]; return [0, v] }
  function to_list$0(param) { if (0 !== param[0]) return 0; var v = param[1]; return [0, v, 0] }
  function to_seq$0(param) {
    if (0 !== param[0]) return empty;
    var v = param[1];
    return function (_Cm_) { return return$0(v, _Cm_) }
  }
  var
    Stdlib_Result =
      [0,
        ok,
        error,
        value$0,
        get_ok,
        get_error,
        bind$0,
        join$0,
        map$3,
        map_error,
        fold$1,
        iter$1,
        iter_error,
        is_ok,
        is_error,
        equal$2,
        compare$2,
        to_option,
        to_list$0,
        to_seq$0];
  caml_register_global(784, Stdlib_Result, "Stdlib__Result");
  function equal$3(_Cl_, _Ck_) { return _Cl_ === _Ck_ ? 1 : 0 }
  var compare$3 = caml_int_compare;
  function to_float(param) { return param ? 1. : 0. }
  function to_string$0(param) { return param ? cst_true$2 : cst_false$2 }
  function _r_(_Cj_) { return _Cj_ }
  var
    Stdlib_Bool =
      [0,
        function (_Ci_) { return 1 - _Ci_ },
        equal$3,
        compare$3,
        _r_,
        to_float,
        to_string$0];
  caml_register_global(785, Stdlib_Bool, "Stdlib__Bool");
  function chr(n) { if (0 <= n && 255 >= n) return n; return invalid_arg(cst_Char_chr) }
  function escaped(c) {
    var switch$0 = 0;
    if (40 <= c) { if (92 === c) return cst$1; if (127 > c) switch$0 = 1 }
    else
      if (32 <= c) { if (39 <= c) return cst$2; switch$0 = 1 }
      else
        if (14 > c)
          switch (c) {
            case 8: return cst_b;
            case 9: return cst_t;
            case 10: return cst_n;
            case 13: return cst_r
          }
    if (switch$0) {
      var s$0 = caml_create_bytes(1);
      caml_bytes_unsafe_set(s$0, 0, c);
      return caml_string_of_bytes(s$0)
    }
    var s = caml_create_bytes(4);
    caml_bytes_unsafe_set(s, 0, 92);
    caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
    caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
    caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
    return caml_string_of_bytes(s)
  }
  function lowercase(c) {
    var _Ch_ = c - 192 | 0, switch$0 = 0;
    if (30 < _Ch_ >>> 0) { if (25 >= _Ch_ + 127 >>> 0) switch$0 = 1 }
    else
      if (23 !== _Ch_) switch$0 = 1;
    return switch$0 ? c + 32 | 0 : c
  }
  function uppercase(c) {
    var _Cg_ = c - 224 | 0, switch$0 = 0;
    if (30 < _Cg_ >>> 0) { if (25 >= _Cg_ + 127 >>> 0) switch$0 = 1 }
    else
      if (23 !== _Cg_) switch$0 = 1;
    return switch$0 ? c - 32 | 0 : c
  }
  function lowercase_ascii(c) { return 25 < c - 65 >>> 0 ? c : c + 32 | 0 }
  function uppercase_ascii(c) { return 25 < c - 97 >>> 0 ? c : c - 32 | 0 }
  function compare$4(c1, c2) { return c1 - c2 | 0 }
  function equal$4(c1, c2) { return 0 === (c1 - c2 | 0) ? 1 : 0 }
  var
    Stdlib_Char =
      [0,
        chr,
        escaped,
        lowercase,
        uppercase,
        lowercase_ascii,
        uppercase_ascii,
        compare$4,
        equal$4];
  caml_register_global(786, Stdlib_Char, "Stdlib__Char");
  var
    min$0 = 0,
    max$0 = 1114111,
    lo_bound = 55295,
    hi_bound = 57344,
    bom = 65279,
    rep = 65533;
  function succ(u) {
    return u === 55295
      ? hi_bound
      : u === 1114111 ? invalid_arg(err_no_succ) : u + 1 | 0
  }
  function pred(u) { return u === 57344 ? lo_bound : u === 0 ? invalid_arg(err_no_pred) : u - 1 | 0 }
  function is_valid(i) {
    var _Cc_ = 0 <= i ? 1 : 0, _Cd_ = _Cc_ ? i <= 55295 ? 1 : 0 : _Cc_;
    if (_Cd_)
      var _Ce_ = _Cd_;
    else
      var _Cf_ = 57344 <= i ? 1 : 0, _Ce_ = _Cf_ ? i <= 1114111 ? 1 : 0 : _Cf_;
    return _Ce_
  }
  function of_int(i) {
    return is_valid(i)
      ? i
      : invalid_arg
        (cat(caml_format_int(cst_X, i), cst_is_not_an_Unicode_scalar_v))
  }
  function is_char(u) { return u < 256 ? 1 : 0 }
  function of_char(c) { return c }
  function to_char(u) {
    return 255 < u
      ? invalid_arg
        (cat
          (cst_U,
            cat
              (caml_format_int(cst_04X, u), cst_is_not_a_latin1_character)))
      : u
  }
  function unsafe_to_char(_Cb_) { return _Cb_ }
  function equal$5(_Ca_, _B$_) { return _Ca_ === _B$_ ? 1 : 0 }
  var compare$5 = caml_int_compare;
  function hash(_B__) { return _B__ }
  function utf_decode_is_valid(d) { return 1 === (d >>> 27 | 0) ? 1 : 0 }
  function utf_decode_length(d) { return (d >>> 24 | 0) & 7 }
  function utf_decode_uchar(d) { return d & 16777215 }
  function utf_decode(n, u) { return (8 | n) << 24 | u }
  function dec_invalid(n) { return n << 24 | 65533 }
  function utf_8_byte_length(u) {
    if (0 > u) throw [0, Assert_failure, _t_];
    if (127 >= u) return 1;
    if (2047 >= u) return 2;
    if (65535 >= u) return 3;
    if (1114111 < u) throw [0, Assert_failure, _s_];
    return 4
  }
  function utf_16_byte_length(u) {
    if (0 > u) throw [0, Assert_failure, _v_];
    if (65535 >= u) return 2;
    if (1114111 < u) throw [0, Assert_failure, _u_];
    return 4
  }
  function _w_(_B9_) { return _B9_ }
  var
    Stdlib_Uchar =
      [0,
        min$0,
        max$0,
        bom,
        rep,
        succ,
        pred,
        is_valid,
        of_int,
        function (_B8_) { return _B8_ },
        _w_,
        is_char,
        of_char,
        to_char,
        unsafe_to_char,
        equal$5,
        compare$5,
        hash,
        utf_decode_is_valid,
        utf_decode_uchar,
        utf_decode_length,
        utf_decode,
        dec_invalid,
        utf_8_byte_length,
        utf_16_byte_length];
  caml_register_global(787, Stdlib_Uchar, "Stdlib__Uchar");
  function length$1(l) {
    var len = 0, param = l;
    for (; ;) {
      if (!param) return len;
      var param$0 = param[2], len$0 = len + 1 | 0, len = len$0, param = param$0
    }
  }
  function cons$0(a, l) { return [0, a, l] }
  function hd(param) { if (!param) return failwith(cst_hd); var a = param[1]; return a }
  function tl(param) { if (!param) return failwith(cst_tl); var l = param[2]; return l }
  function nth(l, n) {
    if (0 > n) return invalid_arg(cst_List_nth);
    var l$0 = l, n$0 = n;
    for (; ;) {
      if (!l$0) return failwith(cst_nth);
      var l$1 = l$0[2], a = l$0[1];
      if (0 === n$0) return a;
      var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1
    }
  }
  function nth_opt(l, n) {
    if (0 > n) return invalid_arg(cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for (; ;) {
      if (!l$0) return 0;
      var l$1 = l$0[2], a = l$0[1];
      if (0 === n$0) return [0, a];
      var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1
    }
  }
  function rev_append(l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (!l1$0) return l2$0;
      var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0], l1$0 = l1$1, l2$0 = l2$1
    }
  }
  function rev(l) { return rev_append(l, 0) }
  function init_aux$0(i, n, f) {
    if (n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux$0(i + 1 | 0, n, f)]
  }
  function init$0(len, f) {
    if (0 > len) return invalid_arg(cst_List_init);
    if (50 >= len) return init_aux$0(0, len, f);
    var acc = 0, i = 0;
    for (; ;) {
      if (len <= i) return rev(acc);
      var i$0 = i + 1 | 0, acc$0 = [0, caml_call1(f, i), acc], acc = acc$0, i = i$0
    }
  }
  function flatten(param) {
    if (!param) return 0;
    var r = param[2], l = param[1];
    return append(l, flatten(r))
  }
  function map$4(f, param) {
    if (!param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map$4(f, l)]
  }
  function _x_(i, f, param) {
    if (!param) return 0;
    var l = param[2], a = param[1], r = caml_call2(f, i, a);
    return [0, r, _x_(i + 1 | 0, f, l)]
  }
  function mapi$0(f, l) { return _x_(0, f, l) }
  function rev_map(f, param) {
    var accu = 0, param$0 = param;
    for (; ;) {
      if (!param$0) return accu;
      var
        l = param$0[2],
        a = param$0[1],
        accu$0 = [0, caml_call1(f, a), accu],
        accu = accu$0,
        param$0 = l
    }
  }
  function iter$2(f, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], a = param$0[1];
      caml_call1(f, a);
      var param$0 = l
    }
  }
  function iteri$0(f, l$0) {
    var i = 0, param = l$0;
    for (; ;) {
      if (!param) return 0;
      var l = param[2], a = param[1];
      caml_call2(f, i, a);
      var i$0 = i + 1 | 0, i = i$0, param = l
    }
  }
  function fold_left$0(f, accu, l) {
    var accu$0 = accu, l$0 = l;
    for (; ;) {
      if (!l$0) return accu$0;
      var
        l$1 = l$0[2],
        a = l$0[1],
        accu$1 = caml_call2(f, accu$0, a),
        accu$0 = accu$1,
        l$0 = l$1
    }
  }
  function fold_right(f, l, accu) {
    if (!l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu))
  }
  function map2$0(f, l1, l2) {
    if (l1) {
      if (l2) {
        var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1], r = caml_call2(f, a1, a2);
        return [0, r, map2$0(f, l1$0, l2$0)]
      }
    }
    else
      if (!l2) return 0;
    return invalid_arg(cst_List_map2)
  }
  function rev_map2(f, l1, l2) {
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var
          l2$1 = l2$0[2],
          a2 = l2$0[1],
          l1$1 = l1$0[2],
          a1 = l1$0[1],
          accu$0 = [0, caml_call2(f, a1, a2), accu],
          accu = accu$0,
          l1$0 = l1$1,
          l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return accu;
      return invalid_arg(cst_List_rev_map2)
    }
  }
  function iter2$0(f, l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
          caml_call2(f, a1, a2);
          var l1$0 = l1$1, l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return 0;
      return invalid_arg(cst_List_iter2)
    }
  }
  function fold_left2$0(f, accu, l1, l2) {
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var
          l2$1 = l2$0[2],
          a2 = l2$0[1],
          l1$1 = l1$0[2],
          a1 = l1$0[1],
          accu$1 = caml_call3(f, accu$0, a1, a2),
          accu$0 = accu$1,
          l1$0 = l1$1,
          l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return accu$0;
      return invalid_arg(cst_List_fold_left2)
    }
  }
  function fold_right2(f, l1, l2, accu) {
    if (l1) {
      if (l2) {
        var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
        return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu))
      }
    }
    else
      if (!l2) return accu;
    return invalid_arg(cst_List_fold_right2)
  }
  function for_all$0(p, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 1;
      var l = param$0[2], a = param$0[1], _B7_ = caml_call1(p, a);
      if (!_B7_) return _B7_;
      var param$0 = l
    }
  }
  function exists$0(p, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], a = param$0[1], _B6_ = caml_call1(p, a);
      if (_B6_) return _B6_;
      var param$0 = l
    }
  }
  function for_all2$0(p, l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var
          l2$1 = l2$0[2],
          a2 = l2$0[1],
          l1$1 = l1$0[2],
          a1 = l1$0[1],
          _B5_ = caml_call2(p, a1, a2);
          if (!_B5_) return _B5_;
          var l1$0 = l1$1, l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return 1;
      return invalid_arg(cst_List_for_all2)
    }
  }
  function exists2$0(p, l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var
          l2$1 = l2$0[2],
          a2 = l2$0[1],
          l1$1 = l1$0[2],
          a1 = l1$0[1],
          _B4_ = caml_call2(p, a1, a2);
          if (_B4_) return _B4_;
          var l1$0 = l1$1, l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return 0;
      return invalid_arg(cst_List_exists2)
    }
  }
  function mem(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], a = param$0[1], _B3_ = 0 === caml_compare(a, x) ? 1 : 0;
      if (_B3_) return _B3_;
      var param$0 = l
    }
  }
  function memq(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], a = param$0[1], _B2_ = a === x ? 1 : 0;
      if (_B2_) return _B2_;
      var param$0 = l
    }
  }
  function assoc(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) throw Not_found;
      var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
      if (0 === caml_compare(a, x)) return b;
      var param$0 = l
    }
  }
  function assoc_opt(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
      if (0 === caml_compare(a, x)) return [0, b];
      var param$0 = l
    }
  }
  function assq(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) throw Not_found;
      var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
      if (a === x) return b;
      var param$0 = l
    }
  }
  function assq_opt(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
      if (a === x) return [0, b];
      var param$0 = l
    }
  }
  function mem_assoc(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var
        l = param$0[2],
        match = param$0[1],
        a = match[1],
        _B1_ = 0 === caml_compare(a, x) ? 1 : 0;
      if (_B1_) return _B1_;
      var param$0 = l
    }
  }
  function mem_assq(x, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], match = param$0[1], a = match[1], _B0_ = a === x ? 1 : 0;
      if (_B0_) return _B0_;
      var param$0 = l
    }
  }
  function remove_assoc(x, param) {
    if (!param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)]
  }
  function remove_assq(x, param) {
    if (!param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)]
  }
  function find$0(p, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) throw Not_found;
      var l = param$0[2], x = param$0[1];
      if (caml_call1(p, x)) return x;
      var param$0 = l
    }
  }
  function find_opt(p, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], x = param$0[1];
      if (caml_call1(p, x)) return [0, x];
      var param$0 = l
    }
  }
  function find_map$0(f, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
      if (result) return result;
      var param$0 = l
    }
  }
  function find_all(p) {
    var accu = 0;
    return function (param$0) {
      var accu$0 = accu, param = param$0;
      for (; ;) {
        if (!param) return rev(accu$0);
        var l = param[2], x = param[1];
        if (caml_call1(p, x)) { var accu$1 = [0, x, accu$0], accu$0 = accu$1, param = l; continue }
        var param = l
      }
    }
  }
  function filteri(p, param) {
    var i = 0, acc = 0, param$0 = param;
    for (; ;) {
      if (!param$0) return rev(acc);
      var
        l = param$0[2],
        x = param$0[1],
        acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
        i$0 = i + 1 | 0,
        i = i$0,
        acc = acc$0,
        param$0 = l
    }
  }
  function filter_map$0(f) {
    var accu = 0;
    return function (param$0) {
      var accu$0 = accu, param = param$0;
      for (; ;) {
        if (!param) return rev(accu$0);
        var l = param[2], x = param[1], match = caml_call1(f, x);
        if (match) { var v = match[1], accu$1 = [0, v, accu$0], accu$0 = accu$1, param = l; continue }
        var param = l
      }
    }
  }
  function concat_map(f, param) {
    var acc = 0, param$0 = param;
    for (; ;) {
      if (!param$0) return rev(acc);
      var
        l = param$0[2],
        x = param$0[1],
        xs = caml_call1(f, x),
        acc$0 = rev_append(xs, acc),
        acc = acc$0,
        param$0 = l
    }
  }
  function fold_left_map(f, accu, param) {
    var accu$0 = accu, l_accu = 0, param$0 = param;
    for (; ;) {
      if (!param$0) return [0, accu$0, rev(l_accu)];
      var
        l = param$0[2],
        x = param$0[1],
        match = caml_call2(f, accu$0, x),
        x$0 = match[2],
        accu$1 = match[1],
        l_accu$0 = [0, x$0, l_accu],
        accu$0 = accu$1,
        l_accu = l_accu$0,
        param$0 = l
    }
  }
  function partition$0(p, param) {
    var yes = 0, no = 0, param$0 = param;
    for (; ;) {
      if (!param$0) { var _BZ_ = rev(no); return [0, rev(yes), _BZ_] }
      var l = param$0[2], x = param$0[1];
      if (caml_call1(p, x)) { var yes$0 = [0, x, yes], yes = yes$0, param$0 = l; continue }
      var no$0 = [0, x, no], no = no$0, param$0 = l
    }
  }
  function partition_map$0(p, param) {
    var left = 0, right = 0, param$0 = param;
    for (; ;) {
      if (!param$0) { var _BY_ = rev(right); return [0, rev(left), _BY_] }
      var l = param$0[2], x = param$0[1], match = caml_call1(p, x);
      if (0 === match[0]) { var v = match[1], left$0 = [0, v, left], left = left$0, param$0 = l; continue }
      var v$0 = match[1], right$0 = [0, v$0, right], right = right$0, param$0 = l
    }
  }
  function split(param) {
    if (!param) return _y_;
    var
      l = param[2],
      match = param[1],
      y = match[2],
      x = match[1],
      match$0 = split(l),
      ry = match$0[2],
      rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]]
  }
  function combine(l1, l2) {
    if (l1) {
      if (l2) {
        var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
        return [0, [0, a1, a2], combine(l1$0, l2$0)]
      }
    }
    else
      if (!l2) return 0;
    return invalid_arg(cst_List_combine)
  }
  function merge(cmp, l1, l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
      ? [0, h2, merge(cmp, l1, t2)]
      : [0, h1, merge(cmp, t1, l2)]
  }
  function fast_sort(cmp, l) {
    function sort(n, l) {
      if (2 === n) {
        if (l) {
          var _BU_ = l[2];
          if (_BU_) {
            var
            tl = _BU_[2],
            x2 = _BU_[1],
            x1 = l[1],
            s = 0 < caml_call2(cmp, x1, x2) ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
            return [0, s, tl]
          }
        }
      }
      else
        if (3 === n && l) {
          var _BW_ = l[2];
          if (_BW_) {
            var _BX_ = _BW_[2];
            if (_BX_) {
              var
              tl$1 = _BX_[2],
              x3 = _BX_[1],
              x2$0 = _BW_[1],
              x1$0 = l[1],
              s$0 =
                0 < caml_call2(cmp, x1$0, x2$0)
                  ? 0 < caml_call2(cmp, x1$0, x3)
                    ? 0 < caml_call2(cmp, x2$0, x3)
                      ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                      : [0, x2$0, [0, x3, [0, x1$0, 0]]]
                    : [0, x2$0, [0, x1$0, [0, x3, 0]]]
                  : 0 < caml_call2(cmp, x2$0, x3)
                    ? 0 < caml_call2(cmp, x1$0, x3)
                      ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                      : [0, x1$0, [0, x3, [0, x2$0, 0]]]
                    : [0, x1$0, [0, x2$0, [0, x3, 0]]];
              return [0, s$0, tl$1]
            }
          }
        }
      var
        n1 = n >> 1,
        n2 = n - n1 | 0,
        match = rev_sort(n1, l),
        l2$0 = match[2],
        s1 = match[1],
        match$0 = rev_sort(n2, l2$0),
        tl$0 = match$0[2],
        s2 = match$0[1],
        l1 = s1,
        l2 = s2,
        accu = 0;
      for (; ;) {
        if (l1) {
          if (l2) {
            var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
            if (0 < caml_call2(cmp, h1, h2)) { var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0; continue }
            var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
            continue
          }
          var _BV_ = rev_append(l1, accu)
        }
        else
          var _BV_ = rev_append(l2, accu);
        return [0, _BV_, tl$0]
      }
    }
    function rev_sort(n, l) {
      if (2 === n) {
        if (l) {
          var _BQ_ = l[2];
          if (_BQ_) {
            var
            tl = _BQ_[2],
            x2 = _BQ_[1],
            x1 = l[1],
            s = 0 < caml_call2(cmp, x1, x2) ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
            return [0, s, tl]
          }
        }
      }
      else
        if (3 === n && l) {
          var _BS_ = l[2];
          if (_BS_) {
            var _BT_ = _BS_[2];
            if (_BT_) {
              var
              tl$1 = _BT_[2],
              x3 = _BT_[1],
              x2$0 = _BS_[1],
              x1$0 = l[1],
              s$0 =
                0 < caml_call2(cmp, x1$0, x2$0)
                  ? 0 < caml_call2(cmp, x2$0, x3)
                    ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
                    : 0 < caml_call2(cmp, x1$0, x3)
                      ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                      : [0, x3, [0, x1$0, [0, x2$0, 0]]]
                  : 0 < caml_call2(cmp, x1$0, x3)
                    ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
                    : 0 < caml_call2(cmp, x2$0, x3)
                      ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                      : [0, x3, [0, x2$0, [0, x1$0, 0]]];
              return [0, s$0, tl$1]
            }
          }
        }
      var
        n1 = n >> 1,
        n2 = n - n1 | 0,
        match = sort(n1, l),
        l2$0 = match[2],
        s1 = match[1],
        match$0 = sort(n2, l2$0),
        tl$0 = match$0[2],
        s2 = match$0[1],
        l1 = s1,
        l2 = s2,
        accu = 0;
      for (; ;) {
        if (l1) {
          if (l2) {
            var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
            if (0 < caml_call2(cmp, h1, h2)) { var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0; continue }
            var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
            continue
          }
          var _BR_ = rev_append(l1, accu)
        }
        else
          var _BR_ = rev_append(l2, accu);
        return [0, _BR_, tl$0]
      }
    }
    var len = length$1(l);
    return 2 <= len ? sort(len, l)[1] : l
  }
  function sort_uniq(cmp, l) {
    function sort(n, l) {
      if (2 === n) {
        if (l) {
          var _BH_ = l[2];
          if (_BH_) {
            var
            tl = _BH_[2],
            x2 = _BH_[1],
            x1 = l[1],
            c$0 = caml_call2(cmp, x1, x2),
            s = 0 === c$0 ? [0, x1, 0] : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
            return [0, s, tl]
          }
        }
      }
      else
        if (3 === n && l) {
          var _BJ_ = l[2];
          if (_BJ_) {
            var _BK_ = _BJ_[2];
            if (_BK_) {
              var
              tl$1 = _BK_[2],
              x3 = _BK_[1],
              x2$0 = _BJ_[1],
              x1$0 = l[1],
              c$1 = caml_call2(cmp, x1$0, x2$0);
              if (0 === c$1)
                var
                  c$2 = caml_call2(cmp, x2$0, x3),
                  _BL_ =
                    0 === c$2
                      ? [0, x2$0, 0]
                      : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
                  s$0 = _BL_;
              else
                if (0 <= c$1) {
                  var c$3 = caml_call2(cmp, x1$0, x3);
                  if (0 === c$3)
                    var _BM_ = [0, x2$0, [0, x1$0, 0]];
                  else
                    if (0 <= c$3)
                      var
                        c$4 = caml_call2(cmp, x2$0, x3),
                        _BN_ =
                          0 === c$4
                            ? [0, x2$0, [0, x1$0, 0]]
                            : 0 <= c$4
                              ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                              : [0, x2$0, [0, x3, [0, x1$0, 0]]],
                        _BM_ = _BN_;
                    else
                      var _BM_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
                  var s$0 = _BM_
                }
                else {
                  var c$5 = caml_call2(cmp, x2$0, x3);
                  if (0 === c$5)
                    var _BO_ = [0, x1$0, [0, x2$0, 0]];
                  else
                    if (0 <= c$5)
                      var
                        c$6 = caml_call2(cmp, x1$0, x3),
                        _BP_ =
                          0 === c$6
                            ? [0, x1$0, [0, x2$0, 0]]
                            : 0 <= c$6
                              ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                              : [0, x1$0, [0, x3, [0, x2$0, 0]]],
                        _BO_ = _BP_;
                    else
                      var _BO_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
                  var s$0 = _BO_
                }
              return [0, s$0, tl$1]
            }
          }
        }
      var
        n1 = n >> 1,
        n2 = n - n1 | 0,
        match = rev_sort(n1, l),
        l2$0 = match[2],
        s1 = match[1],
        match$0 = rev_sort(n2, l2$0),
        tl$0 = match$0[2],
        s2 = match$0[1],
        l1 = s1,
        l2 = s2,
        accu = 0;
      for (; ;) {
        if (l1) {
          if (l2) {
            var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1], c = caml_call2(cmp, h1, h2);
            if (0 === c) { var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0; continue }
            if (0 < c) { var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1; continue }
            var accu$2 = [0, h2, accu], l2 = t2, accu = accu$2;
            continue
          }
          var _BI_ = rev_append(l1, accu)
        }
        else
          var _BI_ = rev_append(l2, accu);
        return [0, _BI_, tl$0]
      }
    }
    function rev_sort(n, l) {
      if (2 === n) {
        if (l) {
          var _By_ = l[2];
          if (_By_) {
            var
            tl = _By_[2],
            x2 = _By_[1],
            x1 = l[1],
            c$0 = caml_call2(cmp, x1, x2),
            s = 0 === c$0 ? [0, x1, 0] : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
            return [0, s, tl]
          }
        }
      }
      else
        if (3 === n && l) {
          var _BA_ = l[2];
          if (_BA_) {
            var _BB_ = _BA_[2];
            if (_BB_) {
              var
              tl$1 = _BB_[2],
              x3 = _BB_[1],
              x2$0 = _BA_[1],
              x1$0 = l[1],
              c$1 = caml_call2(cmp, x1$0, x2$0);
              if (0 === c$1)
                var
                  c$2 = caml_call2(cmp, x2$0, x3),
                  _BC_ =
                    0 === c$2
                      ? [0, x2$0, 0]
                      : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
                  s$0 = _BC_;
              else
                if (0 < c$1) {
                  var c$3 = caml_call2(cmp, x2$0, x3);
                  if (0 === c$3)
                    var _BD_ = [0, x1$0, [0, x2$0, 0]];
                  else
                    if (0 < c$3)
                      var _BD_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
                    else
                      var
                        c$4 = caml_call2(cmp, x1$0, x3),
                        _BE_ =
                          0 === c$4
                            ? [0, x1$0, [0, x2$0, 0]]
                            : 0 < c$4
                              ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                              : [0, x3, [0, x1$0, [0, x2$0, 0]]],
                        _BD_ = _BE_;
                  var s$0 = _BD_
                }
                else {
                  var c$5 = caml_call2(cmp, x1$0, x3);
                  if (0 === c$5)
                    var _BF_ = [0, x2$0, [0, x1$0, 0]];
                  else
                    if (0 < c$5)
                      var _BF_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
                    else
                      var
                        c$6 = caml_call2(cmp, x2$0, x3),
                        _BG_ =
                          0 === c$6
                            ? [0, x2$0, [0, x1$0, 0]]
                            : 0 < c$6
                              ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                              : [0, x3, [0, x2$0, [0, x1$0, 0]]],
                        _BF_ = _BG_;
                  var s$0 = _BF_
                }
              return [0, s$0, tl$1]
            }
          }
        }
      var
        n1 = n >> 1,
        n2 = n - n1 | 0,
        match = sort(n1, l),
        l2$0 = match[2],
        s1 = match[1],
        match$0 = sort(n2, l2$0),
        tl$0 = match$0[2],
        s2 = match$0[1],
        l1 = s1,
        l2 = s2,
        accu = 0;
      for (; ;) {
        if (l1) {
          if (l2) {
            var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1], c = caml_call2(cmp, h1, h2);
            if (0 === c) { var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0; continue }
            if (0 <= c) { var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1; continue }
            var accu$2 = [0, h1, accu], l1 = t1, accu = accu$2;
            continue
          }
          var _Bz_ = rev_append(l1, accu)
        }
        else
          var _Bz_ = rev_append(l2, accu);
        return [0, _Bz_, tl$0]
      }
    }
    var len = length$1(l);
    return 2 <= len ? sort(len, l)[1] : l
  }
  function compare_lengths(l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (!l1$0) return l2$0 ? -1 : 0;
      if (!l2$0) return 1;
      var l2$1 = l2$0[2], l1$1 = l1$0[2], l1$0 = l1$1, l2$0 = l2$1
    }
  }
  function compare_length_with(l, n) {
    var l$0 = l, n$0 = n;
    for (; ;) {
      if (!l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
      var l$1 = l$0[2];
      if (0 >= n$0) return 1;
      var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1
    }
  }
  function equal$6(eq, l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (l1$0) {
        if (l2$0) {
          var
          l2$1 = l2$0[2],
          a2 = l2$0[1],
          l1$1 = l1$0[2],
          a1 = l1$0[1],
          _Bx_ = caml_call2(eq, a1, a2);
          if (!_Bx_) return _Bx_;
          var l1$0 = l1$1, l2$0 = l2$1;
          continue
        }
      }
      else
        if (!l2$0) return 1;
      return 0
    }
  }
  function compare$6(cmp, l1, l2) {
    var l1$0 = l1, l2$0 = l2;
    for (; ;) {
      if (!l1$0) return l2$0 ? -1 : 0;
      var _Bv_ = l1$0[2], _Bw_ = l1$0[1];
      if (!l2$0) return 1;
      var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, _Bw_, a2);
      if (0 !== c) return c;
      var l1$0 = _Bv_, l2$0 = l2$1
    }
  }
  function to_seq$1(l) {
    function aux(l, param) {
      if (!l) return 0;
      var tail = l[2], x = l[1];
      return [0, x, function (_Bu_) { return aux(tail, _Bu_) }]
    }
    return function (_Bt_) { return aux(l, _Bt_) }
  }
  function of_seq(seq) {
    function direct(depth, seq) {
      if (0 === depth) {
        var _Bs_ = 0;
        return rev(fold_left(function (acc, x) { return [0, x, acc] }, _Bs_, seq))
      }
      var match = caml_call1(seq, 0);
      if (!match) return 0;
      var next = match[2], x = match[1];
      return [0, x, direct(depth - 1 | 0, next)]
    }
    return direct(500, seq)
  }
  var
    include$0 =
      [0,
        length$1,
        compare_lengths,
        compare_length_with,
        cons$0,
        hd,
        tl,
        nth,
        nth_opt,
        rev,
        init$0,
        append,
        rev_append,
        flatten,
        flatten,
        equal$6,
        compare$6,
        iter$2,
        iteri$0,
        map$4,
        mapi$0,
        rev_map,
        filter_map$0,
        concat_map,
        fold_left_map,
        fold_left$0,
        fold_right,
        iter2$0,
        map2$0,
        rev_map2,
        fold_left2$0,
        fold_right2,
        for_all$0,
        exists$0,
        for_all2$0,
        exists2$0,
        mem,
        memq,
        find$0,
        find_opt,
        find_map$0,
        find_all,
        find_all,
        filteri,
        partition$0,
        partition_map$0,
        assoc,
        assoc_opt,
        assq,
        assq_opt,
        mem_assoc,
        mem_assq,
        remove_assoc,
        remove_assq,
        split,
        combine,
        fast_sort,
        fast_sort,
        fast_sort,
        sort_uniq,
        merge,
        to_seq$1,
        of_seq];
  caml_register_global(788, include$0, "Stdlib__List");
  var zero = 0, one = 1, minus_one = -1;
  function abs$0(x) { return 0 <= x ? x : - x | 0 }
  var max_int$0 = 2147483647, min_int$0 = -2147483648;
  function lognot(x) { return x ^ -1 }
  function equal$7(_Br_, _Bq_) { return _Br_ === _Bq_ ? 1 : 0 }
  var compare$7 = caml_int_compare;
  function min$1(x, y) { return x <= y ? x : y }
  function max$1(x, y) { return y <= x ? x : y }
  function to_string$1(x) { return caml_string_of_jsbytes("" + x) }
  var
    Stdlib_Int =
      [0,
        zero,
        one,
        minus_one,
        abs$0,
        max_int$0,
        min_int$0,
        lognot,
        equal$7,
        compare$7,
        min$1,
        max$1,
        to_string$1];
  caml_register_global(789, Stdlib_Int, "Stdlib__Int");
  function make$0(n, c) { var s = caml_create_bytes(n); caml_fill_bytes(s, 0, n, c); return s }
  function init$1(n, f) {
    var s = caml_create_bytes(n), _Bo_ = n - 1 | 0, _Bn_ = 0;
    if (_Bo_ >= 0) {
      var i = _Bn_;
      for (; ;) {
        caml_bytes_unsafe_set(s, i, caml_call1(f, i));
        var _Bp_ = i + 1 | 0;
        if (_Bo_ !== i) { var i = _Bp_; continue }
        break
      }
    }
    return s
  }
  var empty$0 = caml_create_bytes(0);
  function copy(s) {
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r
  }
  function of_bytes(b) { return caml_string_of_bytes(copy(b)) }
  function to_bytes(s) { return copy(caml_bytes_of_string(s)) }
  function sub(s, ofs, len) {
    if (0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs) { var r = caml_create_bytes(len); caml_blit_bytes(s, ofs, r, 0, len); return r }
    return invalid_arg(cst_String_sub_Bytes_sub)
  }
  function sub_string(b, ofs, len) { return caml_string_of_bytes(sub(b, ofs, len)) }
  function symbol$0(a, b) {
    var c = a + b | 0, _Bm_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0, switch$0 = 0;
    if (a < 0) { if (_Bm_ && !match) switch$0 = 1 }
    else
      if (!_Bm_ && match) switch$0 = 1;
    return switch$0 ? invalid_arg(cst_Bytes_extend) : c
  }
  function extend(s, left, right) {
    var
    len = symbol$0(symbol$0(caml_ml_bytes_length(s), left), right),
    r = caml_create_bytes(len);
    if (0 <= left)
      var dstoff = left, srcoff = 0;
    else
      var dstoff = 0, srcoff = - left | 0;
    var cpylen = min$1(caml_ml_bytes_length(s) - srcoff | 0, len - dstoff | 0);
    if (0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r
  }
  function fill(s, ofs, len, c) {
    if (0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
      return caml_fill_bytes(s, ofs, len, c);
    return invalid_arg(cst_String_fill_Bytes_fill)
  }
  function blit(s1, ofs1, s2, ofs2, len) {
    if
      (0
      <=
      len
      &&
      0
      <=
      ofs1
      &&
      (caml_ml_bytes_length(s1) - len | 0)
      >=
      ofs1
      &&
      0
      <=
      ofs2
      &&
      (caml_ml_bytes_length(s2) - len | 0)
      >=
      ofs2)
      return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return invalid_arg(cst_Bytes_blit)
  }
  function blit$0(s1, ofs1, s2, ofs2, len) {
    if
      (0
      <=
      len
      &&
      0
      <=
      ofs1
      &&
      (caml_ml_string_length(s1) - len | 0)
      >=
      ofs1
      &&
      0
      <=
      ofs2
      &&
      (caml_ml_bytes_length(s2) - len | 0)
      >=
      ofs2)
      return caml_blit_string(s1, ofs1, s2, ofs2, len);
    return invalid_arg(cst_String_blit_Bytes_blit_str)
  }
  function iter$3(f, a) {
    var _Bk_ = caml_ml_bytes_length(a) - 1 | 0, _Bj_ = 0;
    if (_Bk_ >= 0) {
      var i = _Bj_;
      for (; ;) {
        caml_call1(f, caml_bytes_unsafe_get(a, i));
        var _Bl_ = i + 1 | 0;
        if (_Bk_ !== i) { var i = _Bl_; continue }
        break
      }
    }
    return 0
  }
  function iteri$1(f, a) {
    var _Bh_ = caml_ml_bytes_length(a) - 1 | 0, _Bg_ = 0;
    if (_Bh_ >= 0) {
      var i = _Bg_;
      for (; ;) {
        caml_call2(f, i, caml_bytes_unsafe_get(a, i));
        var _Bi_ = i + 1 | 0;
        if (_Bh_ !== i) { var i = _Bi_; continue }
        break
      }
    }
    return 0
  }
  function concat$0(sep, l) {
    if (!l) return empty$0;
    var seplen = caml_ml_bytes_length(sep), acc = 0, param = l, pos$1 = 0;
    for (; ;) {
      if (param) {
        var _Bd_ = param[1];
        if (param[2]) {
          var
          tl = param[2],
          x = (caml_ml_bytes_length(_Bd_) + seplen | 0) + acc | 0,
          acc$0 = acc <= x ? x : invalid_arg(cst_Bytes_concat),
          acc = acc$0,
          param = tl;
          continue
        }
        var _Bf_ = caml_ml_bytes_length(_Bd_) + acc | 0
      }
      else
        var _Bf_ = acc;
      var dst = caml_create_bytes(_Bf_), pos = pos$1, param$0 = l;
      for (; ;) {
        if (!param$0) return dst;
        var _Be_ = param$0[1];
        if (param$0[2]) {
          var tl$0 = param$0[2];
          caml_blit_bytes(_Be_, 0, dst, pos, caml_ml_bytes_length(_Be_));
          caml_blit_bytes
            (sep, 0, dst, pos + caml_ml_bytes_length(_Be_) | 0, seplen);
          var
            pos$0 = (pos + caml_ml_bytes_length(_Be_) | 0) + seplen | 0,
            pos = pos$0,
            param$0 = tl$0;
          continue
        }
        caml_blit_bytes(_Be_, 0, dst, pos, caml_ml_bytes_length(_Be_));
        return dst
      }
    }
  }
  function cat$0(s1, s2) {
    var
    l1 = caml_ml_bytes_length(s1),
    l2 = caml_ml_bytes_length(s2),
    r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r
  }
  function is_space(param) {
    var _Bc_ = param - 9 | 0, switch$0 = 0;
    if (4 < _Bc_ >>> 0) { if (23 === _Bc_) switch$0 = 1 }
    else
      if (2 !== _Bc_) switch$0 = 1;
    return switch$0 ? 1 : 0
  }
  function trim(s) {
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for (; ;) {
      if (i[1] < len && is_space(caml_bytes_unsafe_get(s, i[1]))) { i[1]++; continue }
      var j = [0, len - 1 | 0];
      for (; ;) {
        if (i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))) { j[1] += -1; continue }
        return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty$0
      }
    }
  }
  function escaped$0(s) {
    var n = [0, 0], _A7_ = caml_ml_bytes_length(s) - 1 | 0, _A6_ = 0;
    if (_A7_ >= 0) {
      var i$0 = _A6_;
      for (; ;) {
        var match = caml_bytes_unsafe_get(s, i$0), switch$0 = 0;
        if (32 <= match) {
          var _A$_ = match - 34 | 0, switch$1 = 0;
          if (58 < _A$_ >>> 0) { if (93 <= _A$_) switch$1 = 1 }
          else
            if (56 < _A$_ - 1 >>> 0) { switch$0 = 1; switch$1 = 1 }
          if (!switch$1) { var _Ba_ = 1; switch$0 = 2 }
        }
        else
          if (11 <= match) { if (13 === match) switch$0 = 1 }
          else
            if (8 <= match) switch$0 = 1;
        switch (switch$0) { case 0: var _Ba_ = 4; break; case 1: var _Ba_ = 2; break }
        n[1] = n[1] + _Ba_ | 0;
        var _Bb_ = i$0 + 1 | 0;
        if (_A7_ !== i$0) { var i$0 = _Bb_; continue }
        break
      }
    }
    if (n[1] === caml_ml_bytes_length(s)) return copy(s);
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _A9_ = caml_ml_bytes_length(s) - 1 | 0, _A8_ = 0;
    if (_A9_ >= 0) {
      var i = _A8_;
      for (; ;) {
        var c = caml_bytes_unsafe_get(s, i), switch$2 = 0;
        if (35 <= c)
          if (92 === c)
            switch$2 = 2;
          else
            if (127 <= c) switch$2 = 1; else switch$2 = 3;
        else
          if (32 <= c)
            if (34 <= c) switch$2 = 2; else switch$2 = 3;
          else
            if (14 <= c)
              switch$2 = 1;
            else
              switch (c) {
                case 8:
                  caml_bytes_unsafe_set(s$0, n[1], 92);
                  n[1]++;
                  caml_bytes_unsafe_set(s$0, n[1], 98);
                  break;
                case 9:
                  caml_bytes_unsafe_set(s$0, n[1], 92);
                  n[1]++;
                  caml_bytes_unsafe_set(s$0, n[1], 116);
                  break;
                case 10:
                  caml_bytes_unsafe_set(s$0, n[1], 92);
                  n[1]++;
                  caml_bytes_unsafe_set(s$0, n[1], 110);
                  break;
                case 13:
                  caml_bytes_unsafe_set(s$0, n[1], 92);
                  n[1]++;
                  caml_bytes_unsafe_set(s$0, n[1], 114);
                  break;
                default: switch$2 = 1
              }
        switch (switch$2) {
          case 1:
            caml_bytes_unsafe_set(s$0, n[1], 92);
            n[1]++;
            caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
            n[1]++;
            caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
            n[1]++;
            caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
            break;
          case 2:
            caml_bytes_unsafe_set(s$0, n[1], 92);
            n[1]++;
            caml_bytes_unsafe_set(s$0, n[1], c);
            break;
          case 3: caml_bytes_unsafe_set(s$0, n[1], c); break
        }
        n[1]++;
        var _A__ = i + 1 | 0;
        if (_A9_ !== i) { var i = _A__; continue }
        break
      }
    }
    return s$0
  }
  function map$5(f, s) {
    var l = caml_ml_bytes_length(s);
    if (0 === l) return s;
    var r = caml_create_bytes(l), _A4_ = l - 1 | 0, _A3_ = 0;
    if (_A4_ >= 0) {
      var i = _A3_;
      for (; ;) {
        caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
        var _A5_ = i + 1 | 0;
        if (_A4_ !== i) { var i = _A5_; continue }
        break
      }
    }
    return r
  }
  function mapi$1(f, s) {
    var l = caml_ml_bytes_length(s);
    if (0 === l) return s;
    var r = caml_create_bytes(l), _A1_ = l - 1 | 0, _A0_ = 0;
    if (_A1_ >= 0) {
      var i = _A0_;
      for (; ;) {
        caml_bytes_unsafe_set
          (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
        var _A2_ = i + 1 | 0;
        if (_A1_ !== i) { var i = _A2_; continue }
        break
      }
    }
    return r
  }
  function fold_left$1(f, x, a) {
    var r = [0, x], _AY_ = caml_ml_bytes_length(a) - 1 | 0, _AX_ = 0;
    if (_AY_ >= 0) {
      var i = _AX_;
      for (; ;) {
        r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
        var _AZ_ = i + 1 | 0;
        if (_AY_ !== i) { var i = _AZ_; continue }
        break
      }
    }
    return r[1]
  }
  function fold_right$0(f, a, x) {
    var r = [0, x], _AV_ = caml_ml_bytes_length(a) - 1 | 0;
    if (_AV_ >= 0) {
      var i = _AV_;
      for (; ;) {
        r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
        var _AW_ = i - 1 | 0;
        if (0 !== i) { var i = _AW_; continue }
        break
      }
    }
    return r[1]
  }
  function exists$1(p, s) {
    var n = caml_ml_bytes_length(s), i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function for_all$1(p, s) {
    var n = caml_ml_bytes_length(s), i = 0;
    for (; ;) {
      if (i === n) return 1;
      if (!caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function uppercase_ascii$0(s) { return map$5(uppercase_ascii, s) }
  function lowercase_ascii$0(s) { return map$5(lowercase_ascii, s) }
  function apply1(f, s) {
    if (0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r
  }
  function capitalize_ascii(s) { return apply1(uppercase_ascii, s) }
  function uncapitalize_ascii(s) { return apply1(lowercase_ascii, s) }
  function starts_with(prefix, s) {
    var
    len_s = caml_ml_bytes_length(s),
    len_pre = caml_ml_bytes_length(prefix),
    _AU_ = len_pre <= len_s ? 1 : 0;
    if (!_AU_) return _AU_;
    var i = 0;
    for (; ;) {
      if (i === len_pre) return 1;
      if (caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
        return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function ends_with(suffix, s) {
    var
    len_s = caml_ml_bytes_length(s),
    len_suf = caml_ml_bytes_length(suffix),
    diff = len_s - len_suf | 0,
    _AT_ = 0 <= diff ? 1 : 0;
    if (!_AT_) return _AT_;
    var i = 0;
    for (; ;) {
      if (i === len_suf) return 1;
      if
        (caml_bytes_unsafe_get(s, diff + i | 0)
        !==
        caml_bytes_unsafe_get(suffix, i))
        return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function index_rec(s, lim, i, c) {
    var i$0 = i;
    for (; ;) {
      if (lim <= i$0) throw Not_found;
      if (caml_bytes_unsafe_get(s, i$0) === c) return i$0;
      var i$1 = i$0 + 1 | 0, i$0 = i$1
    }
  }
  function index(s, c) { return index_rec(s, caml_ml_bytes_length(s), 0, c) }
  function index_rec_opt(s, lim, i, c) {
    var i$0 = i;
    for (; ;) {
      if (lim <= i$0) return 0;
      if (caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
      var i$1 = i$0 + 1 | 0, i$0 = i$1
    }
  }
  function index_opt(s, c) { return index_rec_opt(s, caml_ml_bytes_length(s), 0, c) }
  function index_from(s, i, c) {
    var l = caml_ml_bytes_length(s);
    if (0 <= i && l >= i) return index_rec(s, l, i, c);
    return invalid_arg(cst_String_index_from_Bytes_in)
  }
  function index_from_opt(s, i, c) {
    var l = caml_ml_bytes_length(s);
    if (0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return invalid_arg(cst_String_index_from_opt_Byte)
  }
  function rindex_rec(s, i, c) {
    var i$0 = i;
    for (; ;) {
      if (0 > i$0) throw Not_found;
      if (caml_bytes_unsafe_get(s, i$0) === c) return i$0;
      var i$1 = i$0 - 1 | 0, i$0 = i$1
    }
  }
  function rindex(s, c) { return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c) }
  function rindex_from(s, i, c) {
    if (-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return invalid_arg(cst_String_rindex_from_Bytes_r)
  }
  function rindex_rec_opt(s, i, c) {
    var i$0 = i;
    for (; ;) {
      if (0 > i$0) return 0;
      if (caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
      var i$1 = i$0 - 1 | 0, i$0 = i$1
    }
  }
  function rindex_opt(s, c) { return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c) }
  function rindex_from_opt(s, i, c) {
    if (-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return invalid_arg(cst_String_rindex_from_opt_Byt)
  }
  function contains_from(s, i, c) {
    var l = caml_ml_bytes_length(s);
    if (0 <= i && l >= i)
      try { index_rec(s, l, i, c); var _AR_ = 1; return _AR_ }
      catch (_AS_) {
        _AS_ = caml_wrap_exception(_AS_);
        if (_AS_ === Not_found) return 0;
        throw _AS_
      }
    return invalid_arg(cst_String_contains_from_Bytes)
  }
  function contains(s, c) { return contains_from(s, 0, c) }
  function rcontains_from(s, i, c) {
    if (0 <= i && caml_ml_bytes_length(s) > i)
      try { rindex_rec(s, i, c); var _AP_ = 1; return _AP_ }
      catch (_AQ_) {
        _AQ_ = caml_wrap_exception(_AQ_);
        if (_AQ_ === Not_found) return 0;
        throw _AQ_
      }
    return invalid_arg(cst_String_rcontains_from_Byte)
  }
  function compare$8(x, y) { return runtime.caml_bytes_compare(x, y) }
  function split_on_char(sep, s) {
    var
    r = [0, 0],
    j = [0, caml_ml_bytes_length(s)],
    _AL_ = caml_ml_bytes_length(s) - 1 | 0;
    if (_AL_ >= 0) {
      var i = _AL_;
      for (; ;) {
        if (caml_bytes_unsafe_get(s, i) === sep) {
          var _AN_ = r[1];
          r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _AN_];
          j[1] = i
        }
        var _AO_ = i - 1 | 0;
        if (0 !== i) { var i = _AO_; continue }
        break
      }
    }
    var _AM_ = r[1];
    return [0, sub(s, 0, j[1]), _AM_]
  }
  function uppercase$0(s) { return map$5(uppercase, s) }
  function lowercase$0(s) { return map$5(lowercase, s) }
  function capitalize(s) { return apply1(uppercase, s) }
  function uncapitalize(s) { return apply1(lowercase, s) }
  function to_seq$2(s) {
    function aux(i, param) {
      if (i === caml_ml_bytes_length(s)) return 0;
      var x = caml_bytes_get(s, i), _AJ_ = i + 1 | 0;
      return [0, x, function (_AK_) { return aux(_AJ_, _AK_) }]
    }
    var _AH_ = 0;
    return function (_AI_) { return aux(_AH_, _AI_) }
  }
  function to_seqi(s) {
    function aux(i, param) {
      if (i === caml_ml_bytes_length(s)) return 0;
      var x = caml_bytes_get(s, i), _AF_ = i + 1 | 0;
      return [0, [0, i, x], function (_AG_) { return aux(_AF_, _AG_) }]
    }
    var _AD_ = 0;
    return function (_AE_) { return aux(_AD_, _AE_) }
  }
  function of_seq$0(i) {
    var n = [0, 0], buf = [0, make$0(256, 0)];
    iter
      (function (c) {
        if (n[1] === caml_ml_bytes_length(buf[1])) {
          var
          new_len =
            min$1(2 * caml_ml_bytes_length(buf[1]) | 0, max_string_length);
          if (caml_ml_bytes_length(buf[1]) === new_len)
            failwith(cst_Bytes_of_seq_cannot_grow_b);
          var new_buf = make$0(new_len, 0);
          blit(buf[1], 0, new_buf, 0, n[1]);
          buf[1] = new_buf
        }
        caml_bytes_set(buf[1], n[1], c);
        n[1]++;
        return 0
      },
        i);
    return sub(buf[1], 0, n[1])
  }
  function get$1(b, i) { return caml_bswap16(caml_bytes_get16(b, i)) }
  function get_int8(b, i) { return caml_bytes_get(b, i) << 24 >> 24 }
  function get_uint16_le(b, i) { return caml_bytes_get16(b, i) }
  function get_uint16_be(b, i) { return caml_bswap16(caml_bytes_get16(b, i)) }
  function get_int16_ne(b, i) { return caml_bytes_get16(b, i) << 16 >> 16 }
  function get_int16_le(b, i) { return caml_bytes_get16(b, i) << 16 >> 16 }
  function get_int16_be(b, i) { return get_uint16_be(b, i) << 16 >> 16 }
  function get_int32_le(b, i) { return caml_bytes_get32(b, i) }
  function get_int32_be(b, i) { return caml_int32_bswap(caml_bytes_get32(b, i)) }
  function get_int64_le(b, i) { return caml_bytes_get64(b, i) }
  function get_int64_be(b, i) { return caml_int64_bswap(caml_bytes_get64(b, i)) }
  function set$0(b, i, x) { return caml_bytes_set16(b, i, caml_bswap16(x)) }
  function set_int16_le(b, i, x) { return caml_bytes_set16(b, i, x) }
  function set_int16_be(b, i, x) { return caml_bytes_set16(b, i, caml_bswap16(x)) }
  function set_int32_le(b, i, x) { return caml_bytes_set32(b, i, x) }
  function set_int32_be(b, i, x) { return caml_bytes_set32(b, i, caml_int32_bswap(x)) }
  function set_int64_le(b, i, x) { return caml_bytes_set64(b, i, x) }
  function set_int64_be(b, i, x) { return caml_bytes_set64(b, i, caml_int64_bswap(x)) }
  var set_uint8 = caml_bytes_set, set_uint16_ne = caml_bytes_set16;
  function dec_ret(n, u) { return utf_decode(n, u) }
  function not_in_x80_to_xBF(b) { return 2 !== (b >>> 6 | 0) ? 1 : 0 }
  function not_in_xA0_to_xBF(b) { return 5 !== (b >>> 5 | 0) ? 1 : 0 }
  function not_in_x80_to_x9F(b) { return 4 !== (b >>> 5 | 0) ? 1 : 0 }
  function not_in_x90_to_xBF(b) { var _AB_ = b < 144 ? 1 : 0, _AC_ = _AB_ || (191 < b ? 1 : 0); return _AC_ }
  function not_in_x80_to_x8F(b) { return 8 !== (b >>> 4 | 0) ? 1 : 0 }
  function utf_8_uchar_3(b0, b1, b2) { return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63 }
  function utf_8_uchar_4(b0, b1, b2, b3) { return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63 }
  function get_utf_8_uchar(b, i) {
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    if (224 <= b0) {
      var switch$0 = 0;
      if (237 <= b0) {
        if (245 > b0)
          switch (b0 - 237 | 0) {
            case 0:
              var i$0 = i + 1 | 0;
              if (max < i$0) return dec_invalid(1);
              var b1 = caml_bytes_unsafe_get(b, i$0);
              if (not_in_x80_to_x9F(b1)) return dec_invalid(1);
              var i$1 = i$0 + 1 | 0;
              if (max < i$1) return dec_invalid(2);
              var b2 = caml_bytes_unsafe_get(b, i$1);
              return not_in_x80_to_xBF(b2)
                ? dec_invalid(2)
                : dec_ret(3, utf_8_uchar_3(b0, b1, b2));
            case 3:
              var i$4 = i + 1 | 0;
              if (max < i$4) return dec_invalid(1);
              var b1$1 = caml_bytes_unsafe_get(b, i$4);
              if (not_in_x90_to_xBF(b1$1)) return dec_invalid(1);
              var i$5 = i$4 + 1 | 0;
              if (max < i$5) return dec_invalid(2);
              var b2$1 = caml_bytes_unsafe_get(b, i$5);
              if (not_in_x80_to_xBF(b2$1)) return dec_invalid(2);
              var i$6 = i$5 + 1 | 0;
              if (max < i$6) return dec_invalid(3);
              var b3 = caml_bytes_unsafe_get(b, i$6);
              return not_in_x80_to_xBF(b3)
                ? dec_invalid(3)
                : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$1, b3));
            case 7:
              var i$10 = i + 1 | 0;
              if (max < i$10) return dec_invalid(1);
              var b1$3 = caml_bytes_unsafe_get(b, i$10);
              if (not_in_x80_to_x8F(b1$3)) return dec_invalid(1);
              var i$11 = i$10 + 1 | 0;
              if (max < i$11) return dec_invalid(2);
              var b2$3 = caml_bytes_unsafe_get(b, i$11);
              if (not_in_x80_to_xBF(b2$3)) return dec_invalid(2);
              var i$12 = i$11 + 1 | 0;
              if (max < i$12) return dec_invalid(3);
              var b3$1 = caml_bytes_unsafe_get(b, i$12);
              return not_in_x80_to_xBF(b3$1)
                ? dec_invalid(3)
                : dec_ret(4, utf_8_uchar_4(b0, b1$3, b2$3, b3$1));
            case 1:
            case 2: switch$0 = 1; break;
            default:
              var i$7 = i + 1 | 0;
              if (max < i$7) return dec_invalid(1);
              var b1$2 = caml_bytes_unsafe_get(b, i$7);
              if (not_in_x80_to_xBF(b1$2)) return dec_invalid(1);
              var i$8 = i$7 + 1 | 0;
              if (max < i$8) return dec_invalid(2);
              var b2$2 = caml_bytes_unsafe_get(b, i$8);
              if (not_in_x80_to_xBF(b2$2)) return dec_invalid(2);
              var i$9 = i$8 + 1 | 0;
              if (max < i$9) return dec_invalid(3);
              var b3$0 = caml_bytes_unsafe_get(b, i$9);
              return not_in_x80_to_xBF(b3$0)
                ? dec_invalid(3)
                : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$2, b3$0))
          }
      }
      else {
        if (225 > b0) {
          var i$13 = i + 1 | 0;
          if (max < i$13) return dec_invalid(1);
          var b1$4 = caml_bytes_unsafe_get(b, i$13);
          if (not_in_xA0_to_xBF(b1$4)) return dec_invalid(1);
          var i$14 = i$13 + 1 | 0;
          if (max < i$14) return dec_invalid(2);
          var b2$4 = caml_bytes_unsafe_get(b, i$14);
          return not_in_x80_to_xBF(b2$4)
            ? dec_invalid(2)
            : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$4))
        }
        switch$0 = 1
      }
      if (switch$0) {
        var i$2 = i + 1 | 0;
        if (max < i$2) return dec_invalid(1);
        var b1$0 = caml_bytes_unsafe_get(b, i$2);
        if (not_in_x80_to_xBF(b1$0)) return dec_invalid(1);
        var i$3 = i$2 + 1 | 0;
        if (max < i$3) return dec_invalid(2);
        var b2$0 = caml_bytes_unsafe_get(b, i$3);
        return not_in_x80_to_xBF(b2$0)
          ? dec_invalid(2)
          : dec_ret(3, utf_8_uchar_3(b0, b1$0, b2$0))
      }
    }
    else {
      if (128 > b0) return dec_ret(1, b0);
      if (194 <= b0) {
        var i$15 = i + 1 | 0;
        if (max < i$15) return dec_invalid(1);
        var b1$5 = caml_bytes_unsafe_get(b, i$15);
        return not_in_x80_to_xBF(b1$5)
          ? dec_invalid(1)
          : dec_ret(2, (b0 & 31) << 6 | b1$5 & 63)
      }
    }
    return dec_invalid(1)
  }
  function set_utf_8_uchar(b, i, u) {
    function set(_AA_, _Az_, _Ay_) { caml_bytes_unsafe_set(_AA_, _Az_, _Ay_); return 0 }
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if (0 > u) throw [0, Assert_failure, _A_];
    if (127 >= u) { caml_bytes_set(b, i, u); return 1 }
    if (2047 >= u) {
      var last$1 = i + 1 | 0;
      return max < last$1
        ? 0
        : (caml_bytes_set(b, i, 192 | u >>> 6 | 0),
          set(b, last$1, 128 | u & 63),
          2)
    }
    if (65535 >= u) {
      var last$0 = i + 2 | 0;
      return max < last$0
        ? 0
        : (caml_bytes_set(b, i, 224 | u >>> 12 | 0),
          set(b, i + 1 | 0, 128 | (u >>> 6 | 0) & 63),
          set(b, last$0, 128 | u & 63),
          3)
    }
    if (1114111 < u) throw [0, Assert_failure, _z_];
    var last = i + 3 | 0;
    return max < last
      ? 0
      : (caml_bytes_set(b, i, 240 | u >>> 18 | 0),
        set(b, i + 1 | 0, 128 | (u >>> 12 | 0) & 63),
        set(b, i + 2 | 0, 128 | (u >>> 6 | 0) & 63),
        set(b, last, 128 | u & 63),
        4)
  }
  function is_valid_utf_8(b) {
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for (; ;) {
      if (max < i) return 1;
      var match = caml_bytes_unsafe_get(b, i);
      if (224 <= match) {
        var switch$0 = 0;
        if (237 <= match) {
          if (245 > match)
            switch (match - 237 | 0) {
              case 0:
                var last = i + 2 | 0;
                if
                  (max
                  >=
                  last
                  &&
                  !
                  not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))) { var i$0 = last + 1 | 0, i = i$0; continue }
                return 0;
              case 3:
                var last$1 = i + 3 | 0;
                if
                  (max
                  >=
                  last$1
                  &&
                  !
                  not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))) { var i$2 = last$1 + 1 | 0, i = i$2; continue }
                return 0;
              case 7:
                var last$3 = i + 3 | 0;
                if
                  (max
                  >=
                  last$3
                  &&
                  !
                  not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))) { var i$4 = last$3 + 1 | 0, i = i$4; continue }
                return 0;
              case 1:
              case 2: switch$0 = 1; break;
              default:
                var last$2 = i + 3 | 0;
                if
                  (max
                  >=
                  last$2
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
                  &&
                  !
                  not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))) { var i$3 = last$2 + 1 | 0, i = i$3; continue }
                return 0
            }
        }
        else {
          if (225 > match) {
            var last$4 = i + 2 | 0;
            if
              (max
              >=
              last$4
              &&
              !
              not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))) { var i$5 = last$4 + 1 | 0, i = i$5; continue }
            return 0
          }
          switch$0 = 1
        }
        if (switch$0) {
          var last$0 = i + 2 | 0;
          if
            (max
            >=
            last$0
            &&
            !
            not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
            &&
            !
            not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))) { var i$1 = last$0 + 1 | 0, i = i$1; continue }
          return 0
        }
      }
      else {
        if (128 > match) { var i$7 = i + 1 | 0, i = i$7; continue }
        if (194 <= match) {
          var last$5 = i + 1 | 0;
          if
            (max
            >=
            last$5
            &&
            !
            not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))) { var i$6 = last$5 + 1 | 0, i = i$6; continue }
          return 0
        }
      }
      return 0
    }
  }
  function get_utf_16be_uchar(b, i) {
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if (0 <= i && max >= i) {
      if (i === max) return dec_invalid(1);
      var hi = get$1(b, i);
      if (55296 <= hi && 57343 >= hi) {
        if (56319 < hi) return dec_invalid(2);
        var last = i + 3 | 0;
        if (max < last) return dec_invalid((max - i | 0) + 1 | 0);
        var u = get$1(b, i + 2 | 0);
        if (56320 <= u && 57343 >= u) {
          var u$0 = ((hi & 1023) << 10 | u & 1023) + 65536 | 0;
          return dec_ret(4, u$0)
        }
        return dec_invalid(2)
      }
      return dec_ret(2, hi)
    }
    return invalid_arg(cst_index_out_of_bounds)
  }
  function set_utf_16be_uchar(b, i, u) {
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if (0 <= i && max >= i) {
      if (0 > u) throw [0, Assert_failure, _C_];
      if (65535 >= u) { var last$0 = i + 1 | 0; return max < last$0 ? 0 : (set$0(b, i, u), 2) }
      if (1114111 < u) throw [0, Assert_failure, _B_];
      var last = i + 3 | 0;
      if (max < last) return 0;
      var u$0 = u - 65536 | 0, hi = 55296 | u$0 >>> 10 | 0, lo = 56320 | u$0 & 1023;
      set$0(b, i, hi);
      set$0(b, i + 2 | 0, lo);
      return 4
    }
    return invalid_arg(cst_index_out_of_bounds$0)
  }
  function is_valid_utf_16be(b) {
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for (; ;) {
      if (max < i) return 1;
      if (i === max) return 0;
      var u = get$1(b, i);
      if (55296 <= u && 57343 >= u) {
        if (56319 < u) return 0;
        var last = i + 3 | 0;
        if (max < last) return 0;
        var u$0 = get$1(b, i + 2 | 0);
        if (56320 <= u$0 && 57343 >= u$0) { var i$1 = i + 4 | 0, i = i$1; continue }
        return 0
      }
      var i$0 = i + 2 | 0, i = i$0
    }
  }
  function get_utf_16le_uchar(b, i) {
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if (0 <= i && max >= i) {
      if (i === max) return dec_invalid(1);
      var hi = caml_bytes_get16(b, i);
      if (55296 <= hi && 57343 >= hi) {
        if (56319 < hi) return dec_invalid(2);
        var last = i + 3 | 0;
        if (max < last) return dec_invalid((max - i | 0) + 1 | 0);
        var u = caml_bytes_get16(b, i + 2 | 0);
        if (56320 <= u && 57343 >= u) {
          var u$0 = ((hi & 1023) << 10 | u & 1023) + 65536 | 0;
          return dec_ret(4, u$0)
        }
        return dec_invalid(2)
      }
      return dec_ret(2, hi)
    }
    return invalid_arg(cst_index_out_of_bounds$1)
  }
  function set_utf_16le_uchar(b, i, u) {
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if (0 <= i && max >= i) {
      if (0 > u) throw [0, Assert_failure, _E_];
      if (65535 >= u) {
        var last$0 = i + 1 | 0;
        return max < last$0 ? 0 : (caml_bytes_set16(b, i, u), 2)
      }
      if (1114111 < u) throw [0, Assert_failure, _D_];
      var last = i + 3 | 0;
      if (max < last) return 0;
      var u$0 = u - 65536 | 0, hi = 55296 | u$0 >>> 10 | 0, lo = 56320 | u$0 & 1023;
      caml_bytes_set16(b, i, hi);
      caml_bytes_set16(b, i + 2 | 0, lo);
      return 4
    }
    return invalid_arg(cst_index_out_of_bounds$2)
  }
  function is_valid_utf_16le(b) {
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for (; ;) {
      if (max < i) return 1;
      if (i === max) return 0;
      var u = caml_bytes_get16(b, i);
      if (55296 <= u && 57343 >= u) {
        if (56319 < u) return 0;
        var last = i + 3 | 0;
        if (max < last) return 0;
        var u$0 = caml_bytes_get16(b, i + 2 | 0);
        if (56320 <= u$0 && 57343 >= u$0) { var i$1 = i + 4 | 0, i = i$1; continue }
        return 0
      }
      var i$0 = i + 2 | 0, i = i$0
    }
  }
  var
    set_int64_ne = caml_bytes_set64,
    set_int32_ne = caml_bytes_set32,
    set_int16_ne = caml_bytes_set16,
    set_int8 = caml_bytes_set,
    get_int64_ne = caml_bytes_get64,
    get_int32_ne = caml_bytes_get32,
    get_uint16_ne = caml_bytes_get16,
    get_uint8 = caml_bytes_get,
    unsafe_of_string = caml_bytes_of_string,
    unsafe_to_string = caml_string_of_bytes,
    equal$8 = runtime.caml_bytes_equal,
    include$1 =
      [0,
        make$0,
        init$1,
        empty$0,
        copy,
        to_bytes,
        of_bytes,
        sub,
        sub_string,
        extend,
        fill,
        blit,
        blit$0,
        concat$0,
        cat$0,
        iter$3,
        iteri$1,
        map$5,
        mapi$1,
        fold_left$1,
        fold_right$0,
        for_all$1,
        exists$1,
        trim,
        escaped$0,
        index,
        index_opt,
        rindex,
        rindex_opt,
        index_from,
        index_from_opt,
        rindex_from,
        rindex_from_opt,
        contains,
        contains_from,
        rcontains_from,
        uppercase$0,
        lowercase$0,
        capitalize,
        uncapitalize,
        uppercase_ascii$0,
        lowercase_ascii$0,
        capitalize_ascii,
        uncapitalize_ascii,
        compare$8,
        equal$8,
        starts_with,
        ends_with,
        unsafe_to_string,
        unsafe_of_string,
        split_on_char,
        to_seq$2,
        to_seqi,
        of_seq$0,
        get_utf_8_uchar,
        set_utf_8_uchar,
        is_valid_utf_8,
        get_utf_16be_uchar,
        set_utf_16be_uchar,
        is_valid_utf_16be,
        get_utf_16le_uchar,
        set_utf_16le_uchar,
        is_valid_utf_16le,
        get_uint8,
        get_int8,
        get_uint16_ne,
        get_uint16_be,
        get_uint16_le,
        get_int16_ne,
        get_int16_be,
        get_int16_le,
        get_int32_ne,
        get_int32_be,
        get_int32_le,
        get_int64_ne,
        get_int64_be,
        get_int64_le,
        set_uint8,
        set_int8,
        set_uint16_ne,
        set_int16_be,
        set_int16_le,
        set_int16_ne,
        set_int16_be,
        set_int16_le,
        set_int32_ne,
        set_int32_be,
        set_int32_le,
        set_int64_ne,
        set_int64_be,
        set_int64_le];
  caml_register_global(790, include$1, "Stdlib__Bytes");
  function make$1(n, c) { return caml_string_of_bytes(make$0(n, c)) }
  function init$2(n, f) { return caml_string_of_bytes(init$1(n, f)) }
  function copy$0(s) { return caml_string_of_bytes(copy(caml_bytes_of_string(s))) }
  function sub$0(s, ofs, len) { return caml_string_of_bytes(sub(caml_bytes_of_string(s), ofs, len)) }
  function concat$1(sep, l) {
    if (!l) return cst$3;
    var seplen = caml_ml_string_length(sep), acc = 0, param = l, pos$1 = 0;
    for (; ;) {
      if (param) {
        var _Av_ = param[1];
        if (param[2]) {
          var
          tl = param[2],
          x = (caml_ml_string_length(_Av_) + seplen | 0) + acc | 0,
          acc$0 = acc <= x ? x : invalid_arg(cst_String_concat),
          acc = acc$0,
          param = tl;
          continue
        }
        var _Ax_ = caml_ml_string_length(_Av_) + acc | 0
      }
      else
        var _Ax_ = acc;
      var dst = caml_create_bytes(_Ax_), pos = pos$1, param$0 = l;
      for (; ;) {
        if (param$0) {
          var _Aw_ = param$0[1];
          if (param$0[2]) {
            var tl$0 = param$0[2];
            caml_blit_string(_Aw_, 0, dst, pos, caml_ml_string_length(_Aw_));
            caml_blit_string
              (sep, 0, dst, pos + caml_ml_string_length(_Aw_) | 0, seplen);
            var
              pos$0 = (pos + caml_ml_string_length(_Aw_) | 0) + seplen | 0,
              pos = pos$0,
              param$0 = tl$0;
            continue
          }
          caml_blit_string(_Aw_, 0, dst, pos, caml_ml_string_length(_Aw_))
        }
        return caml_string_of_bytes(dst)
      }
    }
  }
  function iter$4(f, s) {
    var _At_ = caml_ml_string_length(s) - 1 | 0, _As_ = 0;
    if (_At_ >= 0) {
      var i = _As_;
      for (; ;) {
        caml_call1(f, caml_string_unsafe_get(s, i));
        var _Au_ = i + 1 | 0;
        if (_At_ !== i) { var i = _Au_; continue }
        break
      }
    }
    return 0
  }
  function iteri$2(f, s) {
    var _Aq_ = caml_ml_string_length(s) - 1 | 0, _Ap_ = 0;
    if (_Aq_ >= 0) {
      var i = _Ap_;
      for (; ;) {
        caml_call2(f, i, caml_string_unsafe_get(s, i));
        var _Ar_ = i + 1 | 0;
        if (_Aq_ !== i) { var i = _Ar_; continue }
        break
      }
    }
    return 0
  }
  function map$6(f, s) { return caml_string_of_bytes(map$5(f, caml_bytes_of_string(s))) }
  function mapi$2(f, s) { return caml_string_of_bytes(mapi$1(f, caml_bytes_of_string(s))) }
  function fold_right$1(f, x, a) { return fold_right$0(f, caml_bytes_of_string(x), a) }
  function fold_left$2(f, a, x) { return fold_left$1(f, a, caml_bytes_of_string(x)) }
  function exists$2(f, s) { return exists$1(f, caml_bytes_of_string(s)) }
  function for_all$2(f, s) { return for_all$1(f, caml_bytes_of_string(s)) }
  function is_space$0(param) {
    var _Ao_ = param - 9 | 0, switch$0 = 0;
    if (4 < _Ao_ >>> 0) { if (23 === _Ao_) switch$0 = 1 }
    else
      if (2 !== _Ao_) switch$0 = 1;
    return switch$0 ? 1 : 0
  }
  function trim$0(s) {
    if (caml_string_equal(s, cst$4)) return s;
    if
      (!
      is_space$0(caml_string_unsafe_get(s, 0))
      &&
      !
      is_space$0(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
      return s;
    return caml_string_of_bytes(trim(caml_bytes_of_string(s)))
  }
  function escaped$1(s) {
    var n = caml_ml_string_length(s), i = 0;
    for (; ;) {
      if (n <= i) return s;
      var match = caml_string_unsafe_get(s, i), _An_ = match - 32 | 0, switch$0 = 0;
      if (59 < _An_ >>> 0) { if (33 < _An_ - 61 >>> 0) switch$0 = 1 }
      else
        if (2 === _An_) switch$0 = 1;
      if (switch$0)
        return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function index_rec$0(s, lim, i, c) {
    var i$0 = i;
    for (; ;) {
      if (lim <= i$0) throw Not_found;
      if (caml_string_unsafe_get(s, i$0) === c) return i$0;
      var i$1 = i$0 + 1 | 0, i$0 = i$1
    }
  }
  function index$0(s, c) { return index_rec$0(s, caml_ml_string_length(s), 0, c) }
  function index_rec_opt$0(s, lim, i, c) {
    var i$0 = i;
    for (; ;) {
      if (lim <= i$0) return 0;
      if (caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
      var i$1 = i$0 + 1 | 0, i$0 = i$1
    }
  }
  function index_opt$0(s, c) { return index_rec_opt$0(s, caml_ml_string_length(s), 0, c) }
  function index_from$0(s, i, c) {
    var l = caml_ml_string_length(s);
    if (0 <= i && l >= i) return index_rec$0(s, l, i, c);
    return invalid_arg(cst_String_index_from_Bytes_in$0)
  }
  function index_from_opt$0(s, i, c) {
    var l = caml_ml_string_length(s);
    if (0 <= i && l >= i) return index_rec_opt$0(s, l, i, c);
    return invalid_arg(cst_String_index_from_opt_Byte$0)
  }
  function rindex_rec$0(s, i, c) {
    var i$0 = i;
    for (; ;) {
      if (0 > i$0) throw Not_found;
      if (caml_string_unsafe_get(s, i$0) === c) return i$0;
      var i$1 = i$0 - 1 | 0, i$0 = i$1
    }
  }
  function rindex$0(s, c) { return rindex_rec$0(s, caml_ml_string_length(s) - 1 | 0, c) }
  function rindex_from$0(s, i, c) {
    if (-1 <= i && caml_ml_string_length(s) > i) return rindex_rec$0(s, i, c);
    return invalid_arg(cst_String_rindex_from_Bytes_r$0)
  }
  function rindex_rec_opt$0(s, i, c) {
    var i$0 = i;
    for (; ;) {
      if (0 > i$0) return 0;
      if (caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
      var i$1 = i$0 - 1 | 0, i$0 = i$1
    }
  }
  function rindex_opt$0(s, c) { return rindex_rec_opt$0(s, caml_ml_string_length(s) - 1 | 0, c) }
  function rindex_from_opt$0(s, i, c) {
    if (-1 <= i && caml_ml_string_length(s) > i)
      return rindex_rec_opt$0(s, i, c);
    return invalid_arg(cst_String_rindex_from_opt_Byt$0)
  }
  function contains_from$0(s, i, c) {
    var l = caml_ml_string_length(s);
    if (0 <= i && l >= i)
      try { index_rec$0(s, l, i, c); var _Al_ = 1; return _Al_ }
      catch (_Am_) {
        _Am_ = caml_wrap_exception(_Am_);
        if (_Am_ === Not_found) return 0;
        throw _Am_
      }
    return invalid_arg(cst_String_contains_from_Bytes$0)
  }
  function contains$0(s, c) { return contains_from$0(s, 0, c) }
  function rcontains_from$0(s, i, c) {
    if (0 <= i && caml_ml_string_length(s) > i)
      try { rindex_rec$0(s, i, c); var _Aj_ = 1; return _Aj_ }
      catch (_Ak_) {
        _Ak_ = caml_wrap_exception(_Ak_);
        if (_Ak_ === Not_found) return 0;
        throw _Ak_
      }
    return invalid_arg(cst_String_rcontains_from_Byte$0)
  }
  function uppercase_ascii$1(s) { return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s))) }
  function lowercase_ascii$1(s) { return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s))) }
  function capitalize_ascii$0(s) { return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s))) }
  function uncapitalize_ascii$0(s) { return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s))) }
  function starts_with$0(prefix, s) {
    var
    len_s = caml_ml_string_length(s),
    len_pre = caml_ml_string_length(prefix),
    _Ai_ = len_pre <= len_s ? 1 : 0;
    if (!_Ai_) return _Ai_;
    var i = 0;
    for (; ;) {
      if (i === len_pre) return 1;
      if (caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
        return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function ends_with$0(suffix, s) {
    var
    len_s = caml_ml_string_length(s),
    len_suf = caml_ml_string_length(suffix),
    diff = len_s - len_suf | 0,
    _Ah_ = 0 <= diff ? 1 : 0;
    if (!_Ah_) return _Ah_;
    var i = 0;
    for (; ;) {
      if (i === len_suf) return 1;
      if
        (caml_string_unsafe_get(s, diff + i | 0)
        !==
        caml_string_unsafe_get(suffix, i))
        return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function split_on_char$0(sep, s) {
    var
    r = [0, 0],
    j = [0, caml_ml_string_length(s)],
    _Ad_ = caml_ml_string_length(s) - 1 | 0;
    if (_Ad_ >= 0) {
      var i = _Ad_;
      for (; ;) {
        if (caml_string_unsafe_get(s, i) === sep) {
          var _Af_ = r[1];
          r[1] = [0, sub$0(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _Af_];
          j[1] = i
        }
        var _Ag_ = i - 1 | 0;
        if (0 !== i) { var i = _Ag_; continue }
        break
      }
    }
    var _Ae_ = r[1];
    return [0, sub$0(s, 0, j[1]), _Ae_]
  }
  function uppercase$1(s) { return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s))) }
  function lowercase$1(s) { return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s))) }
  function capitalize$0(s) { return caml_string_of_bytes(capitalize(caml_bytes_of_string(s))) }
  function uncapitalize$0(s) { return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s))) }
  function compare$9(x, y) { return caml_string_compare(x, y) }
  function to_seq$3(s) { return to_seq$2(caml_bytes_of_string(s)) }
  function to_seqi$0(s) { return to_seqi(caml_bytes_of_string(s)) }
  function of_seq$1(g) { return caml_string_of_bytes(of_seq$0(g)) }
  function get_utf_8_uchar$0(s, i) { return get_utf_8_uchar(caml_bytes_of_string(s), i) }
  function is_valid_utf_8$0(s) { return is_valid_utf_8(caml_bytes_of_string(s)) }
  function get_utf_16be_uchar$0(s, i) { return get_utf_16be_uchar(caml_bytes_of_string(s), i) }
  function is_valid_utf_16be$0(s) { return is_valid_utf_16be(caml_bytes_of_string(s)) }
  function get_utf_16le_uchar$0(s, i) { return get_utf_16le_uchar(caml_bytes_of_string(s), i) }
  function is_valid_utf_16le$0(s) { return is_valid_utf_16le(caml_bytes_of_string(s)) }
  function get_int8$0(s, i) { return get_int8(caml_bytes_of_string(s), i) }
  function get_uint16_le$0(s, i) { return caml_bytes_get16(caml_bytes_of_string(s), i) }
  function get_uint16_be$0(s, i) { return get_uint16_be(caml_bytes_of_string(s), i) }
  function get_int16_ne$0(s, i) { return get_int16_ne(caml_bytes_of_string(s), i) }
  function get_int16_le$0(s, i) { return get_int16_le(caml_bytes_of_string(s), i) }
  function get_int16_be$0(s, i) { return get_int16_be(caml_bytes_of_string(s), i) }
  function get_int32_le$0(s, i) { return caml_bytes_get32(caml_bytes_of_string(s), i) }
  function get_int32_be$0(s, i) { return get_int32_be(caml_bytes_of_string(s), i) }
  function get_int64_le$0(s, i) { return caml_bytes_get64(caml_bytes_of_string(s), i) }
  function get_int64_be$0(s, i) { return get_int64_be(caml_bytes_of_string(s), i) }
  var
    get_int64_ne$0 = runtime.caml_string_get64,
    get_int32_ne$0 = runtime.caml_string_get32,
    get_uint16_ne$0 = runtime.caml_string_get16,
    get_uint8$0 = caml_string_get,
    equal$9 = caml_string_equal,
    include$2 =
      [0,
        make$1,
        init$2,
        empty$1,
        of_bytes,
        to_bytes,
        concat$1,
        cat,
        equal$9,
        compare$9,
        starts_with$0,
        ends_with$0,
        contains_from$0,
        rcontains_from$0,
        contains$0,
        sub$0,
        split_on_char$0,
        map$6,
        mapi$2,
        fold_left$2,
        fold_right$1,
        for_all$2,
        exists$2,
        trim$0,
        escaped$1,
        uppercase_ascii$1,
        lowercase_ascii$1,
        capitalize_ascii$0,
        uncapitalize_ascii$0,
        iter$4,
        iteri$2,
        index_from$0,
        index_from_opt$0,
        rindex_from$0,
        rindex_from_opt$0,
        index$0,
        index_opt$0,
        rindex$0,
        rindex_opt$0,
        to_seq$3,
        to_seqi$0,
        of_seq$1,
        get_utf_8_uchar$0,
        is_valid_utf_8$0,
        get_utf_16be_uchar$0,
        is_valid_utf_16be$0,
        get_utf_16le_uchar$0,
        is_valid_utf_16le$0,
        blit$0,
        copy$0,
        fill,
        uppercase$1,
        lowercase$1,
        capitalize$0,
        uncapitalize$0,
        get_uint8$0,
        get_int8$0,
        get_uint16_ne$0,
        get_uint16_be$0,
        get_uint16_le$0,
        get_int16_ne$0,
        get_int16_be$0,
        get_int16_le$0,
        get_int32_ne$0,
        get_int32_be$0,
        get_int32_le$0,
        get_int64_ne$0,
        get_int64_be$0,
        get_int64_le$0];
  caml_register_global(791, include$2, "Stdlib__String");
  function equal$10(param, _Ac_) { return 1 }
  function compare$10(param, _Ab_) { return 0 }
  function to_string$2(param) { return cst$5 }
  var Stdlib_Unit = [0, equal$10, compare$10, to_string$2];
  caml_register_global(792, Stdlib_Unit, "Stdlib__Unit");
  function to_buffer(buff, ofs, len, v, flags) {
    if
      (0 <= ofs && 0 <= len && (caml_ml_bytes_length(buff) - len | 0) >= ofs)
      return runtime.caml_output_value_to_buffer(buff, ofs, len, v, flags);
    return invalid_arg(cst_Marshal_to_buffer_substrin)
  }
  var header_size = 20;
  function data_size(buff, ofs) {
    if (0 <= ofs && (caml_ml_bytes_length(buff) - 20 | 0) >= ofs)
      return caml_marshal_data_size(buff, ofs);
    return invalid_arg(cst_Marshal_data_size)
  }
  function total_size(buff, ofs) {
    return 20 + data_size(buff, ofs) | 0 }
  function from_bytes(buff, ofs) {
    if (0 <= ofs && (caml_ml_bytes_length(buff) - 20 | 0) >= ofs) {
      var len = caml_marshal_data_size(buff, ofs);
      return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
        ? invalid_arg(cst_Marshal_from_bytes$0)
        : runtime.caml_input_value_from_bytes(buff, ofs)
    }
    return invalid_arg(cst_Marshal_from_bytes)
  }
  function from_string(buff, ofs) { return from_bytes(caml_bytes_of_string(buff), ofs) }
  var
    Stdlib_Marshal =
      [0,
        caml_output_value,
        to_buffer,
        caml_input_value,
        from_bytes,
        from_string,
        header_size,
        data_size,
        total_size];
  caml_register_global(793, Stdlib_Marshal, "Stdlib__Marshal");
  var make_float = runtime.caml_make_float_vect, Floatarray = [0];
  function init$3(l, f) {
    if (0 === l) return [0];
    if (0 > l) return invalid_arg(cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _z$_ = l - 1 | 0, _z__ = 1;
    if (_z$_ >= 1) {
      var i = _z__;
      for (; ;) {
        res[1 + i] = caml_call1(f, i);
        var _Aa_ = i + 1 | 0;
        if (_z$_ !== i) { var i = _Aa_; continue }
        break
      }
    }
    return res
  }
  function create_matrix(sx, sy, init) {
    var res = caml_make_vect(sx, [0]), _z8_ = sx - 1 | 0, _z7_ = 0;
    if (_z8_ >= 0) {
      var x = _z7_;
      for (; ;) {
        res[1 + x] = caml_make_vect(sy, init);
        var _z9_ = x + 1 | 0;
        if (_z8_ !== x) { var x = _z9_; continue }
        break
      }
    }
    return res
  }
  function copy$1(a) { var l = a.length - 1; return 0 === l ? [0] : caml_array_sub(a, 0, l) }
  function append$1(a1, a2) {
    var l1 = a1.length - 1;
    return 0 === l1
      ? copy$1(a2)
      : 0 === a2.length - 1
        ? caml_array_sub(a1, 0, l1)
        : runtime.caml_array_append(a1, a2)
  }
  function sub$1(a, ofs, len) {
    if (0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
      return caml_array_sub(a, ofs, len);
    return invalid_arg(cst_Array_sub)
  }
  function fill$0(a, ofs, len, v) {
    if (0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
      return runtime.caml_array_fill(a, ofs, len, v);
    return invalid_arg(cst_Array_fill)
  }
  function blit$1(a1, ofs1, a2, ofs2, len) {
    if
      (0
      <=
      len
      &&
      0
      <=
      ofs1
      &&
      (a1.length - 1 - len | 0)
      >=
      ofs1
      &&
      0
      <=
      ofs2
      &&
      (a2.length - 1 - len | 0)
      >=
      ofs2)
      return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return invalid_arg(cst_Array_blit)
  }
  function iter$5(f, a) {
    var _z5_ = a.length - 1 - 1 | 0, _z4_ = 0;
    if (_z5_ >= 0) {
      var i = _z4_;
      for (; ;) {
        caml_call1(f, a[1 + i]);
        var _z6_ = i + 1 | 0;
        if (_z5_ !== i) { var i = _z6_; continue }
        break
      }
    }
    return 0
  }
  function iter2$1(f, a, b) {
    if (a.length - 1 !== b.length - 1)
      return invalid_arg(cst_Array_iter2_arrays_must_ha);
    var _z2_ = a.length - 1 - 1 | 0, _z1_ = 0;
    if (_z2_ >= 0) {
      var i = _z1_;
      for (; ;) {
        caml_call2(f, a[1 + i], b[1 + i]);
        var _z3_ = i + 1 | 0;
        if (_z2_ !== i) { var i = _z3_; continue }
        break
      }
    }
    return 0
  }
  function map$7(f, a) {
    var l = a.length - 1;
    if (0 === l) return [0];
    var r = caml_make_vect(l, caml_call1(f, a[1])), _zZ_ = l - 1 | 0, _zY_ = 1;
    if (_zZ_ >= 1) {
      var i = _zY_;
      for (; ;) {
        r[1 + i] = caml_call1(f, a[1 + i]);
        var _z0_ = i + 1 | 0;
        if (_zZ_ !== i) { var i = _z0_; continue }
        break
      }
    }
    return r
  }
  function map2$1(f, a, b) {
    var la = a.length - 1, lb = b.length - 1;
    if (la !== lb) return invalid_arg(cst_Array_map2_arrays_must_hav);
    if (0 === la) return [0];
    var r = caml_make_vect(la, caml_call2(f, a[1], b[1])), _zW_ = la - 1 | 0, _zV_ = 1;
    if (_zW_ >= 1) {
      var i = _zV_;
      for (; ;) {
        r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
        var _zX_ = i + 1 | 0;
        if (_zW_ !== i) { var i = _zX_; continue }
        break
      }
    }
    return r
  }
  function iteri$3(f, a) {
    var _zT_ = a.length - 1 - 1 | 0, _zS_ = 0;
    if (_zT_ >= 0) {
      var i = _zS_;
      for (; ;) {
        caml_call2(f, i, a[1 + i]);
        var _zU_ = i + 1 | 0;
        if (_zT_ !== i) { var i = _zU_; continue }
        break
      }
    }
    return 0
  }
  function mapi$3(f, a) {
    var l = a.length - 1;
    if (0 === l) return [0];
    var r = caml_make_vect(l, caml_call2(f, 0, a[1])), _zQ_ = l - 1 | 0, _zP_ = 1;
    if (_zQ_ >= 1) {
      var i = _zP_;
      for (; ;) {
        r[1 + i] = caml_call2(f, i, a[1 + i]);
        var _zR_ = i + 1 | 0;
        if (_zQ_ !== i) { var i = _zR_; continue }
        break
      }
    }
    return r
  }
  function to_list$1(a) {
    var i$1 = a.length - 1 - 1 | 0, i = i$1, res = 0;
    for (; ;) {
      if (0 > i) return res;
      var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0, i = i$0, res = res$0
    }
  }
  function list_length(accu, param) {
    var accu$0 = accu, param$0 = param;
    for (; ;) {
      if (!param$0) return accu$0;
      var
        param$1 = param$0[2],
        accu$1 = accu$0 + 1 | 0,
        accu$0 = accu$1,
        param$0 = param$1
    }
  }
  function of_list(l) {
    if (!l) return [0];
    var tl = l[2], hd = l[1], a = caml_make_vect(list_length(0, l), hd), i = 1, param = tl;
    for (; ;) {
      if (!param) return a;
      var tl$0 = param[2], hd$0 = param[1];
      a[1 + i] = hd$0;
      var i$0 = i + 1 | 0, i = i$0, param = tl$0
    }
  }
  function fold_left$3(f, x, a) {
    var r = [0, x], _zN_ = a.length - 1 - 1 | 0, _zM_ = 0;
    if (_zN_ >= 0) {
      var i = _zM_;
      for (; ;) {
        r[1] = caml_call2(f, r[1], a[1 + i]);
        var _zO_ = i + 1 | 0;
        if (_zN_ !== i) { var i = _zO_; continue }
        break
      }
    }
    return r[1]
  }
  function fold_left_map$0(f, acc, input_array) {
    var len = input_array.length - 1;
    if (0 === len) return [0, acc, [0]];
    var
      match = caml_call2(f, acc, input_array[1]),
      elt = match[2],
      acc$0 = match[1],
      output_array = caml_make_vect(len, elt),
      acc$1 = [0, acc$0],
      _zK_ = len - 1 | 0,
      _zJ_ = 1;
    if (_zK_ >= 1) {
      var i = _zJ_;
      for (; ;) {
        var
        match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
        elt$0 = match$0[2],
        acc$2 = match$0[1];
        acc$1[1] = acc$2;
        output_array[1 + i] = elt$0;
        var _zL_ = i + 1 | 0;
        if (_zK_ !== i) { var i = _zL_; continue }
        break
      }
    }
    return [0, acc$1[1], output_array]
  }
  function fold_right$2(f, a, x) {
    var r = [0, x], _zH_ = a.length - 1 - 1 | 0;
    if (_zH_ >= 0) {
      var i = _zH_;
      for (; ;) {
        r[1] = caml_call2(f, a[1 + i], r[1]);
        var _zI_ = i - 1 | 0;
        if (0 !== i) { var i = _zI_; continue }
        break
      }
    }
    return r[1]
  }
  function exists$3(p, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (caml_call1(p, a[1 + i])) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function for_all$3(p, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 1;
      if (!caml_call1(p, a[1 + i])) return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function for_all2$1(p, l1, l2) {
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if (n1 !== n2) return invalid_arg(cst_Array_for_all2);
    var i = 0;
    for (; ;) {
      if (i === n1) return 1;
      if (!caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function exists2$1(p, l1, l2) {
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if (n1 !== n2) return invalid_arg(cst_Array_exists2);
    var i = 0;
    for (; ;) {
      if (i === n1) return 0;
      if (caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function mem$0(x, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (0 === caml_compare(a[1 + i], x)) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function memq$0(x, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (x === a[1 + i]) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function find_opt$0(p, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      var x = a[1 + i];
      if (caml_call1(p, x)) return [0, x];
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function find_map$1(f, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      var r = caml_call1(f, a[1 + i]);
      if (r) return r;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function split$0(x) {
    if (caml_equal(x, [0])) return [0, [0], [0]];
    var
      match = x[1],
      b0 = match[2],
      a0 = match[1],
      n = x.length - 1,
      a = caml_make_vect(n, a0),
      b = caml_make_vect(n, b0),
      _zF_ = n - 1 | 0,
      _zE_ = 1;
    if (_zF_ >= 1) {
      var i = _zE_;
      for (; ;) {
        var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
        a[1 + i] = ai;
        b[1 + i] = bi;
        var _zG_ = i + 1 | 0;
        if (_zF_ !== i) { var i = _zG_; continue }
        break
      }
    }
    return [0, a, b]
  }
  function combine$0(a, b) {
    var na = a.length - 1, nb = b.length - 1;
    if (na !== nb) invalid_arg(cst_Array_combine);
    if (0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _zC_ = na - 1 | 0, _zB_ = 1;
    if (_zC_ >= 1) {
      var i = _zB_;
      for (; ;) {
        x[1 + i] = [0, a[1 + i], b[1 + i]];
        var _zD_ = i + 1 | 0;
        if (_zC_ !== i) { var i = _zD_; continue }
        break
      }
    }
    return x
  }
  var Bottom = [248, cst_Stdlib_Array_Bottom, caml_fresh_oo_id(0)];
  function sort(cmp, a) {
    function maxson(l, i) {
      var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
      if ((i31 + 2 | 0) < l) {
        var _zu_ = i31 + 1 | 0, _zv_ = caml_check_bound(a, _zu_)[1 + _zu_];
        if (caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _zv_) < 0)
          x[1] = i31 + 1 | 0;
        var
          _zw_ = i31 + 2 | 0,
          _zx_ = caml_check_bound(a, _zw_)[1 + _zw_],
          _zy_ = x[1];
        if (caml_call2(cmp, caml_check_bound(a, _zy_)[1 + _zy_], _zx_) < 0)
          x[1] = i31 + 2 | 0;
        return x[1]
      }
      if ((i31 + 1 | 0) < l) {
        var _zz_ = i31 + 1 | 0, _zA_ = caml_check_bound(a, _zz_)[1 + _zz_];
        if (0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _zA_))
          return i31 + 1 | 0
      }
      if (i31 < l) return i31;
      throw [0, Bottom, i]
    }
    function trickledown(l, i, e) {
      var i$0 = i;
      for (; ;) {
        var j = maxson(l, i$0);
        if (0 < caml_call2(cmp, caml_check_bound(a, j)[1 + j], e)) {
          var _zt_ = caml_check_bound(a, j)[1 + j];
          caml_check_bound(a, i$0)[1 + i$0] = _zt_;
          var i$0 = j;
          continue
        }
        caml_check_bound(a, i$0)[1 + i$0] = e;
        return 0
      }
    }
    function trickle(l, i, e) {
      try { var _zs_ = trickledown(l, i, e); return _zs_ }
      catch (exn) {
        exn = caml_wrap_exception(exn);
        if (exn[1] !== Bottom) throw exn;
        var i$0 = exn[2];
        caml_check_bound(a, i$0)[1 + i$0] = e;
        return 0
      }
    }
    function bubbledown(l, i) {
      var i$0 = i;
      for (; ;) {
        var i$1 = maxson(l, i$0), _zr_ = caml_check_bound(a, i$1)[1 + i$1];
        caml_check_bound(a, i$0)[1 + i$0] = _zr_;
        var i$0 = i$1
      }
    }
    function bubble(l, i) {
      try { var _zq_ = bubbledown(l, i); return _zq_ }
      catch (exn) {
        exn = caml_wrap_exception(exn);
        if (exn[1] !== Bottom) throw exn;
        var i$0 = exn[2];
        return i$0
      }
    }
    var l = a.length - 1, _zi_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if (_zi_ >= 0) {
      var i$2 = _zi_;
      for (; ;) {
        trickle(l, i$2, caml_check_bound(a, i$2)[1 + i$2]);
        var _zp_ = i$2 - 1 | 0;
        if (0 !== i$2) { var i$2 = _zp_; continue }
        break
      }
    }
    var _zj_ = l - 1 | 0;
    if (_zj_ >= 2) {
      var i$0 = _zj_;
      a:
      for (; ;) {
        var
        e$0 = caml_check_bound(a, i$0)[1 + i$0],
        _zn_ = caml_check_bound(a, 0)[1];
        caml_check_bound(a, i$0)[1 + i$0] = _zn_;
        var i$1 = bubble(i$0, 0), i = i$1;
        for (; ;) {
          var father = (i - 1 | 0) / 3 | 0;
          if (i === father) throw [0, Assert_failure, _F_];
          if
            (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
            caml_check_bound(a, i)[1 + i] = e$0;
          else {
            var _zh_ = caml_check_bound(a, father)[1 + father];
            caml_check_bound(a, i)[1 + i] = _zh_;
            if (0 < father) { var i = father; continue }
            caml_check_bound(a, 0)[1] = e$0
          }
          var _zo_ = i$0 - 1 | 0;
          if (2 !== i$0) { var i$0 = _zo_; continue a }
          break
        }
        break
      }
    }
    var _zk_ = 1 < l ? 1 : 0;
    if (_zk_) {
      var e = caml_check_bound(a, 1)[2], _zl_ = caml_check_bound(a, 0)[1];
      caml_check_bound(a, 1)[2] = _zl_;
      caml_check_bound(a, 0)[1] = e;
      var _zm_ = 0
    }
    else
      var _zm_ = _zk_;
    return _zm_
  }
  function fast_sort$0(cmp, a) {
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
      var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
      for (; ;) {
        if (0 < caml_call2(cmp, s1, s2)) {
          caml_check_bound(dst, d)[1 + d] = s2;
          var i2$0 = i2 + 1 | 0;
          if (i2$0 >= src2r) return blit$1(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
          var
            d$0 = d + 1 | 0,
            s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0],
            i2 = i2$0,
            s2 = s2$0,
            d = d$0;
          continue
        }
        caml_check_bound(dst, d)[1 + d] = s1;
        var i1$0 = i1 + 1 | 0;
        if (i1$0 >= src1r)
          return blit$1(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        var
          d$1 = d + 1 | 0,
          s1$0 = caml_check_bound(a, i1$0)[1 + i1$0],
          i1 = i1$0,
          s1 = s1$0,
          d = d$1
      }
    }
    function isortto(srcofs, dst, dstofs, len) {
      var _y$_ = len - 1 | 0, _y__ = 0;
      if (_y$_ >= 0) {
        var i = _y__;
        a:
        for (; ;) {
          var
          _za_ = srcofs + i | 0,
          e = caml_check_bound(a, _za_)[1 + _za_],
          j = [0, (dstofs + i | 0) - 1 | 0];
          for (; ;) {
            if (dstofs <= j[1]) {
              var _zb_ = j[1];
              if (0 < caml_call2(cmp, caml_check_bound(dst, _zb_)[1 + _zb_], e)) {
                var
                _zc_ = j[1],
                _zd_ = caml_check_bound(dst, _zc_)[1 + _zc_],
                _ze_ = j[1] + 1 | 0;
                caml_check_bound(dst, _ze_)[1 + _ze_] = _zd_;
                j[1] += -1;
                continue
              }
            }
            var _zf_ = j[1] + 1 | 0;
            caml_check_bound(dst, _zf_)[1 + _zf_] = e;
            var _zg_ = i + 1 | 0;
            if (_y$_ !== i) { var i = _zg_; continue a }
            break
          }
          break
        }
      }
      return 0
    }
    function sortto(srcofs, dst, dstofs, len) {
      if (len <= 5) return isortto(srcofs, dst, dstofs, len);
      var l1 = len / 2 | 0, l2 = len - l1 | 0;
      sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
      sortto(srcofs, a, srcofs + l2 | 0, l1);
      return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs)
    }
    var l = a.length - 1;
    if (l <= 5) return isortto(0, a, 0, l);
    var
      l1 = l / 2 | 0,
      l2 = l - l1 | 0,
      t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0)
  }
  function to_seq$4(a) {
    function aux(i, param) {
      if (i >= a.length - 1) return 0;
      var x = a[1 + i], _y8_ = i + 1 | 0;
      return [0, x, function (_y9_) { return aux(_y8_, _y9_) }]
    }
    var _y6_ = 0;
    return function (_y7_) { return aux(_y6_, _y7_) }
  }
  function to_seqi$1(a) {
    function aux(i, param) {
      if (i >= a.length - 1) return 0;
      var x = a[1 + i], _y4_ = i + 1 | 0;
      return [0, [0, i, x], function (_y5_) { return aux(_y4_, _y5_) }]
    }
    var _y2_ = 0;
    return function (_y3_) { return aux(_y2_, _y3_) }
  }
  function of_seq$2(i$2) {
    var _y1_ = 0, l = fold_left(function (acc, x) { return [0, x, acc] }, _y1_, i$2);
    if (!l) return [0];
    var
      tl = l[2],
      hd = l[1],
      len = list_length(0, l),
      a = caml_make_vect(len, hd),
      i$1 = len - 2 | 0,
      i = i$1,
      param = tl;
    for (; ;) {
      if (!param) return a;
      var tl$0 = param[2], hd$0 = param[1];
      a[1 + i] = hd$0;
      var i$0 = i - 1 | 0, i = i$0, param = tl$0
    }
  }
  var
    concat$2 = caml_array_concat,
    include$3 =
      [0,
        make_float,
        init$3,
        create_matrix,
        create_matrix,
        append$1,
        concat$2,
        sub$1,
        copy$1,
        fill$0,
        blit$1,
        to_list$1,
        of_list,
        iter$5,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$3,
        fold_left_map$0,
        fold_right$2,
        iter2$1,
        map2$1,
        for_all$3,
        exists$3,
        for_all2$1,
        exists2$1,
        mem$0,
        memq$0,
        find_opt$0,
        find_map$1,
        split$0,
        combine$0,
        sort,
        fast_sort$0,
        fast_sort$0,
        to_seq$4,
        to_seqi$1,
        of_seq$2,
        Floatarray];
  caml_register_global(794, include$3, "Stdlib__Array");
  var zero$0 = 0., one$0 = 1., minus_one$0 = -1.;
  function is_finite(x) { return x - x == 0. ? 1 : 0 }
  function is_infinite(x) { return 1. / x == 0. ? 1 : 0 }
  function is_nan(x) { return x != x ? 1 : 0 }
  var pi = 3.14159265358979312;
  function is_integer(x) {
    var _y0_ = x == runtime.caml_trunc_float(x) ? 1 : 0;
    return _y0_ ? is_finite(x) : _y0_
  }
  function succ$0(x) { return caml_nextafter_float(x, infinity) }
  function pred$0(x) { return caml_nextafter_float(x, neg_infinity) }
  function equal$11(x, y) { return 0 === caml_float_compare(x, y) ? 1 : 0 }
  function min$2(x, y) {
    if (!(x < y)) {
      var switch$0 = 0;
      if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
      if (switch$0) return x != x ? x : y
    }
    return y != y ? y : x
  }
  function max$2(x, y) {
    if (!(x < y)) {
      var switch$0 = 0;
      if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
      if (switch$0) return y != y ? y : x
    }
    return x != x ? x : y
  }
  function min_max(x, y) {
    if (x == x && y == y) {
      if (!(x < y)) {
        var switch$0 = 0;
        if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
        if (switch$0) return [0, y, x]
      }
      return [0, x, y]
    }
    return [0, nan, nan]
  }
  function min_num(x, y) {
    if (!(x < y)) {
      var switch$0 = 0;
      if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
      if (switch$0) return y != y ? x : y
    }
    return x != x ? y : x
  }
  function max_num(x, y) {
    if (!(x < y)) {
      var switch$0 = 0;
      if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
      if (switch$0) return x != x ? y : x
    }
    return y != y ? x : y
  }
  function min_max_num(x, y) {
    if (x != x) return [0, y, y];
    if (y != y) return [0, x, x];
    if (!(x < y)) {
      var switch$0 = 0;
      if (caml_signbit_float(y) || !caml_signbit_float(x)) switch$0 = 1;
      if (switch$0) return [0, y, x]
    }
    return [0, x, y]
  }
  function hash$0(x) { return caml_hash(10, 100, 0, x) }
  function unsafe_fill(a, ofs, len, v) {
    var _yY_ = (ofs + len | 0) - 1 | 0;
    if (_yY_ >= ofs) {
      var i = ofs;
      for (; ;) {
        a[1 + i] = v;
        var _yZ_ = i + 1 | 0;
        if (_yY_ !== i) { var i = _yZ_; continue }
        break
      }
    }
    return 0
  }
  function check(a, ofs, len, msg) {
    var _yU_ = ofs < 0 ? 1 : 0;
    if (_yU_)
      var _yV_ = _yU_;
    else {
      var _yW_ = len < 0 ? 1 : 0;
      if (_yW_)
        var _yV_ = _yW_;
      else
        var
          _yX_ = (ofs + len | 0) < 0 ? 1 : 0,
          _yV_ = _yX_ || (a.length - 1 < (ofs + len | 0) ? 1 : 0)
    }
    return _yV_ ? invalid_arg(msg) : _yV_
  }
  function make$2(n, v) {
    var result = caml_floatarray_create(n);
    unsafe_fill(result, 0, n, v);
    return result
  }
  function init$4(l, f) {
    if (0 > l) return invalid_arg(cst_Float_Array_init);
    var res = caml_floatarray_create(l), _yS_ = l - 1 | 0, _yR_ = 0;
    if (_yS_ >= 0) {
      var i = _yR_;
      for (; ;) {
        res[1 + i] = caml_call1(f, i);
        var _yT_ = i + 1 | 0;
        if (_yS_ !== i) { var i = _yT_; continue }
        break
      }
    }
    return res
  }
  function append$2(a1, a2) {
    var
    l1 = a1.length - 1,
    l2 = a2.length - 1,
    result = caml_floatarray_create(l1 + l2 | 0);
    caml_floatarray_blit(a1, 0, result, 0, l1);
    caml_floatarray_blit(a2, 0, result, l1, l2);
    return result
  }
  function concat$3(l) {
    var acc = 0, param = l;
    for (; ;) {
      if (param) {
        var
        tl = param[2],
        hd = param[1],
        x = hd.length - 1 + acc | 0,
        acc$0 = acc <= x ? x : invalid_arg(cst_Float_Array_concat),
        acc = acc$0,
        param = tl;
        continue
      }
      var result = caml_floatarray_create(acc), l$0 = l, i = 0;
      for (; ;) {
        if (l$0) {
          var tl$0 = l$0[2], hd$0 = l$0[1], hlen = hd$0.length - 1;
          caml_floatarray_blit(hd$0, 0, result, i, hlen);
          var i$0 = i + hlen | 0, l$0 = tl$0, i = i$0;
          continue
        }
        if (i === acc) return result;
        throw [0, Assert_failure, _G_]
      }
    }
  }
  function sub$2(a, ofs, len) {
    check(a, ofs, len, cst_Float_Array_sub);
    var result = caml_floatarray_create(len);
    caml_floatarray_blit(a, ofs, result, 0, len);
    return result
  }
  function copy$2(a) {
    var l = a.length - 1, result = caml_floatarray_create(l);
    caml_floatarray_blit(a, 0, result, 0, l);
    return result
  }
  function fill$1(a, ofs, len, v) { check(a, ofs, len, cst_Float_Array_fill); return unsafe_fill(a, ofs, len, v) }
  function blit$2(src, sofs, dst, dofs, len) {
    check(src, sofs, len, cst_Float_array_blit);
    check(dst, dofs, len, cst_Float_array_blit$0);
    return caml_floatarray_blit(src, sofs, dst, dofs, len)
  }
  function to_list$2(a) { return init$0(a.length - 1, function (_yQ_) { return a[1 + _yQ_] }) }
  function of_list$0(l) {
    var result = caml_floatarray_create(length$1(l)), i = 0, l$0 = l;
    for (; ;) {
      if (!l$0) return result;
      var t = l$0[2], h = l$0[1];
      result[1 + i] = h;
      var i$0 = i + 1 | 0, i = i$0, l$0 = t
    }
  }
  function iter$6(f, a) {
    var _yO_ = a.length - 1 - 1 | 0, _yN_ = 0;
    if (_yO_ >= 0) {
      var i = _yN_;
      for (; ;) {
        caml_call1(f, a[1 + i]);
        var _yP_ = i + 1 | 0;
        if (_yO_ !== i) { var i = _yP_; continue }
        break
      }
    }
    return 0
  }
  function iter2$2(f, a, b) {
    if (a.length - 1 !== b.length - 1)
      return invalid_arg(cst_Float_Array_iter2_arrays_m);
    var _yL_ = a.length - 1 - 1 | 0, _yK_ = 0;
    if (_yL_ >= 0) {
      var i = _yK_;
      for (; ;) {
        caml_call2(f, a[1 + i], b[1 + i]);
        var _yM_ = i + 1 | 0;
        if (_yL_ !== i) { var i = _yM_; continue }
        break
      }
    }
    return 0
  }
  function map$8(f, a) {
    var l = a.length - 1, r = caml_floatarray_create(l), _yI_ = l - 1 | 0, _yH_ = 0;
    if (_yI_ >= 0) {
      var i = _yH_;
      for (; ;) {
        r[1 + i] = caml_call1(f, a[1 + i]);
        var _yJ_ = i + 1 | 0;
        if (_yI_ !== i) { var i = _yJ_; continue }
        break
      }
    }
    return r
  }
  function map2$2(f, a, b) {
    var la = a.length - 1, lb = b.length - 1;
    if (la !== lb) return invalid_arg(cst_Float_Array_map2_arrays_mu);
    var r = caml_floatarray_create(la), _yF_ = la - 1 | 0, _yE_ = 0;
    if (_yF_ >= 0) {
      var i = _yE_;
      for (; ;) {
        r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
        var _yG_ = i + 1 | 0;
        if (_yF_ !== i) { var i = _yG_; continue }
        break
      }
    }
    return r
  }
  function iteri$4(f, a) {
    var _yC_ = a.length - 1 - 1 | 0, _yB_ = 0;
    if (_yC_ >= 0) {
      var i = _yB_;
      for (; ;) {
        caml_call2(f, i, a[1 + i]);
        var _yD_ = i + 1 | 0;
        if (_yC_ !== i) { var i = _yD_; continue }
        break
      }
    }
    return 0
  }
  function mapi$4(f, a) {
    var l = a.length - 1, r = caml_floatarray_create(l), _yz_ = l - 1 | 0, _yy_ = 0;
    if (_yz_ >= 0) {
      var i = _yy_;
      for (; ;) {
        r[1 + i] = caml_call2(f, i, a[1 + i]);
        var _yA_ = i + 1 | 0;
        if (_yz_ !== i) { var i = _yA_; continue }
        break
      }
    }
    return r
  }
  function fold_left$4(f, x, a) {
    var r = [0, x], _yw_ = a.length - 1 - 1 | 0, _yv_ = 0;
    if (_yw_ >= 0) {
      var i = _yv_;
      for (; ;) {
        r[1] = caml_call2(f, r[1], a[1 + i]);
        var _yx_ = i + 1 | 0;
        if (_yw_ !== i) { var i = _yx_; continue }
        break
      }
    }
    return r[1]
  }
  function fold_right$3(f, a, x) {
    var r = [0, x], _yt_ = a.length - 1 - 1 | 0;
    if (_yt_ >= 0) {
      var i = _yt_;
      for (; ;) {
        r[1] = caml_call2(f, a[1 + i], r[1]);
        var _yu_ = i - 1 | 0;
        if (0 !== i) { var i = _yu_; continue }
        break
      }
    }
    return r[1]
  }
  function exists$4(p, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (caml_call1(p, a[1 + i])) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function for_all$4(p, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 1;
      if (!caml_call1(p, a[1 + i])) return 0;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function mem$1(x, a) {
    var n = a.length - 1, i = 0;
    for (; ;) {
      if (i === n) return 0;
      if (0 === caml_float_compare(a[1 + i], x)) return 1;
      var i$0 = i + 1 | 0, i = i$0
    }
  }
  function mem_ieee(x, a) {
    var n = a.length - 1, i = 0;
    for (; ;) { if (i === n) return 0; if (x == a[1 + i]) return 1; var i$0 = i + 1 | 0, i = i$0 }
  }
  var Bottom$0 = [248, cst_Stdlib_Float_Array_Bottom, caml_fresh_oo_id(0)];
  function sort$0(cmp, a) {
    function maxson(l, i) {
      var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
      if ((i31 + 2 | 0) < l) {
        if
          (caml_call2
            (cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0))
          <
          0)
          x[1] = i31 + 1 | 0;
        if
          (caml_call2
            (cmp, caml_array_get(a, x[1]), caml_array_get(a, i31 + 2 | 0))
          <
          0)
          x[1] = i31 + 2 | 0;
        return x[1]
      }
      if
        ((i31 + 1 | 0)
        <
        l
        &&
        0
        >
        caml_call2(cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0)))
        return i31 + 1 | 0;
      if (i31 < l) return i31;
      throw [0, Bottom$0, i]
    }
    function trickledown(l, i, e) {
      var i$0 = i;
      for (; ;) {
        var j = maxson(l, i$0);
        if (0 >= caml_call2(cmp, caml_array_get(a, j), e))
          return caml_array_set(a, i$0, e);
        caml_array_set(a, i$0, caml_array_get(a, j));
        var i$0 = j
      }
    }
    function trickle(l, i, e) {
      try { var _ys_ = trickledown(l, i, e); return _ys_ }
      catch (exn) {
        exn = caml_wrap_exception(exn);
        if (exn[1] !== Bottom$0) throw exn;
        var i$0 = exn[2];
        return caml_array_set(a, i$0, e)
      }
    }
    function bubbledown(l, i) {
      var i$0 = i;
      for (; ;) {
        var i$1 = maxson(l, i$0);
        caml_array_set(a, i$0, caml_array_get(a, i$1));
        var i$0 = i$1
      }
    }
    function bubble(l, i) {
      try { var _yr_ = bubbledown(l, i); return _yr_ }
      catch (exn) {
        exn = caml_wrap_exception(exn);
        if (exn[1] !== Bottom$0) throw exn;
        var i$0 = exn[2];
        return i$0
      }
    }
    var l = a.length - 1, _yl_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if (_yl_ >= 0) {
      var i$2 = _yl_;
      for (; ;) {
        trickle(l, i$2, caml_array_get(a, i$2));
        var _yq_ = i$2 - 1 | 0;
        if (0 !== i$2) { var i$2 = _yq_; continue }
        break
      }
    }
    var _ym_ = l - 1 | 0;
    if (_ym_ >= 2) {
      var i$0 = _ym_;
      a:
      for (; ;) {
        var e$0 = caml_array_get(a, i$0);
        caml_array_set(a, i$0, caml_array_get(a, 0));
        var i$1 = bubble(i$0, 0), i = i$1;
        for (; ;) {
          var father = (i - 1 | 0) / 3 | 0;
          if (i === father) throw [0, Assert_failure, _H_];
          if (0 <= caml_call2(cmp, caml_array_get(a, father), e$0))
            caml_array_set(a, i, e$0);
          else {
            caml_array_set(a, i, caml_array_get(a, father));
            if (0 < father) { var i = father; continue }
            caml_array_set(a, 0, e$0)
          }
          var _yp_ = i$0 - 1 | 0;
          if (2 !== i$0) { var i$0 = _yp_; continue a }
          break
        }
        break
      }
    }
    var _yn_ = 1 < l ? 1 : 0;
    if (_yn_) {
      var e = caml_array_get(a, 1);
      caml_array_set(a, 1, caml_array_get(a, 0));
      var _yo_ = caml_array_set(a, 0, e)
    }
    else
      var _yo_ = _yn_;
    return _yo_
  }
  function stable_sort(cmp, a) {
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
      var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_array_get(src2, src2ofs),
      s1$1 = caml_array_get(a, src1ofs),
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
      for (; ;) {
        if (0 < caml_call2(cmp, s1, s2)) {
          caml_array_set(dst, d, s2);
          var i2$0 = i2 + 1 | 0;
          if (i2$0 >= src2r) return blit$2(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
          var
            d$0 = d + 1 | 0,
            s2$0 = caml_array_get(src2, i2$0),
            i2 = i2$0,
            s2 = s2$0,
            d = d$0;
          continue
        }
        caml_array_set(dst, d, s1);
        var i1$0 = i1 + 1 | 0;
        if (i1$0 >= src1r)
          return blit$2(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        var d$1 = d + 1 | 0, s1$0 = caml_array_get(a, i1$0), i1 = i1$0, s1 = s1$0, d = d$1
      }
    }
    function isortto(srcofs, dst, dstofs, len) {
      var _yj_ = len - 1 | 0, _yi_ = 0;
      if (_yj_ >= 0) {
        var i = _yi_;
        a:
        for (; ;) {
          var
          e = caml_array_get(a, srcofs + i | 0),
          j = [0, (dstofs + i | 0) - 1 | 0];
          for (; ;) {
            if
              (dstofs
              <=
              j[1]
              &&
              0
              <
              caml_call2(cmp, caml_array_get(dst, j[1]), e)) {
              caml_array_set(dst, j[1] + 1 | 0, caml_array_get(dst, j[1]));
              j[1] += -1;
              continue
            }
            caml_array_set(dst, j[1] + 1 | 0, e);
            var _yk_ = i + 1 | 0;
            if (_yj_ !== i) { var i = _yk_; continue a }
            break
          }
          break
        }
      }
      return 0
    }
    function sortto(srcofs, dst, dstofs, len) {
      if (len <= 5) return isortto(srcofs, dst, dstofs, len);
      var l1 = len / 2 | 0, l2 = len - l1 | 0;
      sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
      sortto(srcofs, a, srcofs + l2 | 0, l1);
      return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs)
    }
    var l = a.length - 1;
    if (l <= 5) return isortto(0, a, 0, l);
    var l1 = l / 2 | 0, l2 = l - l1 | 0, t = caml_floatarray_create(l2);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0)
  }
  function to_seq$5(a) {
    function aux(i, param) {
      if (i >= a.length - 1) return 0;
      var x = a[1 + i], _yg_ = i + 1 | 0;
      return [0, x, function (_yh_) { return aux(_yg_, _yh_) }]
    }
    var _ye_ = 0;
    return function (_yf_) { return aux(_ye_, _yf_) }
  }
  function to_seqi$2(a) {
    function aux(i, param) {
      if (i >= a.length - 1) return 0;
      var x = a[1 + i], _yc_ = i + 1 | 0;
      return [0, [0, i, x], function (_yd_) { return aux(_yc_, _yd_) }]
    }
    var _ya_ = 0;
    return function (_yb_) { return aux(_ya_, _yb_) }
  }
  function of_seq$3(i$2) {
    var
    _x$_ = 0,
    param$0 = fold_left(function (acc, x) { return [0, x, acc] }, _x$_, i$2),
    len = length$1(param$0),
    a = caml_floatarray_create(len),
    i$1 = len - 1 | 0,
    i = i$1,
    param = param$0;
    for (; ;) {
      if (!param) return a;
      var tl = param[2], hd = param[1];
      a[1 + i] = hd;
      var i$0 = i - 1 | 0, i = i$0, param = tl
    }
  }
  function map_to_array(f, a) {
    var l = a.length - 1;
    if (0 === l) return [0];
    var r = caml_make_vect(l, caml_call1(f, a[1])), _x9_ = l - 1 | 0, _x8_ = 1;
    if (_x9_ >= 1) {
      var i = _x8_;
      for (; ;) {
        r[1 + i] = caml_call1(f, a[1 + i]);
        var _x__ = i + 1 | 0;
        if (_x9_ !== i) { var i = _x__; continue }
        break
      }
    }
    return r
  }
  function map_from_array(f, a) {
    var l = a.length - 1, r = caml_floatarray_create(l), _x6_ = l - 1 | 0, _x5_ = 0;
    if (_x6_ >= 0) {
      var i = _x5_;
      for (; ;) {
        r[1 + i] = caml_call1(f, a[1 + i]);
        var _x7_ = i + 1 | 0;
        if (_x6_ !== i) { var i = _x7_; continue }
        break
      }
    }
    return r
  }
  var
    _I_ = caml_floatarray_create,
    _J_ = caml_array_set,
    _K_ = caml_array_get,
    _L_ =
      [0,
        function (_x4_) { return _x4_.length - 1 },
        _K_,
        _J_,
        make$2,
        _I_,
        init$4,
        append$2,
        concat$3,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$4,
        map$8,
        mapi$4,
        fold_left$4,
        fold_right$3,
        iter2$2,
        map2$2,
        for_all$4,
        exists$4,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
    _M_ = caml_floatarray_create,
    _N_ = caml_array_set,
    _O_ = caml_array_get,
    Stdlib_Float =
      [0,
        zero$0,
        one$0,
        minus_one$0,
        succ$0,
        pred$0,
        infinity,
        neg_infinity,
        nan,
        pi,
        max_float,
        min_float,
        epsilon,
        is_finite,
        is_infinite,
        is_nan,
        is_integer,
        of_string_opt,
        to_string,
        caml_float_compare,
        equal$11,
        min$2,
        max$2,
        min_max,
        min_num,
        max_num,
        min_max_num,
        hash$0,
        [0,
          function (_x3_) { return _x3_.length - 1 },
          _O_,
          _N_,
          make$2,
          _M_,
          init$4,
          append$2,
          concat$3,
          sub$2,
          copy$2,
          fill$1,
          blit$2,
          to_list$2,
          of_list$0,
          iter$6,
          iteri$4,
          map$8,
          mapi$4,
          fold_left$4,
          fold_right$3,
          iter2$2,
          map2$2,
          for_all$4,
          exists$4,
          mem$1,
          mem_ieee,
          sort$0,
          stable_sort,
          stable_sort,
          to_seq$5,
          to_seqi$2,
          of_seq$3,
          map_to_array,
          map_from_array],
        _L_];
  caml_register_global(795, Stdlib_Float, "Stdlib__Float");
  var zero$1 = 0, one$1 = 1, minus_one$1 = -1;
  function succ$1(n) { return n + 1 | 0 }
  function pred$1(n) { return n - 1 | 0 }
  function abs$1(n) { return caml_greaterequal(n, 0) ? n : - n | 0 }
  var min_int$1 = -2147483648, max_int$1 = 2147483647;
  function lognot$0(n) { return n ^ -1 }
  function unsigned_to_int(n) {
    if (0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, 2147483647))
      return [0, n];
    return 0
  }
  function to_string$3(n) { return caml_format_int(cst_d, n) }
  function of_string_opt$0(s) {
    try { var _x1_ = [0, caml_int_of_string(s)]; return _x1_ }
    catch (_x2_) {
      _x2_ = caml_wrap_exception(_x2_);
      if (_x2_[1] === Failure) return 0;
      throw _x2_
    }
  }
  function compare$11(x, y) { return caml_int_compare(x, y) }
  function equal$12(x, y) { return 0 === caml_int_compare(x, y) ? 1 : 0 }
  function unsigned_compare(n, m) { return caml_int_compare(n + 2147483648 | 0, m + 2147483648 | 0) }
  function min$3(x, y) { return caml_lessequal(x, y) ? x : y }
  function max$3(x, y) { return caml_greaterequal(x, y) ? x : y }
  function unsigned_div(n, d) {
    if (caml_lessthan(d, 0)) return 0 <= unsigned_compare(n, d) ? one$1 : zero$1;
    var q = caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q
  }
  function unsigned_rem(n, d) { return n - caml_mul(unsigned_div(n, d), d) | 0 }
  var
    Stdlib_Int32 =
      [0,
        zero$1,
        one$1,
        minus_one$1,
        unsigned_div,
        unsigned_rem,
        succ$1,
        pred$1,
        abs$1,
        max_int$1,
        min_int$1,
        lognot$0,
        unsigned_to_int,
        of_string_opt$0,
        to_string$3,
        compare$11,
        unsigned_compare,
        equal$12,
        min$3,
        max$3];
  caml_register_global(796, Stdlib_Int32, "Stdlib__Int32");
  function succ$2(n) { return caml_int64_add(n, _P_) }
  function pred$2(n) { return caml_int64_sub(n, _Q_) }
  function abs$2(n) { return caml_greaterequal(n, _R_) ? n : runtime.caml_int64_neg(n) }
  function lognot$1(n) { return runtime.caml_int64_xor(n, _S_) }
  var max_int$3 = caml_int64_of_int32(2147483647);
  function unsigned_to_int$0(n) {
    if
      (0
      >=
      caml_int64_compare(zero$2, n)
      &&
      0
      >=
      caml_int64_compare(n, max_int$3))
      return [0, runtime.caml_int64_to_int32(n)];
    return 0
  }
  function to_string$4(n) { return caml_int64_format(cst_d$0, n) }
  function of_string_opt$1(s) {
    try { var _xZ_ = [0, caml_int64_of_string(s)]; return _xZ_ }
    catch (_x0_) {
      _x0_ = caml_wrap_exception(_x0_);
      if (_x0_[1] === Failure) return 0;
      throw _x0_
    }
  }
  function compare$12(x, y) { return caml_int64_compare(x, y) }
  function equal$13(x, y) { return 0 === caml_int64_compare(x, y) ? 1 : 0 }
  function unsigned_compare$0(n, m) {
    return caml_int64_compare
      (caml_int64_sub(n, min_int$2), caml_int64_sub(m, min_int$2))
  }
  function min$4(x, y) { return caml_lessequal(x, y) ? x : y }
  function max$4(x, y) { return caml_greaterequal(x, y) ? x : y }
  function unsigned_div$0(n, d) {
    if (caml_lessthan(d, zero$2))
      return 0 <= unsigned_compare$0(n, d) ? one$2 : zero$2;
    var
      q =
        caml_int64_shift_left
          (runtime.caml_int64_div(caml_int64_shift_right_unsigne(n, 1), d), 1),
      r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare$0(r, d) ? succ$2(q) : q
  }
  function unsigned_rem$0(n, d) { return caml_int64_sub(n, caml_int64_mul(unsigned_div$0(n, d), d)) }
  var
    Stdlib_Int64 =
      [0,
        zero$2,
        one$2,
        minus_one$2,
        unsigned_div$0,
        unsigned_rem$0,
        succ$2,
        pred$2,
        abs$2,
        max_int$2,
        min_int$2,
        lognot$1,
        unsigned_to_int$0,
        of_string_opt$1,
        to_string$4,
        compare$12,
        unsigned_compare$0,
        equal$13,
        min$4,
        max$4];
  caml_register_global(797, Stdlib_Int64, "Stdlib__Int64");
  var zero$3 = 0, one$3 = 1, minus_one$3 = -1;
  function succ$3(n) { return n + 1 | 0 }
  function pred$3(n) { return n - 1 | 0 }
  function abs$3(n) { return caml_greaterequal(n, 0) ? n : - n | 0 }
  var min_int$3 = -2147483648, max_int$4 = 2147483647;
  function lognot$2(n) { return n ^ -1 }
  function unsigned_to_int$1(n) {
    if (0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, 2147483647))
      return [0, n];
    return 0
  }
  function to_string$5(n) { return caml_format_int(cst_d$1, n) }
  function of_string_opt$2(s) {
    try { var _xX_ = [0, caml_int_of_string(s)]; return _xX_ }
    catch (_xY_) {
      _xY_ = caml_wrap_exception(_xY_);
      if (_xY_[1] === Failure) return 0;
      throw _xY_
    }
  }
  function compare$13(x, y) { return caml_int_compare(x, y) }
  function equal$14(x, y) { return 0 === caml_int_compare(x, y) ? 1 : 0 }
  function unsigned_compare$1(n, m) { return caml_int_compare(n + 2147483648 | 0, m + 2147483648 | 0) }
  function min$5(x, y) { return caml_lessequal(x, y) ? x : y }
  function max$5(x, y) { return caml_greaterequal(x, y) ? x : y }
  function unsigned_div$1(n, d) {
    if (caml_lessthan(d, 0)) return 0 <= unsigned_compare$1(n, d) ? one$3 : zero$3;
    var q = caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare$1(r, d) ? q + 1 | 0 : q
  }
  function unsigned_rem$1(n, d) { return n - caml_mul(unsigned_div$1(n, d), d) | 0 }
  var
    Stdlib_Nativeint =
      [0,
        zero$3,
        one$3,
        minus_one$3,
        unsigned_div$1,
        unsigned_rem$1,
        succ$3,
        pred$3,
        abs$3,
        match$1,
        max_int$4,
        min_int$3,
        lognot$2,
        unsigned_to_int$1,
        of_string_opt$2,
        to_string$5,
        compare$13,
        unsigned_compare$1,
        equal$14,
        min$5,
        max$5];
  caml_register_global(798, Stdlib_Nativeint, "Stdlib__Nativeint");
  function engine(tbl, state, buf) {
    var
    result = runtime.caml_lex_engine(tbl, state, buf),
    _xU_ = 0 <= result ? 1 : 0,
    _xV_ = _xU_ ? buf[12] !== dummy_pos ? 1 : 0 : _xU_;
    if (_xV_) {
      buf[11] = buf[12];
      var _xW_ = buf[12];
      buf[12] = [0, _xW_[1], _xW_[2], _xW_[3], buf[4] + buf[6] | 0]
    }
    return result
  }
  function new_engine(tbl, state, buf) {
    var
    result = runtime.caml_new_lex_engine(tbl, state, buf),
    _xR_ = 0 <= result ? 1 : 0,
    _xS_ = _xR_ ? buf[12] !== dummy_pos ? 1 : 0 : _xR_;
    if (_xS_) {
      buf[11] = buf[12];
      var _xT_ = buf[12];
      buf[12] = [0, _xT_[1], _xT_[2], _xT_[3], buf[4] + buf[6] | 0]
    }
    return result
  }
  function from_function(opt, f) {
    if (opt) var sth = opt[1], with_positions = sth; else var with_positions = 1;
    var
      _xD_ = with_positions ? zero_pos : dummy_pos,
      _xE_ = with_positions ? zero_pos : dummy_pos,
      aux_buffer = caml_create_bytes(512),
      _xF_ = [0],
      _xG_ = 0,
      _xH_ = 0,
      _xI_ = 0,
      _xJ_ = 0,
      _xK_ = 0,
      _xL_ = 0,
      _xM_ = 0,
      _xN_ = caml_create_bytes(1024);
    return [0,
      function (lexbuf) {
        var
        read =
          caml_call2(f, aux_buffer, caml_ml_bytes_length(aux_buffer)),
        n = 0 < read ? read : (lexbuf[9] = 1, 0);
        if (caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0)) {
          if
            (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
            <=
            caml_ml_bytes_length(lexbuf[2]))
            blit
              (lexbuf[2], lexbuf[5], lexbuf[2], 0, lexbuf[3] - lexbuf[5] | 0);
          else {
            var
            newlen =
              min$1
                (2 * caml_ml_bytes_length(lexbuf[2]) | 0, max_string_length);
            if (newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
              failwith(cst_Lexing_lex_refill_cannot_g);
            var newbuf = caml_create_bytes(newlen);
            blit(lexbuf[2], lexbuf[5], newbuf, 0, lexbuf[3] - lexbuf[5] | 0);
            lexbuf[2] = newbuf
          }
          var s = lexbuf[5];
          lexbuf[4] = lexbuf[4] + s | 0;
          lexbuf[6] = lexbuf[6] - s | 0;
          lexbuf[5] = 0;
          lexbuf[7] = lexbuf[7] - s | 0;
          lexbuf[3] = lexbuf[3] - s | 0;
          var t = lexbuf[10], _xP_ = t.length - 1 - 1 | 0, _xO_ = 0;
          if (_xP_ >= 0) {
            var i = _xO_;
            for (; ;) {
              var v = caml_check_bound(t, i)[1 + i];
              if (0 <= v) caml_check_bound(t, i)[1 + i] = v - s | 0;
              var _xQ_ = i + 1 | 0;
              if (_xP_ !== i) { var i = _xQ_; continue }
              break
            }
          }
        }
        blit(aux_buffer, 0, lexbuf[2], lexbuf[3], n);
        lexbuf[3] = lexbuf[3] + n | 0;
        return 0
      },
      _xN_,
      _xM_,
      _xL_,
      _xK_,
      _xJ_,
      _xI_,
      _xH_,
      _xG_,
      _xF_,
      _xE_,
      _xD_]
  }
  function from_channel(with_positions, ic) {
    return from_function
      (with_positions, function (buf, n) { return input(ic, buf, 0, n) })
  }
  function from_string$0(opt, s) {
    if (opt) var sth = opt[1], with_positions = sth; else var with_positions = 1;
    var
      _xs_ = with_positions ? zero_pos : dummy_pos,
      _xt_ = with_positions ? zero_pos : dummy_pos,
      _xu_ = [0],
      _xv_ = 1,
      _xw_ = 0,
      _xx_ = 0,
      _xy_ = 0,
      _xz_ = 0,
      _xA_ = 0,
      _xB_ = caml_ml_string_length(s),
      _xC_ = to_bytes(s);
    return [0,
      function (lexbuf) { lexbuf[9] = 1; return 0 },
      _xC_,
      _xB_,
      _xA_,
      _xz_,
      _xy_,
      _xx_,
      _xw_,
      _xv_,
      _xu_,
      _xt_,
      _xs_]
  }
  function set_position(lexbuf, position) {
    lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
    lexbuf[4] = position[4];
    return 0
  }
  function set_filename(lexbuf, fname) {
    var _xr_ = lexbuf[12];
    lexbuf[12] = [0, fname, _xr_[2], _xr_[3], _xr_[4]];
    return 0
  }
  function with_positions(lexbuf) { return lexbuf[12] !== dummy_pos ? 1 : 0 }
  function lexeme(lexbuf) {
    var len = lexbuf[6] - lexbuf[5] | 0;
    return sub_string(lexbuf[2], lexbuf[5], len)
  }
  function sub_lexeme(lexbuf, i1, i2) { var len = i2 - i1 | 0; return sub_string(lexbuf[2], i1, len) }
  function sub_lexeme_opt(lexbuf, i1, i2) {
    if (0 > i1) return 0;
    var len = i2 - i1 | 0;
    return [0, sub_string(lexbuf[2], i1, len)]
  }
  function sub_lexeme_char(lexbuf, i) { return caml_bytes_get(lexbuf[2], i) }
  function sub_lexeme_char_opt(lexbuf, i) { return 0 <= i ? [0, caml_bytes_get(lexbuf[2], i)] : 0 }
  function lexeme_char(lexbuf, i) { return caml_bytes_get(lexbuf[2], lexbuf[5] + i | 0) }
  function lexeme_start(lexbuf) { return lexbuf[11][4] }
  function lexeme_end(lexbuf) { return lexbuf[12][4] }
  function lexeme_start_p(lexbuf) { return lexbuf[11] }
  function lexeme_end_p(lexbuf) { return lexbuf[12] }
  function new_line(lexbuf) {
    var
    lcp = lexbuf[12],
    _xp_ = lcp !== dummy_pos ? 1 : 0,
    _xq_ = _xp_ ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0) : _xp_;
    return _xq_
  }
  function flush_input(lb) {
    lb[6] = 0;
    lb[4] = 0;
    var lcp = lb[12];
    if (lcp !== dummy_pos)
      lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
    lb[3] = 0;
    return 0
  }
  var
    Stdlib_Lexing =
      [0,
        dummy_pos,
        from_channel,
        from_string$0,
        from_function,
        set_position,
        set_filename,
        with_positions,
        lexeme,
        lexeme_char,
        lexeme_start,
        lexeme_end,
        lexeme_start_p,
        lexeme_end_p,
        new_line,
        flush_input,
        sub_lexeme,
        sub_lexeme_opt,
        sub_lexeme_char,
        sub_lexeme_char_opt,
        engine,
        new_engine];
  caml_register_global(799, Stdlib_Lexing, "Stdlib__Lexing");
  var
    YYexit = [248, cst_Stdlib_Parsing_YYexit, caml_fresh_oo_id(0)],
    Parse_error = [248, cst_Stdlib_Parsing_Parse_error, caml_fresh_oo_id(0)],
    env =
      [0,
        caml_make_vect(100, 0),
        caml_make_vect(100, 0),
        caml_make_vect(100, dummy_pos),
        caml_make_vect(100, dummy_pos),
        100,
        0,
        0,
        0,
        dummy_pos,
        dummy_pos,
        0,
        0,
        0,
        0,
        0,
        0];
  function grow_stacks(param) {
    var
    oldsize = env[5],
    newsize = oldsize * 2 | 0,
    new_s = caml_make_vect(newsize, 0),
    new_v = caml_make_vect(newsize, 0),
    new_start = caml_make_vect(newsize, dummy_pos),
    new_end = caml_make_vect(newsize, dummy_pos);
    blit$1(env[1], 0, new_s, 0, oldsize);
    env[1] = new_s;
    blit$1(env[2], 0, new_v, 0, oldsize);
    env[2] = new_v;
    blit$1(env[3], 0, new_start, 0, oldsize);
    env[3] = new_start;
    blit$1(env[4], 0, new_end, 0, oldsize);
    env[4] = new_end;
    env[5] = newsize;
    return 0
  }
  function clear_parser(param) { fill$0(env[2], 0, env[5], 0); env[8] = 0; return 0 }
  var current_lookahead_fun = [0, function (param) { return 0 }];
  function yyparse(tables, start, lexer, lexbuf) {
    var
    init_asp = env[11],
    init_sp = env[14],
    init_stackbase = env[6],
    init_state = env[15],
    init_curr_char = env[7],
    init_lval = env[8],
    init_errflag = env[16];
    env[6] = env[14] + 1 | 0;
    env[7] = start;
    env[10] = lexbuf[12];
    try {
      var cmd = 0, arg = 0;
      for (; ;) {
        var match = runtime.caml_parse_engine(tables, env, cmd, arg);
        switch (match) {
          case 0:
            var arg$0 = caml_call1(lexer, lexbuf);
            env[9] = lexbuf[11];
            env[10] = lexbuf[12];
            var cmd = 1, arg = arg$0;
            continue;
          case 1: throw Parse_error;
          case 2: grow_stacks(0); var cmd = 2, arg = 0; continue;
          case 3: grow_stacks(0); var cmd = 3, arg = 0; continue;
          case 4:
            try {
              var
              _xk_ = env[13],
              _xl_ =
                caml_call1(caml_check_bound(tables[1], _xk_)[1 + _xk_], env),
              _xm_ = 4,
              arg$1 = _xl_,
              cmd$0 = _xm_
            }
            catch (_xo_) {
              _xo_ = caml_wrap_exception(_xo_);
              if (_xo_ !== Parse_error) throw _xo_;
              var arg$1 = 0, cmd$0 = 5
            }
            var cmd = cmd$0, arg = arg$1;
            continue;
          default:
            caml_call1(tables[14], cst_syntax_error); var cmd = 5, arg = 0; continue
        }
      }
    }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      var curr_char = env[7];
      env[11] = init_asp;
      env[14] = init_sp;
      env[6] = init_stackbase;
      env[15] = init_state;
      env[7] = init_curr_char;
      env[8] = init_lval;
      env[16] = init_errflag;
      if (exn[1] === YYexit) { var v = exn[2]; return v }
      current_lookahead_fun[1]
        =
        function (tok) {
          if (!is_block(tok))
            return caml_check_bound(tables[2], tok)[1 + tok] === curr_char ? 1 : 0;
          var _xn_ = caml_obj_tag(tok);
          return caml_check_bound(tables[3], _xn_)[1 + _xn_] === curr_char ? 1 : 0
        };
      throw exn
    }
  }
  function peek_val(env, n) { var _xj_ = env[11] - n | 0; return caml_check_bound(env[2], _xj_)[1 + _xj_] }
  function symbol_start_pos(param) {
    var i = env[12];
    for (; ;) {
      if (0 >= i) { var _xi_ = env[11]; return caml_check_bound(env[4], _xi_)[1 + _xi_] }
      var
        _xg_ = (env[11] - i | 0) + 1 | 0,
        st = caml_check_bound(env[3], _xg_)[1 + _xg_],
        _xh_ = (env[11] - i | 0) + 1 | 0,
        en = caml_check_bound(env[4], _xh_)[1 + _xh_];
      if (caml_notequal(st, en)) return st;
      var i$0 = i - 1 | 0, i = i$0
    }
  }
  function symbol_end_pos(param) { var _xf_ = env[11]; return caml_check_bound(env[4], _xf_)[1 + _xf_] }
  function rhs_start_pos(n) {
    var _xe_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[3], _xe_)[1 + _xe_]
  }
  function rhs_end_pos(n) {
    var _xd_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[4], _xd_)[1 + _xd_]
  }
  function symbol_start(param) { return symbol_start_pos(0)[4] }
  function symbol_end(param) { return symbol_end_pos(0)[4] }
  function rhs_start(n) { return rhs_start_pos(n)[4] }
  function rhs_end(n) { return rhs_end_pos(n)[4] }
  function is_current_lookahead(tok) { return caml_call1(current_lookahead_fun[1], tok) }
  function parse_error(param) { return 0 }
  var
    Stdlib_Parsing =
      [0,
        symbol_start,
        symbol_end,
        rhs_start,
        rhs_end,
        symbol_start_pos,
        symbol_end_pos,
        rhs_start_pos,
        rhs_end_pos,
        clear_parser,
        Parse_error,
        runtime.caml_set_parser_trace,
        YYexit,
        yyparse,
        peek_val,
        is_current_lookahead,
        parse_error];
  caml_register_global(800, Stdlib_Parsing, "Stdlib__Parsing");
  var
    Stdlib_Set =
      [0,
        function (Ord) {
          function height(param) { if (!param) return 0; var h = param[4]; return h }
          function create(l, v, r) {
            if (l) var h = l[4], hl = h; else var hl = 0;
            if (r) var h$0 = r[4], hr = h$0; else var hr = 0;
            var _xc_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
            return [0, l, v, r, _xc_]
          }
          function bal(l, v, r) {
            if (l) var h = l[4], hl = h; else var hl = 0;
            if (r) var h$0 = r[4], hr = h$0; else var hr = 0;
            if ((hr + 2 | 0) < hl) {
              if (!l) return invalid_arg(cst_Set_bal$0);
              var lr = l[3], lv = l[2], ll = l[1], _w9_ = height(lr);
              if (_w9_ <= height(ll)) return create(ll, lv, create(lr, v, r));
              if (!lr) return invalid_arg(cst_Set_bal);
              var lrr = lr[3], lrv = lr[2], lrl = lr[1], _w__ = create(lrr, v, r);
              return create(create(ll, lv, lrl), lrv, _w__)
            }
            if ((hl + 2 | 0) >= hr) { var _xb_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0; return [0, l, v, r, _xb_] }
            if (!r) return invalid_arg(cst_Set_bal$2);
            var rr = r[3], rv = r[2], rl = r[1], _w$_ = height(rl);
            if (_w$_ <= height(rr)) return create(create(l, v, rl), rv, rr);
            if (!rl) return invalid_arg(cst_Set_bal$1);
            var rlr = rl[3], rlv = rl[2], rll = rl[1], _xa_ = create(rlr, rv, rr);
            return create(create(l, v, rll), rlv, _xa_)
          }
          function add(x, t) {
            if (!t) return [0, 0, x, 0, 1];
            var r = t[3], v = t[2], l = t[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) return t;
            if (0 <= c) { var rr = add(x, r); return r === rr ? t : bal(l, v, rr) }
            var ll = add(x, l);
            return l === ll ? t : bal(ll, v, r)
          }
          function singleton(x) { return [0, 0, x, 0, 1] }
          function add_min_element(x, param) {
            if (!param) return singleton(x);
            var r = param[3], v = param[2], l = param[1];
            return bal(add_min_element(x, l), v, r)
          }
          function add_max_element(x, param) {
            if (!param) return singleton(x);
            var r = param[3], v = param[2], l = param[1];
            return bal(l, v, add_max_element(x, r))
          }
          function join(l, v, r) {
            if (!l) return add_min_element(v, r);
            if (!r) return add_max_element(v, l);
            var
              rh = r[4],
              rr = r[3],
              rv = r[2],
              rl = r[1],
              lh = l[4],
              lr = l[3],
              lv = l[2],
              ll = l[1];
            return (rh + 2 | 0) < lh
              ? bal(ll, lv, join(lr, v, r))
              : (lh + 2 | 0) < rh ? bal(join(l, v, rl), rv, rr) : create(l, v, r)
          }
          function min_elt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              var _w8_ = param$0[1];
              if (_w8_) { var param$0 = _w8_; continue }
              var v = param$0[2];
              return v
            }
          }
          function min_elt_opt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var _w7_ = param$0[1];
              if (_w7_) { var param$0 = _w7_; continue }
              var v = param$0[2];
              return [0, v]
            }
          }
          function max_elt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              if (param$0[3]) { var param$1 = param$0[3], param$0 = param$1; continue }
              var v = param$0[2];
              return v
            }
          }
          function max_elt_opt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              if (param$0[3]) { var param$1 = param$0[3], param$0 = param$1; continue }
              var v = param$0[2];
              return [0, v]
            }
          }
          function remove_min_elt(param) {
            if (!param) return invalid_arg(cst_Set_remove_min_elt);
            var _w6_ = param[1];
            if (_w6_) { var r = param[3], v = param[2]; return bal(remove_min_elt(_w6_), v, r) }
            var r$0 = param[3];
            return r$0
          }
          function concat(t1, t2) {
            if (!t1) return t2;
            if (!t2) return t1;
            var _w5_ = remove_min_elt(t2);
            return join(t1, min_elt(t2), _w5_)
          }
          function split(x, param) {
            if (!param) return _T_;
            var r = param[3], v = param[2], l = param[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) return [0, l, 1, r];
            if (0 <= c) {
              var match = split(x, r), rr = match[3], pres = match[2], lr = match[1];
              return [0, join(l, v, lr), pres, rr]
            }
            var
              match$0 = split(x, l),
              rl = match$0[3],
              pres$0 = match$0[2],
              ll = match$0[1];
            return [0, ll, pres$0, join(rl, v, r)]
          }
          var empty = 0;
          function is_empty(param) { return param ? 0 : 1 }
          function mem(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var
                r = param$0[3],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v),
                _w4_ = 0 === c ? 1 : 0;
              if (_w4_) return _w4_;
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function remove(x, t) {
            if (!t) return 0;
            var r = t[3], v = t[2], l = t[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) {
              if (!l) return r;
              if (!r) return l;
              var _w3_ = remove_min_elt(r);
              return bal(l, min_elt(r), _w3_)
            }
            if (0 <= c) { var rr = remove(x, r); return r === rr ? t : bal(l, v, rr) }
            var ll = remove(x, l);
            return l === ll ? t : bal(ll, v, r)
          }
          function union(s1, s2) {
            if (!s1) return s2;
            if (!s2) return s1;
            var
              h2 = s2[4],
              r2 = s2[3],
              v2 = s2[2],
              l2 = s2[1],
              h1 = s1[4],
              r1 = s1[3],
              v1 = s1[2],
              l1 = s1[1];
            if (h2 <= h1) {
              if (1 === h2) return add(v2, s1);
              var
                match = split(v1, s2),
                r2$0 = match[3],
                l2$0 = match[1],
                _w1_ = union(r1, r2$0);
              return join(union(l1, l2$0), v1, _w1_)
            }
            if (1 === h1) return add(v1, s2);
            var
              match$0 = split(v2, s1),
              r1$0 = match$0[3],
              l1$0 = match$0[1],
              _w2_ = union(r1$0, r2);
            return join(union(l1$0, l2), v2, _w2_)
          }
          function inter(s1, s2) {
            if (!s1) return 0;
            if (!s2) return 0;
            var r1 = s1[3], v1 = s1[2], l1 = s1[1], _wX_ = split(v1, s2), _wY_ = _wX_[1];
            if (_wX_[2]) {
              var r2 = _wX_[3], _wZ_ = inter(r1, r2);
              return join(inter(l1, _wY_), v1, _wZ_)
            }
            var r2$0 = _wX_[3], _w0_ = inter(r1, r2$0);
            return concat(inter(l1, _wY_), _w0_)
          }
          function split_bis(x, param) {
            if (!param) return [0, 0, function (param) { return 0 }];
            var r = param[3], v = param[2], l = param[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) return 0;
            if (0 <= c) {
              var match = split_bis(x, r);
              if (!match) return 0;
              var rr = match[2], lr = match[1];
              return [0, join(l, v, lr), rr]
            }
            var match$0 = split_bis(x, l);
            if (!match$0) return 0;
            var rl = match$0[2], ll = match$0[1];
            return [0, ll, function (param) { return join(caml_call1(rl, 0), v, r) }]
          }
          function disjoint(s1, s2) {
            var s1$0 = s1, s2$0 = s2;
            for (; ;) {
              if (s1$0 && s2$0) {
                var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
                if (s1$0 === s2$0) return 0;
                var match = split_bis(v1, s2$0);
                if (!match) return 0;
                var r2 = match[2], l2 = match[1], _wW_ = disjoint(l1, l2);
                if (!_wW_) return _wW_;
                var s2$1 = caml_call1(r2, 0), s1$0 = r1, s2$0 = s2$1;
                continue
              }
              return 1
            }
          }
          function diff(s1, s2) {
            if (!s1) return 0;
            if (!s2) return s1;
            var r1 = s1[3], v1 = s1[2], l1 = s1[1], _wS_ = split(v1, s2), _wT_ = _wS_[1];
            if (_wS_[2]) {
              var r2 = _wS_[3], _wU_ = diff(r1, r2);
              return concat(diff(l1, _wT_), _wU_)
            }
            var r2$0 = _wS_[3], _wV_ = diff(r1, r2$0);
            return join(diff(l1, _wT_), v1, _wV_)
          }
          function cons_enum(s, e) {
            var s$0 = s, e$0 = e;
            for (; ;) {
              if (!s$0) return e$0;
              var r = s$0[3], v = s$0[2], s$1 = s$0[1], e$1 = [0, v, r, e$0], s$0 = s$1, e$0 = e$1
            }
          }
          function compare(s1, s2) {
            var e2$2 = cons_enum(s2, 0), e1$2 = cons_enum(s1, 0), e1 = e1$2, e2 = e2$2;
            for (; ;) {
              if (!e1) return e2 ? -1 : 0;
              if (!e2) return 1;
              var
                e2$0 = e2[3],
                r2 = e2[2],
                v2 = e2[1],
                e1$0 = e1[3],
                r1 = e1[2],
                v1 = e1[1],
                c = caml_call2(Ord[1], v1, v2);
              if (0 !== c) return c;
              var
                e2$1 = cons_enum(r2, e2$0),
                e1$1 = cons_enum(r1, e1$0),
                e1 = e1$1,
                e2 = e2$1
            }
          }
          function equal(s1, s2) { return 0 === compare(s1, s2) ? 1 : 0 }
          function subset(s1, s2) {
            var s1$0 = s1, s2$0 = s2;
            for (; ;) {
              if (!s1$0) return 1;
              if (!s2$0) return 0;
              var
                r2 = s2$0[3],
                v2 = s2$0[2],
                l2 = s2$0[1],
                r1 = s1$0[3],
                v1 = s1$0[2],
                l1 = s1$0[1],
                c = caml_call2(Ord[1], v1, v2);
              if (0 === c) {
                var _wP_ = subset(l1, l2);
                if (!_wP_) return _wP_;
                var s1$0 = r1, s2$0 = r2;
                continue
              }
              if (0 <= c) {
                var _wQ_ = subset([0, 0, v1, r1, 0], r2);
                if (!_wQ_) return _wQ_;
                var s1$0 = l1;
                continue
              }
              var _wR_ = subset([0, l1, v1, 0, 0], l2);
              if (!_wR_) return _wR_;
              var s1$0 = r1
            }
          }
          function iter(f, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var r = param$0[3], v = param$0[2], l = param$0[1];
              iter(f, l);
              caml_call1(f, v);
              var param$0 = r
            }
          }
          function fold(f, s, accu) {
            var s$0 = s, accu$0 = accu;
            for (; ;) {
              if (!s$0) return accu$0;
              var
                r = s$0[3],
                v = s$0[2],
                l = s$0[1],
                accu$1 = caml_call2(f, v, fold(f, l, accu$0)),
                s$0 = r,
                accu$0 = accu$1
            }
          }
          function for_all(p, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 1;
              var r = param$0[3], v = param$0[2], l = param$0[1], _wM_ = caml_call1(p, v);
              if (_wM_) {
                var _wN_ = for_all(p, l);
                if (_wN_) { var param$0 = r; continue }
                var _wO_ = _wN_
              }
              else
                var _wO_ = _wM_;
              return _wO_
            }
          }
          function exists(p, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var r = param$0[3], v = param$0[2], l = param$0[1], _wJ_ = caml_call1(p, v);
              if (_wJ_)
                var _wK_ = _wJ_;
              else {
                var _wL_ = exists(p, l);
                if (!_wL_) { var param$0 = r; continue }
                var _wK_ = _wL_
              }
              return _wK_
            }
          }
          function filter(p, t) {
            if (!t) return 0;
            var
              r = t[3],
              v = t[2],
              l = t[1],
              l$0 = filter(p, l),
              pv = caml_call1(p, v),
              r$0 = filter(p, r);
            if (!pv) return concat(l$0, r$0);
            if (l === l$0 && r === r$0) return t;
            return join(l$0, v, r$0)
          }
          function partition(p, param) {
            if (!param) return _U_;
            var
              r = param[3],
              v = param[2],
              l = param[1],
              match = partition(p, l),
              lf = match[2],
              lt = match[1],
              pv = caml_call1(p, v),
              match$0 = partition(p, r),
              rf = match$0[2],
              rt = match$0[1];
            if (pv) { var _wH_ = concat(lf, rf); return [0, join(lt, v, rt), _wH_] }
            var _wI_ = join(lf, v, rf);
            return [0, concat(lt, rt), _wI_]
          }
          function cardinal(param) {
            if (!param) return 0;
            var r = param[3], l = param[1], _wG_ = cardinal(r);
            return (cardinal(l) + 1 | 0) + _wG_ | 0
          }
          function elements_aux(accu, param) {
            var accu$0 = accu, param$0 = param;
            for (; ;) {
              if (!param$0) return accu$0;
              var
                r = param$0[3],
                v = param$0[2],
                l = param$0[1],
                accu$1 = [0, v, elements_aux(accu$0, r)],
                accu$0 = accu$1,
                param$0 = l
            }
          }
          function elements(s) { return elements_aux(0, s) }
          function find(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              var
                r = param$0[3],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v);
              if (0 === c) return v;
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function find_first(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) throw Not_found;
              var r$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = r$0; continue }
              var v0 = v$0, param = l$0;
              for (; ;) {
                if (!param) return v0;
                var r = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, param = l; continue }
                var param = r
              }
            }
          }
          function find_first_opt(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) return 0;
              var r$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = r$0; continue }
              var v0 = v$0, param = l$0;
              for (; ;) {
                if (!param) return [0, v0];
                var r = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, param = l; continue }
                var param = r
              }
            }
          }
          function find_last(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) throw Not_found;
              var r$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = l$0; continue }
              var v0 = v$0, param = r$0;
              for (; ;) {
                if (!param) return v0;
                var r = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, param = r; continue }
                var param = l
              }
            }
          }
          function find_last_opt(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) return 0;
              var r$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = l$0; continue }
              var v0 = v$0, param = r$0;
              for (; ;) {
                if (!param) return [0, v0];
                var r = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, param = r; continue }
                var param = l
              }
            }
          }
          function find_opt(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var
                r = param$0[3],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v);
              if (0 === c) return [0, v];
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function try_join(l, v, r) {
            var switch$0 = 0;
            if (0 !== l) {
              var _wF_ = max_elt(l);
              if (0 <= caml_call2(Ord[1], _wF_, v)) switch$0 = 1
            }
            if (!switch$0) {
              var switch$1 = 0;
              if (0 !== r) {
                var _wE_ = min_elt(r);
                if (0 <= caml_call2(Ord[1], v, _wE_)) switch$1 = 1
              }
              if (!switch$1) return join(l, v, r)
            }
            return union(l, add(v, r))
          }
          function map(f, t) {
            if (!t) return 0;
            var
              r = t[3],
              v = t[2],
              l = t[1],
              l$0 = map(f, l),
              v$0 = caml_call1(f, v),
              r$0 = map(f, r);
            if (l === l$0 && v === v$0 && r === r$0) return t;
            return try_join(l$0, v$0, r$0)
          }
          function filter_map(f, t) {
            if (!t) return 0;
            var
              r = t[3],
              v = t[2],
              l = t[1],
              t1 = filter_map(f, l),
              v$0 = caml_call1(f, v),
              t2 = filter_map(f, r);
            if (v$0) {
              var v$1 = v$0[1];
              if (l === t1 && v === v$1 && r === t2) return t;
              return try_join(t1, v$1, t2)
            }
            if (!t1) return t2;
            if (!t2) return t1;
            var _wD_ = remove_min_elt(t2);
            return try_join(t1, min_elt(t2), _wD_)
          }
          function of_list(l) {
            if (!l) return empty;
            var _ws_ = l[2], _wt_ = l[1];
            if (!_ws_) return singleton(_wt_);
            var _wu_ = _ws_[2], _wv_ = _ws_[1];
            if (!_wu_) return add(_wv_, singleton(_wt_));
            var _ww_ = _wu_[2], _wx_ = _wu_[1];
            if (!_ww_) return add(_wx_, add(_wv_, singleton(_wt_)));
            var _wy_ = _ww_[2], _wz_ = _ww_[1];
            if (!_wy_) return add(_wz_, add(_wx_, add(_wv_, singleton(_wt_))));
            if (_wy_[2]) {
              var
              l$0 = sort_uniq(Ord[1], l),
              sub =
                function (n, l) {
                  if (3 >= n >>> 0)
                    switch (n) {
                      case 0: return [0, 0, l];
                      case 1:
                        if (l) { var l$3 = l[2], x0 = l[1]; return [0, [0, 0, x0, 0, 1], l$3] }
                        break;
                      case 2:
                        if (l) {
                          var _wA_ = l[2];
                          if (_wA_) {
                            var l$4 = _wA_[2], x1 = _wA_[1], x0$0 = l[1];
                            return [0, [0, [0, 0, x0$0, 0, 1], x1, 0, 2], l$4]
                          }
                        }
                        break;
                      default:
                        if (l) {
                          var _wB_ = l[2];
                          if (_wB_) {
                            var _wC_ = _wB_[2];
                            if (_wC_) {
                              var l$5 = _wC_[2], x2 = _wC_[1], x1$0 = _wB_[1], x0$1 = l[1];
                              return [0, [0, [0, 0, x0$1, 0, 1], x1$0, [0, 0, x2, 0, 1], 2], l$5]
                            }
                          }
                        }
                    }
                  var nl = n / 2 | 0, match = sub(nl, l), l$0 = match[2], left = match[1];
                  if (!l$0) throw [0, Assert_failure, _V_];
                  var
                    l$1 = l$0[2],
                    mid = l$0[1],
                    match$0 = sub((n - nl | 0) - 1 | 0, l$1),
                    l$2 = match$0[2],
                    right = match$0[1];
                  return [0, create(left, mid, right), l$2]
                };
              return sub(length$1(l$0), l$0)[1]
            }
            var x4 = _wy_[1];
            return add(x4, add(_wz_, add(_wx_, add(_wv_, singleton(_wt_)))))
          }
          function add_seq(i, m) { return fold_left(function (s, x) { return add(x, s) }, m, i) }
          function of_seq(i) { return add_seq(i, empty) }
          function seq_of_enum(c, param) {
            if (!c) return 0;
            var rest = c[3], t = c[2], x = c[1], _wq_ = cons_enum(t, rest);
            return [0, x, function (_wr_) { return seq_of_enum(_wq_, _wr_) }]
          }
          function to_seq(c) {
            var _wo_ = cons_enum(c, 0);
            return function (_wp_) { return seq_of_enum(_wo_, _wp_) }
          }
          function snoc_enum(s, e) {
            var s$0 = s, e$0 = e;
            for (; ;) {
              if (!s$0) return e$0;
              var s$1 = s$0[3], v = s$0[2], l = s$0[1], e$1 = [0, v, l, e$0], s$0 = s$1, e$0 = e$1
            }
          }
          function rev_seq_of_enum(c, param) {
            if (!c) return 0;
            var rest = c[3], t = c[2], x = c[1], _wm_ = snoc_enum(t, rest);
            return [0, x, function (_wn_) { return rev_seq_of_enum(_wm_, _wn_) }]
          }
          function to_rev_seq(c) {
            var _wk_ = snoc_enum(c, 0);
            return function (_wl_) { return rev_seq_of_enum(_wk_, _wl_) }
          }
          function to_seq_from(low, s) {
            var s$0 = s, c = 0;
            for (; ;) {
              if (s$0) {
                var r = s$0[3], v = s$0[2], l = s$0[1], n = caml_call2(Ord[1], v, low);
                if (0 !== n) {
                  if (0 <= n) { var c$0 = [0, v, r, c], s$0 = l, c = c$0; continue }
                  var s$0 = r;
                  continue
                }
                var _wi_ = [0, v, r, c]
              }
              else
                var _wi_ = c;
              return function (_wj_) { return seq_of_enum(_wi_, _wj_) }
            }
          }
          return [0,
            empty,
            is_empty,
            mem,
            add,
            singleton,
            remove,
            union,
            inter,
            disjoint,
            diff,
            compare,
            equal,
            subset,
            iter,
            map,
            fold,
            for_all,
            exists,
            filter,
            filter_map,
            partition,
            cardinal,
            elements,
            min_elt,
            min_elt_opt,
            max_elt,
            max_elt_opt,
            min_elt,
            min_elt_opt,
            split,
            find,
            find_opt,
            find_first,
            find_first_opt,
            find_last,
            find_last_opt,
            of_list,
            to_seq_from,
            to_seq,
            to_rev_seq,
            add_seq,
            of_seq]
        }];
  caml_register_global(801, Stdlib_Set, "Stdlib__Set");
  var
    Stdlib_Map =
      [0,
        function (Ord) {
          function height(param) { if (!param) return 0; var h = param[5]; return h }
          function create(l, x, d, r) {
            var hl = height(l), hr = height(r), _wh_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
            return [0, l, x, d, r, _wh_]
          }
          function singleton(x, d) { return [0, 0, x, d, 0, 1] }
          function bal(l, x, d, r) {
            if (l) var h = l[5], hl = h; else var hl = 0;
            if (r) var h$0 = r[5], hr = h$0; else var hr = 0;
            if ((hr + 2 | 0) < hl) {
              if (!l) return invalid_arg(cst_Map_bal$0);
              var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _wc_ = height(lr);
              if (_wc_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
              if (!lr) return invalid_arg(cst_Map_bal);
              var
                lrr = lr[4],
                lrd = lr[3],
                lrv = lr[2],
                lrl = lr[1],
                _wd_ = create(lrr, x, d, r);
              return create(create(ll, lv, ld, lrl), lrv, lrd, _wd_)
            }
            if ((hl + 2 | 0) >= hr) { var _wg_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0; return [0, l, x, d, r, _wg_] }
            if (!r) return invalid_arg(cst_Map_bal$2);
            var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _we_ = height(rl);
            if (_we_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
            if (!rl) return invalid_arg(cst_Map_bal$1);
            var
              rlr = rl[4],
              rld = rl[3],
              rlv = rl[2],
              rll = rl[1],
              _wf_ = create(rlr, rv, rd, rr);
            return create(create(l, x, d, rll), rlv, rld, _wf_)
          }
          var empty = 0;
          function is_empty(param) { return param ? 0 : 1 }
          function add(x, data, m) {
            if (!m) return [0, 0, x, data, 0, 1];
            var h = m[5], r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) return d === data ? m : [0, l, x, data, r, h];
            if (0 <= c) { var rr = add(x, data, r); return r === rr ? m : bal(l, v, d, rr) }
            var ll = add(x, data, l);
            return l === ll ? m : bal(ll, v, d, r)
          }
          function find(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              var
                r = param$0[4],
                d = param$0[3],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v);
              if (0 === c) return d;
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function find_first(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) throw Not_found;
              var r$0 = param$1[4], d$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = r$0; continue }
              var v0 = v$0, d0 = d$0, param = l$0;
              for (; ;) {
                if (!param) return [0, v0, d0];
                var r = param[4], d = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, d0 = d, param = l; continue }
                var param = r
              }
            }
          }
          function find_first_opt(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) return 0;
              var r$0 = param$1[4], d$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = r$0; continue }
              var v0 = v$0, d0 = d$0, param = l$0;
              for (; ;) {
                if (!param) return [0, [0, v0, d0]];
                var r = param[4], d = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, d0 = d, param = l; continue }
                var param = r
              }
            }
          }
          function find_last(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) throw Not_found;
              var r$0 = param$1[4], d$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = l$0; continue }
              var v0 = v$0, d0 = d$0, param = r$0;
              for (; ;) {
                if (!param) return [0, v0, d0];
                var r = param[4], d = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, d0 = d, param = r; continue }
                var param = l
              }
            }
          }
          function find_last_opt(f, param$0) {
            var param$1 = param$0;
            for (; ;) {
              if (!param$1) return 0;
              var r$0 = param$1[4], d$0 = param$1[3], v$0 = param$1[2], l$0 = param$1[1];
              if (!caml_call1(f, v$0)) { var param$1 = l$0; continue }
              var v0 = v$0, d0 = d$0, param = r$0;
              for (; ;) {
                if (!param) return [0, [0, v0, d0]];
                var r = param[4], d = param[3], v = param[2], l = param[1];
                if (caml_call1(f, v)) { var v0 = v, d0 = d, param = r; continue }
                var param = l
              }
            }
          }
          function find_opt(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var
                r = param$0[4],
                d = param$0[3],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v);
              if (0 === c) return [0, d];
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function mem(x, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var
                r = param$0[4],
                v = param$0[2],
                l = param$0[1],
                c = caml_call2(Ord[1], x, v),
                _wb_ = 0 === c ? 1 : 0;
              if (_wb_) return _wb_;
              var param$1 = 0 <= c ? r : l, param$0 = param$1
            }
          }
          function min_binding(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              var _wa_ = param$0[1];
              if (_wa_) { var param$0 = _wa_; continue }
              var d = param$0[3], v = param$0[2];
              return [0, v, d]
            }
          }
          function min_binding_opt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var _v$_ = param$0[1];
              if (_v$_) { var param$0 = _v$_; continue }
              var d = param$0[3], v = param$0[2];
              return [0, [0, v, d]]
            }
          }
          function max_binding(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) throw Not_found;
              if (param$0[4]) { var param$1 = param$0[4], param$0 = param$1; continue }
              var d = param$0[3], v = param$0[2];
              return [0, v, d]
            }
          }
          function max_binding_opt(param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              if (param$0[4]) { var param$1 = param$0[4], param$0 = param$1; continue }
              var d = param$0[3], v = param$0[2];
              return [0, [0, v, d]]
            }
          }
          function remove_min_binding(param) {
            if (!param) return invalid_arg(cst_Map_remove_min_elt);
            var _v__ = param[1];
            if (_v__) {
              var r = param[4], d = param[3], v = param[2];
              return bal(remove_min_binding(_v__), v, d, r)
            }
            var r$0 = param[4];
            return r$0
          }
          function _vJ_(t1, t2) {
            if (!t1) return t2;
            if (!t2) return t1;
            var match = min_binding(t2), d = match[2], x = match[1];
            return bal(t1, x, d, remove_min_binding(t2))
          }
          function remove(x, m) {
            if (!m) return 0;
            var r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) return _vJ_(l, r);
            if (0 <= c) { var rr = remove(x, r); return r === rr ? m : bal(l, v, d, rr) }
            var ll = remove(x, l);
            return l === ll ? m : bal(ll, v, d, r)
          }
          function update(x, f, m) {
            if (!m) {
              var match$0 = caml_call1(f, 0);
              if (!match$0) return 0;
              var data$0 = match$0[1];
              return [0, 0, x, data$0, 0, 1]
            }
            var h = m[5], r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x, v);
            if (0 === c) {
              var match = caml_call1(f, [0, d]);
              if (!match) return _vJ_(l, r);
              var data = match[1];
              return d === data ? m : [0, l, x, data, r, h]
            }
            if (0 <= c) { var rr = update(x, f, r); return r === rr ? m : bal(l, v, d, rr) }
            var ll = update(x, f, l);
            return l === ll ? m : bal(ll, v, d, r)
          }
          function iter(f, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
              iter(f, l);
              caml_call2(f, v, d);
              var param$0 = r
            }
          }
          function map(f, param) {
            if (!param) return 0;
            var
              h = param[5],
              r = param[4],
              d = param[3],
              v = param[2],
              l = param[1],
              l$0 = map(f, l),
              d$0 = caml_call1(f, d),
              r$0 = map(f, r);
            return [0, l$0, v, d$0, r$0, h]
          }
          function mapi(f, param) {
            if (!param) return 0;
            var
              h = param[5],
              r = param[4],
              d = param[3],
              v = param[2],
              l = param[1],
              l$0 = mapi(f, l),
              d$0 = caml_call2(f, v, d),
              r$0 = mapi(f, r);
            return [0, l$0, v, d$0, r$0, h]
          }
          function fold(f, m, accu) {
            var m$0 = m, accu$0 = accu;
            for (; ;) {
              if (!m$0) return accu$0;
              var
                r = m$0[4],
                d = m$0[3],
                v = m$0[2],
                l = m$0[1],
                accu$1 = caml_call3(f, v, d, fold(f, l, accu$0)),
                m$0 = r,
                accu$0 = accu$1
            }
          }
          function for_all(p, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 1;
              var
                r = param$0[4],
                d = param$0[3],
                v = param$0[2],
                l = param$0[1],
                _v7_ = caml_call2(p, v, d);
              if (_v7_) {
                var _v8_ = for_all(p, l);
                if (_v8_) { var param$0 = r; continue }
                var _v9_ = _v8_
              }
              else
                var _v9_ = _v7_;
              return _v9_
            }
          }
          function exists(p, param) {
            var param$0 = param;
            for (; ;) {
              if (!param$0) return 0;
              var
                r = param$0[4],
                d = param$0[3],
                v = param$0[2],
                l = param$0[1],
                _v4_ = caml_call2(p, v, d);
              if (_v4_)
                var _v5_ = _v4_;
              else {
                var _v6_ = exists(p, l);
                if (!_v6_) { var param$0 = r; continue }
                var _v5_ = _v6_
              }
              return _v5_
            }
          }
          function add_min_binding(k, x, param) {
            if (!param) return singleton(k, x);
            var r = param[4], d = param[3], v = param[2], l = param[1];
            return bal(add_min_binding(k, x, l), v, d, r)
          }
          function add_max_binding(k, x, param) {
            if (!param) return singleton(k, x);
            var r = param[4], d = param[3], v = param[2], l = param[1];
            return bal(l, v, d, add_max_binding(k, x, r))
          }
          function join(l, v, d, r) {
            if (!l) return add_min_binding(v, d, r);
            if (!r) return add_max_binding(v, d, l);
            var
              rh = r[5],
              rr = r[4],
              rd = r[3],
              rv = r[2],
              rl = r[1],
              lh = l[5],
              lr = l[4],
              ld = l[3],
              lv = l[2],
              ll = l[1];
            return (rh + 2 | 0) < lh
              ? bal(ll, lv, ld, join(lr, v, d, r))
              : (lh + 2 | 0) < rh
                ? bal(join(l, v, d, rl), rv, rd, rr)
                : create(l, v, d, r)
          }
          function concat(t1, t2) {
            if (!t1) return t2;
            if (!t2) return t1;
            var match = min_binding(t2), d = match[2], x = match[1];
            return join(t1, x, d, remove_min_binding(t2))
          }
          function concat_or_join(t1, v, d, t2) { if (!d) return concat(t1, t2); var d$0 = d[1]; return join(t1, v, d$0, t2) }
          function split(x, param) {
            if (!param) return _W_;
            var
              r = param[4],
              d = param[3],
              v = param[2],
              l = param[1],
              c = caml_call2(Ord[1], x, v);
            if (0 === c) return [0, l, [0, d], r];
            if (0 <= c) {
              var match = split(x, r), rr = match[3], pres = match[2], lr = match[1];
              return [0, join(l, v, d, lr), pres, rr]
            }
            var
              match$0 = split(x, l),
              rl = match$0[3],
              pres$0 = match$0[2],
              ll = match$0[1];
            return [0, ll, pres$0, join(rl, v, d, r)]
          }
          function merge(f, s1, s2) {
            if (s1) {
              var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
              if (height(s2) <= h1) {
                var
                match = split(v1, s2),
                r2 = match[3],
                d2 = match[2],
                l2 = match[1],
                _v0_ = merge(f, r1, r2),
                _v1_ = caml_call3(f, v1, [0, d1], d2);
                return concat_or_join(merge(f, l1, l2), v1, _v1_, _v0_)
              }
            }
            else
              if (!s2) return 0;
            if (!s2) throw [0, Assert_failure, _X_];
            var
              r2$0 = s2[4],
              d2$0 = s2[3],
              v2 = s2[2],
              l2$0 = s2[1],
              match$0 = split(v2, s1),
              r1$0 = match$0[3],
              d1$0 = match$0[2],
              l1$0 = match$0[1],
              _v2_ = merge(f, r1$0, r2$0),
              _v3_ = caml_call3(f, v2, d1$0, [0, d2$0]);
            return concat_or_join(merge(f, l1$0, l2$0), v2, _v3_, _v2_)
          }
          function union(f, s1, s2) {
            if (s1) {
              if (s2) {
                var
                h2 = s2[5],
                r2 = s2[4],
                d2 = s2[3],
                v2 = s2[2],
                l2 = s2[1],
                h1 = s1[5],
                r1 = s1[4],
                d1 = s1[3],
                v1 = s1[2],
                l1 = s1[1];
                if (h2 <= h1) {
                  var
                  match = split(v1, s2),
                  r2$0 = match[3],
                  d2$0 = match[2],
                  l2$0 = match[1],
                  l = union(f, l1, l2$0),
                  r = union(f, r1, r2$0);
                  if (!d2$0) return join(l, v1, d1, r);
                  var d2$1 = d2$0[1];
                  return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r)
                }
                var
                  match$0 = split(v2, s1),
                  r1$0 = match$0[3],
                  d1$0 = match$0[2],
                  l1$0 = match$0[1],
                  l$0 = union(f, l1$0, l2),
                  r$0 = union(f, r1$0, r2);
                if (!d1$0) return join(l$0, v2, d2, r$0);
                var d1$1 = d1$0[1];
                return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0)
              }
              var s = s1
            }
            else
              var s = s2;
            return s
          }
          function filter(p, m) {
            if (!m) return 0;
            var
              r = m[4],
              d = m[3],
              v = m[2],
              l = m[1],
              l$0 = filter(p, l),
              pvd = caml_call2(p, v, d),
              r$0 = filter(p, r);
            if (!pvd) return concat(l$0, r$0);
            if (l === l$0 && r === r$0) return m;
            return join(l$0, v, d, r$0)
          }
          function filter_map(f, param) {
            if (!param) return 0;
            var
              r = param[4],
              d = param[3],
              v = param[2],
              l = param[1],
              l$0 = filter_map(f, l),
              fvd = caml_call2(f, v, d),
              r$0 = filter_map(f, r);
            if (!fvd) return concat(l$0, r$0);
            var d$0 = fvd[1];
            return join(l$0, v, d$0, r$0)
          }
          function partition(p, param) {
            if (!param) return _Y_;
            var
              r = param[4],
              d = param[3],
              v = param[2],
              l = param[1],
              match = partition(p, l),
              lf = match[2],
              lt = match[1],
              pvd = caml_call2(p, v, d),
              match$0 = partition(p, r),
              rf = match$0[2],
              rt = match$0[1];
            if (pvd) { var _vY_ = concat(lf, rf); return [0, join(lt, v, d, rt), _vY_] }
            var _vZ_ = join(lf, v, d, rf);
            return [0, concat(lt, rt), _vZ_]
          }
          function cons_enum(m, e) {
            var m$0 = m, e$0 = e;
            for (; ;) {
              if (!m$0) return e$0;
              var
                r = m$0[4],
                d = m$0[3],
                v = m$0[2],
                m$1 = m$0[1],
                e$1 = [0, v, d, r, e$0],
                m$0 = m$1,
                e$0 = e$1
            }
          }
          function compare(cmp, m1, m2) {
            var e2$2 = cons_enum(m2, 0), e1$2 = cons_enum(m1, 0), e1 = e1$2, e2 = e2$2;
            for (; ;) {
              if (!e1) return e2 ? -1 : 0;
              if (!e2) return 1;
              var
                e2$0 = e2[4],
                r2 = e2[3],
                d2 = e2[2],
                v2 = e2[1],
                e1$0 = e1[4],
                r1 = e1[3],
                d1 = e1[2],
                v1 = e1[1],
                c = caml_call2(Ord[1], v1, v2);
              if (0 !== c) return c;
              var c$0 = caml_call2(cmp, d1, d2);
              if (0 !== c$0) return c$0;
              var
                e2$1 = cons_enum(r2, e2$0),
                e1$1 = cons_enum(r1, e1$0),
                e1 = e1$1,
                e2 = e2$1
            }
          }
          function equal(cmp, m1, m2) {
            var e2$2 = cons_enum(m2, 0), e1$2 = cons_enum(m1, 0), e1 = e1$2, e2 = e2$2;
            for (; ;) {
              if (!e1) return e2 ? 0 : 1;
              if (!e2) return 0;
              var
                e2$0 = e2[4],
                r2 = e2[3],
                d2 = e2[2],
                v2 = e2[1],
                e1$0 = e1[4],
                r1 = e1[3],
                d1 = e1[2],
                v1 = e1[1],
                _vV_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
              if (_vV_) {
                var _vW_ = caml_call2(cmp, d1, d2);
                if (_vW_) {
                  var
                  e2$1 = cons_enum(r2, e2$0),
                  e1$1 = cons_enum(r1, e1$0),
                  e1 = e1$1,
                  e2 = e2$1;
                  continue
                }
                var _vX_ = _vW_
              }
              else
                var _vX_ = _vV_;
              return _vX_
            }
          }
          function cardinal(param) {
            if (!param) return 0;
            var r = param[4], l = param[1], _vU_ = cardinal(r);
            return (cardinal(l) + 1 | 0) + _vU_ | 0
          }
          function bindings_aux(accu, param) {
            var accu$0 = accu, param$0 = param;
            for (; ;) {
              if (!param$0) return accu$0;
              var
                r = param$0[4],
                d = param$0[3],
                v = param$0[2],
                l = param$0[1],
                accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)],
                accu$0 = accu$1,
                param$0 = l
            }
          }
          function bindings(s) { return bindings_aux(0, s) }
          function add_seq(i, m) {
            return fold_left
              (function (m, param) { var v = param[2], k = param[1]; return add(k, v, m) },
                m,
                i)
          }
          function of_seq(i) { return add_seq(i, empty) }
          function seq_of_enum(c, param) {
            if (!c) return 0;
            var rest = c[4], t = c[3], v = c[2], k = c[1], _vS_ = cons_enum(t, rest);
            return [0, [0, k, v], function (_vT_) { return seq_of_enum(_vS_, _vT_) }]
          }
          function to_seq(m) {
            var _vQ_ = cons_enum(m, 0);
            return function (_vR_) { return seq_of_enum(_vQ_, _vR_) }
          }
          function snoc_enum(s, e) {
            var s$0 = s, e$0 = e;
            for (; ;) {
              if (!s$0) return e$0;
              var
                s$1 = s$0[4],
                d = s$0[3],
                v = s$0[2],
                l = s$0[1],
                e$1 = [0, v, d, l, e$0],
                s$0 = s$1,
                e$0 = e$1
            }
          }
          function rev_seq_of_enum(c, param) {
            if (!c) return 0;
            var rest = c[4], t = c[3], v = c[2], k = c[1], _vO_ = snoc_enum(t, rest);
            return [0,
              [0, k, v],
              function (_vP_) { return rev_seq_of_enum(_vO_, _vP_) }]
          }
          function to_rev_seq(c) {
            var _vM_ = snoc_enum(c, 0);
            return function (_vN_) { return rev_seq_of_enum(_vM_, _vN_) }
          }
          function to_seq_from(low, m) {
            var m$0 = m, c = 0;
            for (; ;) {
              if (m$0) {
                var
                r = m$0[4],
                d = m$0[3],
                v = m$0[2],
                l = m$0[1],
                n = caml_call2(Ord[1], v, low);
                if (0 !== n) {
                  if (0 <= n) { var c$0 = [0, v, d, r, c], m$0 = l, c = c$0; continue }
                  var m$0 = r;
                  continue
                }
                var _vK_ = [0, v, d, r, c]
              }
              else
                var _vK_ = c;
              return function (_vL_) { return seq_of_enum(_vK_, _vL_) }
            }
          }
          return [0,
            empty,
            is_empty,
            mem,
            add,
            update,
            singleton,
            remove,
            merge,
            union,
            compare,
            equal,
            iter,
            fold,
            for_all,
            exists,
            filter,
            filter_map,
            partition,
            cardinal,
            bindings,
            min_binding,
            min_binding_opt,
            max_binding,
            max_binding_opt,
            min_binding,
            min_binding_opt,
            split,
            find,
            find_opt,
            find_first,
            find_first_opt,
            find_last,
            find_last_opt,
            map,
            mapi,
            to_seq,
            to_rev_seq,
            to_seq_from,
            add_seq,
            of_seq]
        }];
  caml_register_global(802, Stdlib_Map, "Stdlib__Map");
  var Empty = [248, cst_Stdlib_Stack_Empty, caml_fresh_oo_id(0)];
  function create$0(param) { return [0, 0, 0] }
  function clear(s) { s[1] = 0; s[2] = 0; return 0 }
  function copy$3(s) { return [0, s[1], s[2]] }
  function push(x, s) { s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0 }
  function pop(s) {
    var _vI_ = s[1];
    if (!_vI_) throw Empty;
    var tl = _vI_[2], hd = _vI_[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd
  }
  function pop_opt(s) {
    var _vH_ = s[1];
    if (!_vH_) return 0;
    var tl = _vH_[2], hd = _vH_[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd]
  }
  function top(s) { var _vG_ = s[1]; if (!_vG_) throw Empty; var hd = _vG_[1]; return hd }
  function top_opt(s) { var _vF_ = s[1]; if (!_vF_) return 0; var hd = _vF_[1]; return [0, hd] }
  function is_empty$0(s) { return 0 === s[1] ? 1 : 0 }
  function length$2(s) { return s[2] }
  function iter$7(f, s) { return iter$2(f, s[1]) }
  function fold$2(f, acc, s) { return fold_left$0(f, acc, s[1]) }
  function to_seq$6(s) { return to_seq$1(s[1]) }
  function add_seq(q, i) { return iter(function (x) { return push(x, q) }, i) }
  function of_seq$4(g) { var s = create$0(0); add_seq(s, g); return s }
  var
    Stdlib_Stack =
      [0,
        Empty,
        create$0,
        push,
        pop,
        pop_opt,
        top,
        top_opt,
        clear,
        copy$3,
        is_empty$0,
        length$2,
        iter$7,
        fold$2,
        to_seq$6,
        add_seq,
        of_seq$4];
  caml_register_global(803, Stdlib_Stack, "Stdlib__Stack");
  var Empty$0 = [248, cst_Stdlib_Queue_Empty, caml_fresh_oo_id(0)];
  function create$1(param) { return [0, 0, 0, 0] }
  function clear$0(q) { q[1] = 0; q[2] = 0; q[3] = 0; return 0 }
  function add(x, q) {
    var cell = [0, x, 0], _vE_ = q[3];
    return _vE_
      ? (q[1] = q[1] + 1 | 0, _vE_[2] = cell, q[3] = cell, 0)
      : (q[1] = 1, q[2] = cell, q[3] = cell, 0)
  }
  function peek(q) {
    var _vD_ = q[2];
    if (!_vD_) throw Empty$0;
    var content = _vD_[1];
    return content
  }
  function peek_opt(q) { var _vC_ = q[2]; if (!_vC_) return 0; var content = _vC_[1]; return [0, content] }
  function take$0(q) {
    var _vA_ = q[2];
    if (!_vA_) throw Empty$0;
    var _vB_ = _vA_[1];
    if (_vA_[2]) { var next = _vA_[2]; q[1] = q[1] - 1 | 0; q[2] = next; return _vB_ }
    clear$0(q);
    return _vB_
  }
  function take_opt(q) {
    var _vy_ = q[2];
    if (!_vy_) return 0;
    var _vz_ = _vy_[1];
    if (_vy_[2]) { var next = _vy_[2]; q[1] = q[1] - 1 | 0; q[2] = next; return [0, _vz_] }
    clear$0(q);
    return [0, _vz_]
  }
  function copy$4(q) {
    var q_res = [0, q[1], 0, 0], prev = 0, cell = q[2];
    for (; ;) {
      if (!cell) { q_res[3] = prev; return q_res }
      var content = cell[1], next = cell[2], res = [0, content, 0];
      if (prev) prev[2] = res; else q_res[2] = res;
      var prev = res, cell = next
    }
  }
  function is_empty$1(q) { return 0 === q[1] ? 1 : 0 }
  function length$3(q) { return q[1] }
  function iter$8(f, q) {
    var cell = q[2];
    for (; ;) {
      if (!cell) return 0;
      var content = cell[1], next = cell[2];
      caml_call1(f, content);
      var cell = next
    }
  }
  function fold$3(f, accu$1, q) {
    var accu = accu$1, cell = q[2];
    for (; ;) {
      if (!cell) return accu;
      var
        content = cell[1],
        next = cell[2],
        accu$0 = caml_call2(f, accu, content),
        accu = accu$0,
        cell = next
    }
  }
  function transfer(q1, q2) {
    var _vw_ = 0 < q1[1] ? 1 : 0;
    if (!_vw_) return _vw_;
    var _vx_ = q2[3];
    return _vx_
      ? (q2[1]
        =
        q2[1]
        +
        q1[1]
        |
        0,
        _vx_[2]
        =
        q1[2],
        q2[3]
        =
        q1[3],
        clear$0(q1))
      : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear$0(q1))
  }
  function to_seq$7(q) {
    function aux(c, param) {
      if (!c) return 0;
      var x = c[1], next = c[2];
      return [0, x, function (_vv_) { return aux(next, _vv_) }]
    }
    var _vt_ = q[2];
    return function (_vu_) { return aux(_vt_, _vu_) }
  }
  function add_seq$0(q, i) { return iter(function (x) { return add(x, q) }, i) }
  function of_seq$5(g) { var q = create$1(0); add_seq$0(q, g); return q }
  var
    Stdlib_Queue =
      [0,
        Empty$0,
        create$1,
        add,
        add,
        take$0,
        take_opt,
        take$0,
        peek,
        peek_opt,
        peek,
        clear$0,
        copy$4,
        is_empty$1,
        length$3,
        iter$8,
        fold$3,
        transfer,
        to_seq$7,
        add_seq$0,
        of_seq$5];
  caml_register_global(804, Stdlib_Queue, "Stdlib__Queue");
  var
    Failure$0 = [248, cst_Stdlib_Stream_Failure, caml_fresh_oo_id(0)],
    Error = [248, cst_Stdlib_Stream_Error, caml_fresh_oo_id(0)];
  function count(param) { if (!param) return 0; var match = param[1], count = match[1]; return count }
  function data(param) { if (!param) return 0; var match = param[1], data = match[2]; return data }
  function fill_buff(b) { b[3] = input(b[1], b[2], 0, caml_ml_bytes_length(b[2])); b[4] = 0; return 0 }
  function get_data(count, d) {
    var d$0 = d;
    for (; ;) {
      if (typeof d$0 !== "number")
        switch (d$0[0]) {
          case 1:
            var d2 = d$0[2], d1 = d$0[1], match = get_data(count, d1);
            if (typeof match === "number") { var d$0 = d2; continue }
            if (0 !== match[0]) throw [0, Assert_failure, _Z_];
            var d11 = match[2], a = match[1];
            return [0, a, [1, d11, d2]];
          case 2:
            var
              f = d$0[1],
              _vp_ = caml_obj_tag(f),
              d$1 = 250 === _vp_ ? f[1] : 246 === _vp_ ? force_lazy_block(f) : f,
              d$0 = d$1;
            continue;
          case 3:
            var _vq_ = d$0[1], _vr_ = _vq_[1];
            if (_vr_) {
              var _vs_ = _vr_[1];
              if (!_vs_) return 0;
              var a$0 = _vs_[1];
              _vq_[1] = 0;
              return [0, a$0, d$0]
            }
            var match$0 = caml_call1(_vq_[2], count);
            if (match$0) { var a$1 = match$0[1]; return [0, a$1, d$0] }
            _vq_[1] = ___;
            return 0;
          case 4:
            var b = d$0[1];
            if (b[3] <= b[4]) fill_buff(b);
            if (0 === b[3]) return 0;
            var r = caml_bytes_unsafe_get(b[2], b[4]);
            b[4] = b[4] + 1 | 0;
            return [0, r, d$0]
        }
      return d$0
    }
  }
  function peek_data(s) {
    for (; ;) {
      var _vk_ = s[2];
      if (typeof _vk_ === "number") return 0;
      switch (_vk_[0]) {
        case 0: var a = _vk_[1]; return [0, a];
        case 1:
          var d = get_data(s[1], s[2]);
          if (typeof d === "number") return 0;
          if (0 !== d[0]) throw [0, Assert_failure, _$_];
          var a$0 = d[1];
          s[2] = d;
          return [0, a$0];
        case 2:
          var
            f = _vk_[1],
            _vl_ = caml_obj_tag(f),
            _vm_ = 250 === _vl_ ? f[1] : 246 === _vl_ ? force_lazy_block(f) : f;
          s[2] = _vm_;
          continue;
        case 3:
          var _vn_ = _vk_[1], _vo_ = _vn_[1];
          if (_vo_) { var a$1 = _vo_[1]; return a$1 }
          var x = caml_call1(_vn_[2], s[1]);
          _vn_[1] = [0, x];
          return x;
        default:
          var b = _vk_[1];
          if (b[3] <= b[4]) fill_buff(b);
          return 0 === b[3] ? (s[2] = 0, 0) : [0, caml_bytes_unsafe_get(b[2], b[4])]
      }
    }
  }
  function peek$0(param) { if (!param) return 0; var s = param[1]; return peek_data(s) }
  function junk_data(s) {
    for (; ;) {
      var _vi_ = s[2];
      if (typeof _vi_ !== "number")
        switch (_vi_[0]) {
          case 0: var d = _vi_[2]; s[1] = s[1] + 1 | 0; s[2] = d; return 0;
          case 3:
            var _vj_ = _vi_[1];
            if (_vj_[1]) { s[1] = s[1] + 1 | 0; _vj_[1] = 0; return 0 }
            break;
          case 4:
            var b = _vi_[1];
            if (b[3] <= b[4]) fill_buff(b);
            return 0 === b[3]
              ? (s[2] = 0, 0)
              : (s[1] = s[1] + 1 | 0, b[4] = b[4] + 1 | 0, 0)
        }
      var match = peek_data(s);
      if (match) continue;
      return 0
    }
  }
  function junk(param) { if (!param) return 0; var data = param[1]; return junk_data(data) }
  function nget_data(n, s) {
    if (0 >= n) return [0, 0, s[2], 0];
    var match = peek_data(s);
    if (!match) return [0, 0, s[2], 0];
    var a = match[1];
    junk_data(s);
    var
      match$0 = nget_data(n - 1 | 0, s),
      k = match$0[3],
      d = match$0[2],
      al = match$0[1];
    return [0, [0, a, al], [0, a, d], k + 1 | 0]
  }
  function npeek(n, param) {
    if (!param) return 0;
    var
      d$0 = param[1],
      match = nget_data(n, d$0),
      len = match[3],
      d = match[2],
      al = match[1];
    d$0[1] = d$0[1] - len | 0;
    d$0[2] = d;
    return al
  }
  function next(s) {
    var match = peek$0(s);
    if (!match) throw Failure$0;
    var a = match[1];
    junk(s);
    return a
  }
  function empty$2(s) { var match = peek$0(s); if (match) throw Failure$0; return 0 }
  function iter$9(f, strm) {
    for (; ;) {
      var match = peek$0(strm);
      if (!match) return 0;
      var a = match[1];
      junk(strm);
      caml_call1(f, a)
    }
  }
  function from(f) { return [0, [0, 0, [3, [0, 0, f]]]] }
  function of_list$1(l) {
    var _vh_ = 0;
    return [0, [0, 0, fold_right(function (x, l) { return [0, x, l] }, l, _vh_)]]
  }
  function of_string(s) {
    var count = [0, 0];
    return from
      (function (param) {
        var c = count[1];
        return c < caml_ml_string_length(s)
          ? (count[1]++, [0, caml_string_get(s, c)])
          : 0
      })
  }
  function of_bytes$0(s) {
    var count = [0, 0];
    return from
      (function (param) {
        var c = count[1];
        return c < caml_ml_bytes_length(s)
          ? (count[1]++, [0, caml_bytes_get(s, c)])
          : 0
      })
  }
  function of_channel(ic) { return [0, [0, 0, [4, [0, ic, caml_create_bytes(4096), 0, 0]]]] }
  function iapp(i, s) { var _vg_ = data(s); return [0, [0, 0, [1, data(i), _vg_]]] }
  function icons(i, s) { return [0, [0, 0, [0, i, data(s)]]] }
  function ising(i) { return [0, [0, 0, [0, i, 0]]] }
  function lapp(f, s) {
    return [0,
      [0,
        0,
        [2,
          [246,
            function (_ve_) { var _vf_ = data(s); return [1, data(caml_call1(f, 0)), _vf_] }]]]]
  }
  function lcons(f, s) {
    return [0,
      [0,
        0,
        [2,
          [246,
            function (_vc_) { var _vd_ = data(s); return [0, caml_call1(f, 0), _vd_] }]]]]
  }
  function lsing(f) { return [0, [0, 0, [2, [246, function (_vb_) { return [0, caml_call1(f, 0), 0] }]]]] }
  var sempty = 0;
  function slazy(f) { return [0, [0, 0, [2, [246, function (_va_) { return data(caml_call1(f, 0)) }]]]] }
  function dump(f, s) {
    print_string(cst_count);
    print_int(count(s));
    print_string(cst_data);
    dump_data(f, data(s));
    print_string(cst$6);
    return print_newline(0)
  }
  function dump_data(f, param) {
    if (typeof param === "number") return print_string(cst_Sempty);
    switch (param[0]) {
      case 0:
        var d = param[2], a = param[1];
        print_string(cst_Scons);
        caml_call1(f, a);
        print_string(cst$7);
        dump_data(f, d);
        return print_string(cst$8);
      case 1:
        var d2 = param[2], d1 = param[1];
        print_string(cst_Sapp);
        dump_data(f, d1);
        print_string(cst$9);
        dump_data(f, d2);
        return print_string(cst$10);
      case 2: return print_string(cst_Slazy);
      case 3: return print_string(cst_Sgen);
      default: return print_string(cst_Sbuffio)
    }
  }
  var
    Stdlib_Stream =
      [0,
        Failure$0,
        Error,
        from,
        of_list$1,
        of_string,
        of_bytes$0,
        of_channel,
        iter$9,
        next,
        empty$2,
        peek$0,
        junk,
        count,
        npeek,
        iapp,
        icons,
        ising,
        lapp,
        lcons,
        lsing,
        sempty,
        slazy,
        dump];
  caml_register_global(805, Stdlib_Stream, "Stdlib__Stream");
  function create$2(n) {
    var
    n$0 = 1 <= n ? n : 1,
    n$1 = max_string_length < n$0 ? max_string_length : n$0,
    s = caml_create_bytes(n$1);
    return [0, s, 0, n$1, s]
  }
  function contents(b) { return sub_string(b[1], 0, b[2]) }
  function to_bytes$0(b) { return sub(b[1], 0, b[2]) }
  function sub$3(b, ofs, len) {
    if (0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
      return sub_string(b[1], ofs, len);
    return invalid_arg(cst_Buffer_sub)
  }
  function blit$3(src, srcoff, dst, dstoff, len) {
    if
      (0
      <=
      len
      &&
      0
      <=
      srcoff
      &&
      (src[2] - len | 0)
      >=
      srcoff
      &&
      0
      <=
      dstoff
      &&
      (caml_ml_bytes_length(dst) - len | 0)
      >=
      dstoff)
      return caml_blit_bytes(src[1], srcoff, dst, dstoff, len);
    return invalid_arg(cst_Buffer_blit)
  }
  function nth$0(b, ofs) {
    if (0 <= ofs && b[2] > ofs) return caml_bytes_unsafe_get(b[1], ofs);
    return invalid_arg(cst_Buffer_nth)
  }
  function length$4(b) { return b[2] }
  function clear$1(b) { b[2] = 0; return 0 }
  function reset(b) { b[2] = 0; b[1] = b[4]; b[3] = caml_ml_bytes_length(b[1]); return 0 }
  function resize(b, more) {
    var old_pos = b[2], old_len = b[3], new_len = [0, old_len];
    for (; ;) {
      if (new_len[1] < (old_pos + more | 0)) { new_len[1] = 2 * new_len[1] | 0; continue }
      if (max_string_length < new_len[1])
        if ((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
        else
          failwith(cst_Buffer_add_cannot_grow_buf);
      var new_buffer = caml_create_bytes(new_len[1]);
      blit(b[1], 0, new_buffer, 0, b[2]);
      b[1] = new_buffer;
      b[3] = new_len[1];
      if ((b[2] + more | 0) > b[3]) throw [0, Assert_failure, _ab_];
      if ((old_pos + more | 0) <= b[3]) return 0;
      throw [0, Assert_failure, _aa_]
    }
  }
  function add_char(b, c) {
    var pos = b[2];
    if (b[3] <= pos) resize(b, 1);
    caml_bytes_unsafe_set(b[1], pos, c);
    b[2] = pos + 1 | 0;
    return 0
  }
  var uchar_utf_8_byte_length_max = 4, uchar_utf_16_byte_length_max = 4;
  function add_utf_8_uchar(b, u) {
    for (; ;) {
      var pos = b[2];
      if (b[3] <= pos) resize(b, uchar_utf_8_byte_length_max);
      var n = set_utf_8_uchar(b[1], pos, u);
      if (0 === n) { resize(b, uchar_utf_8_byte_length_max); continue }
      b[2] = pos + n | 0;
      return 0
    }
  }
  function add_utf_16be_uchar(b, u) {
    for (; ;) {
      var pos = b[2];
      if (b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
      var n = set_utf_16be_uchar(b[1], pos, u);
      if (0 === n) { resize(b, uchar_utf_16_byte_length_max); continue }
      b[2] = pos + n | 0;
      return 0
    }
  }
  function add_utf_16le_uchar(b, u) {
    for (; ;) {
      var pos = b[2];
      if (b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
      var n = set_utf_16le_uchar(b[1], pos, u);
      if (0 === n) { resize(b, uchar_utf_16_byte_length_max); continue }
      b[2] = pos + n | 0;
      return 0
    }
  }
  function add_substring(b, s, offset, len) {
    var _u9_ = offset < 0 ? 1 : 0;
    if (_u9_)
      var _u__ = _u9_;
    else
      var
        _u$_ = len < 0 ? 1 : 0,
        _u__ = _u$_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if (_u__) invalid_arg(cst_Buffer_add_substring_add_s);
    var new_position = b[2] + len | 0;
    if (b[3] < new_position) resize(b, len);
    caml_blit_string(s, offset, b[1], b[2], len);
    b[2] = new_position;
    return 0
  }
  function add_subbytes(b, s, offset, len) { return add_substring(b, caml_string_of_bytes(s), offset, len) }
  function add_string(b, s) {
    var len = caml_ml_string_length(s), new_position = b[2] + len | 0;
    if (b[3] < new_position) resize(b, len);
    caml_blit_string(s, 0, b[1], b[2], len);
    b[2] = new_position;
    return 0
  }
  function add_bytes(b, s) { return add_string(b, caml_string_of_bytes(s)) }
  function add_buffer(b, bs) { return add_subbytes(b, bs[1], 0, bs[2]) }
  function add_channel(b, ic, len) {
    var _u7_ = len < 0 ? 1 : 0, _u8_ = _u7_ || (max_string_length < len ? 1 : 0);
    if (_u8_) invalid_arg(cst_Buffer_add_channel);
    if (b[3] < (b[2] + len | 0)) resize(b, len);
    var already_read = 0, ofs = b[2], to_read = len, _u6_ = b[1];
    for (; ;) {
      if (0 !== to_read) {
        var r = input(ic, _u6_, ofs, to_read);
        if (0 !== r) {
          var
          already_read$0 = already_read + r | 0,
          ofs$0 = ofs + r | 0,
          to_read$0 = to_read - r | 0,
          already_read = already_read$0,
          ofs = ofs$0,
          to_read = to_read$0;
          continue
        }
      }
      if ((b[2] + already_read | 0) > b[3]) throw [0, Assert_failure, _ac_];
      b[2] = b[2] + already_read | 0;
      if (already_read < len) throw End_of_file;
      return 0
    }
  }
  function output_buffer(oc, b) { return output(oc, b[1], 0, b[2]) }
  function add_substitute(b, f, s) {
    var lim$1 = caml_ml_string_length(s), previous = 32, i$7 = 0;
    for (; ;) {
      if (i$7 >= lim$1) { var _u5_ = 92 === previous ? 1 : 0; return _u5_ ? add_char(b, previous) : _u5_ }
      var current = caml_string_get(s, i$7);
      if (36 !== current) {
        if (92 === previous) {
          add_char(b, 92);
          add_char(b, current);
          var i$9 = i$7 + 1 | 0, previous = 32, i$7 = i$9;
          continue
        }
        if (92 === current) { var i$10 = i$7 + 1 | 0, previous = current, i$7 = i$10; continue }
        add_char(b, current);
        var i$11 = i$7 + 1 | 0, previous = current, i$7 = i$11;
        continue
      }
      if (92 === previous) {
        add_char(b, current);
        var i$8 = i$7 + 1 | 0, previous = 32, i$7 = i$8;
        continue
      }
      var start = i$7 + 1 | 0;
      if (lim$1 <= start) throw Not_found;
      var opening = caml_string_get(s, start), switch$0 = 0;
      if (40 !== opening && 123 !== opening) {
        var i$6 = start + 1 | 0, lim$0 = caml_ml_string_length(s), i$3 = i$6;
        for (; ;) {
          if (lim$0 <= i$3)
            var stop = lim$0;
          else {
            var match = caml_string_get(s, i$3), switch$1 = 0;
            if (91 <= match) {
              if (97 <= match) { if (123 > match) switch$1 = 1 }
              else
                if (95 === match) switch$1 = 1
            }
            else
              if (58 <= match) { if (65 <= match) switch$1 = 1 }
              else
                if (48 <= match) switch$1 = 1;
            if (switch$1) { var i$4 = i$3 + 1 | 0, i$3 = i$4; continue }
            var stop = i$3
          }
          var match$0 = [0, sub$0(s, start, stop - start | 0), stop];
          switch$0 = 1;
          break
        }
      }
      if (!switch$0) {
        var i$5 = start + 1 | 0, k$2 = 0;
        if (40 === opening)
          var _u4_ = 41;
        else { if (123 !== opening) throw [0, Assert_failure, _ad_]; var _u4_ = 125 }
        var lim = caml_ml_string_length(s), k = k$2, i = i$5;
        for (; ;) {
          if (lim <= i) throw Not_found;
          if (caml_string_get(s, i) === opening) { var i$0 = i + 1 | 0, k$0 = k + 1 | 0, k = k$0, i = i$0; continue }
          if (caml_string_get(s, i) !== _u4_) { var i$2 = i + 1 | 0, i = i$2; continue }
          if (0 !== k) { var i$1 = i + 1 | 0, k$1 = k - 1 | 0, k = k$1, i = i$1; continue }
          var match$0 = [0, sub$0(s, i$5, (i - start | 0) - 1 | 0), i + 1 | 0];
          break
        }
      }
      var next_i = match$0[2], ident = match$0[1];
      add_string(b, caml_call1(f, ident));
      var previous = 32, i$7 = next_i
    }
  }
  function truncate(b, len) {
    if (0 <= len && b[2] >= len) { b[2] = len; return 0 }
    return invalid_arg(cst_Buffer_truncate)
  }
  function to_seq$8(b) {
    function aux(i, param) {
      if (b[2] <= i) return 0;
      var x = caml_bytes_unsafe_get(b[1], i), _u2_ = i + 1 | 0;
      return [0, x, function (_u3_) { return aux(_u2_, _u3_) }]
    }
    var _u0_ = 0;
    return function (_u1_) { return aux(_u0_, _u1_) }
  }
  function to_seqi$3(b) {
    function aux(i, param) {
      if (b[2] <= i) return 0;
      var x = caml_bytes_unsafe_get(b[1], i), _uY_ = i + 1 | 0;
      return [0, [0, i, x], function (_uZ_) { return aux(_uY_, _uZ_) }]
    }
    var _uW_ = 0;
    return function (_uX_) { return aux(_uW_, _uX_) }
  }
  function add_seq$1(b, seq) { return iter(function (_uV_) { return add_char(b, _uV_) }, seq) }
  function of_seq$6(i) { var b = create$2(32); add_seq$1(b, i); return b }
  function add_int8(b, x) {
    var new_position = b[2] + 1 | 0;
    if (b[3] < new_position) resize(b, 1);
    caml_bytes_unsafe_set(b[1], b[2], x);
    b[2] = new_position;
    return 0
  }
  function add_int16_ne(b, x) {
    var new_position = b[2] + 2 | 0;
    if (b[3] < new_position) resize(b, 2);
    caml_bytes_set16(b[1], b[2], x);
    b[2] = new_position;
    return 0
  }
  function add_int32_ne(b, x) {
    var new_position = b[2] + 4 | 0;
    if (b[3] < new_position) resize(b, 4);
    caml_bytes_set32(b[1], b[2], x);
    b[2] = new_position;
    return 0
  }
  function add_int64_ne(b, x) {
    var new_position = b[2] + 8 | 0;
    if (b[3] < new_position) resize(b, 8);
    caml_bytes_set64(b[1], b[2], x);
    b[2] = new_position;
    return 0
  }
  function add_int16_le(b, x) { return add_int16_ne(b, x) }
  function add_int16_be(b, x) { var x$0 = caml_bswap16(x); return add_int16_ne(b, x$0) }
  function add_int32_le(b, x) { return add_int32_ne(b, x) }
  function add_int32_be(b, x) { var x$0 = caml_int32_bswap(x); return add_int32_ne(b, x$0) }
  function add_int64_le(b, x) { return add_int64_ne(b, x) }
  function add_int64_be(b, x) { var x$0 = caml_int64_bswap(x); return add_int64_ne(b, x$0) }
  var
    Stdlib_Buffer =
      [0,
        create$2,
        contents,
        to_bytes$0,
        sub$3,
        blit$3,
        nth$0,
        length$4,
        clear$1,
        reset,
        output_buffer,
        truncate,
        add_char,
        add_utf_8_uchar,
        add_utf_16le_uchar,
        add_utf_16be_uchar,
        add_string,
        add_bytes,
        add_substring,
        add_subbytes,
        add_substitute,
        add_buffer,
        add_channel,
        to_seq$8,
        to_seqi$3,
        add_seq$1,
        of_seq$6,
        add_int8,
        add_int8,
        add_int16_ne,
        add_int16_be,
        add_int16_le,
        add_int16_ne,
        add_int16_be,
        add_int16_le,
        add_int32_ne,
        add_int32_be,
        add_int32_le,
        add_int64_ne,
        add_int64_be,
        add_int64_le];
  caml_register_global(806, Stdlib_Buffer, "Stdlib__Buffer");
  function create_char_set(param) { return make$0(32, 0) }
  function add_in_char_set(char_set, c) {
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return caml_bytes_set
      (char_set,
        str_ind,
        char_of_int(caml_bytes_get(char_set, str_ind) | mask))
  }
  function freeze_char_set(char_set) { return of_bytes(char_set) }
  function rev_char_set(char_set) {
    var char_set$0 = create_char_set(0), i = 0;
    for (; ;) {
      caml_bytes_set
        (char_set$0, i, char_of_int(caml_string_get(char_set, i) ^ 255));
      var _uU_ = i + 1 | 0;
      if (31 === i) return caml_string_of_bytes(char_set$0);
      var i = _uU_
    }
  }
  function is_in_char_set(char_set, c) {
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0
  }
  function pad_of_pad_opt(pad_opt) { if (!pad_opt) return 0; var width = pad_opt[1]; return [0, 1, width] }
  function param_format_of_ignored_format(ign, fmt) {
    if (typeof ign === "number")
      switch (ign) {
        case 0: return [0, [0, fmt]];
        case 1: return [0, [1, fmt]];
        case 2: return [0, [19, fmt]];
        default: return [0, [22, fmt]]
      }
    switch (ign[0]) {
      case 0: var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
        var pad_opt$0 = ign[1]; return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
        var pad_opt$1 = ign[2], iconv = ign[1];
        return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
        var pad_opt$2 = ign[2], iconv$0 = ign[1];
        return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
        var pad_opt$3 = ign[2], iconv$1 = ign[1];
        return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
        var pad_opt$4 = ign[2], iconv$2 = ign[1];
        return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
        var prec_opt = ign[2], pad_opt$5 = ign[1];
        if (prec_opt) var ndec = prec_opt[1], _uT_ = [0, ndec]; else var _uT_ = 0;
        return [0, [8, _ae_, pad_of_pad_opt(pad_opt$5), _uT_, fmt]];
      case 7:
        var pad_opt$6 = ign[1]; return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
        var fmtty = ign[2], pad_opt$7 = ign[1];
        return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
        var fmtty$0 = ign[2], pad_opt$8 = ign[1];
        return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
        var char_set = ign[2], width_opt = ign[1];
        return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]]
    }
  }
  function default_float_precision(fconv) { return 5 === fconv[2] ? 12 : -6 }
  function buffer_create(init_size) { return [0, 0, caml_create_bytes(init_size)] }
  function buffer_check_size(buf, overhead) {
    var
    len = caml_ml_bytes_length(buf[2]),
    min_len = buf[1] + overhead | 0,
    _uR_ = len < min_len ? 1 : 0;
    if (_uR_) {
      var
      new_len = max$1(len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
      blit(buf[2], 0, new_str, 0, len);
      buf[2] = new_str;
      var _uS_ = 0
    }
    else
      var _uS_ = _uR_;
    return _uS_
  }
  function buffer_add_char(buf, c) {
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return 0
  }
  function buffer_add_string(buf, s) {
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    blit$0(s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return 0
  }
  function buffer_contents(buf) { return sub_string(buf[2], 0, buf[1]) }
  function char_of_iconv(iconv) {
    switch (iconv) {
      case 6:
      case 7: return 120;
      case 8:
      case 9: return 88;
      case 10:
      case 11: return 111;
      case 12:
      case 15: return 117;
      case 0:
      case 1:
      case 2:
      case 13: return 100;
      default: return 105
    }
  }
  function char_of_fconv(opt, fconv) {
    if (opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch (fconv[2]) {
      case 0: return 102;
      case 1: return 101;
      case 2: return 69;
      case 3: return 103;
      case 4: return 71;
      case 5: return cF;
      case 6: return 104;
      case 7: return 72;
      default: return 70
    }
  }
  function bprint_padty(buf, padty) {
    switch (padty) {
      case 0: return buffer_add_char(buf, 45);
      case 1: return 0;
      default: return buffer_add_char(buf, 48)
    }
  }
  function bprint_ignored_flag(buf, ign_flag) { return ign_flag ? buffer_add_char(buf, 95) : ign_flag }
  function bprint_pad_opt(buf, pad_opt) {
    if (!pad_opt) return 0;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_string_of_jsbytes("" + width))
  }
  function bprint_padding(buf, pad) {
    if (typeof pad === "number") return 0;
    if (0 === pad[0]) {
      var n = pad[2], padty = pad[1];
      bprint_padty(buf, padty);
      return buffer_add_string(buf, caml_string_of_jsbytes("" + n))
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42)
  }
  function bprint_precision(buf, prec) {
    if (typeof prec === "number") return prec ? buffer_add_string(buf, cst$11) : 0;
    var n = prec[1];
    buffer_add_char(buf, 46);
    return buffer_add_string(buf, caml_string_of_jsbytes("" + n))
  }
  function bprint_iconv_flag(buf, iconv) {
    switch (iconv) {
      case 1:
      case 4: return buffer_add_char(buf, 43);
      case 2:
      case 5: return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15: return buffer_add_char(buf, 35);
      default: return 0
    }
  }
  function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv))
  }
  function bprint_fconv_flag(buf, fconv) {
    switch (fconv[1]) {
      case 0: break;
      case 1: buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32)
    }
    return 8 <= fconv[2] ? buffer_add_char(buf, 35) : 0
  }
  function string_of_formatting_lit(formatting_lit) {
    if (typeof formatting_lit === "number")
      switch (formatting_lit) {
        case 0: return cst$12;
        case 1: return cst$13;
        case 2: return cst$14;
        case 3: return cst$15;
        case 4: return cst$16;
        case 5: return cst$17;
        default: return cst$18
      }
    switch (formatting_lit[0]) {
      case 0: var str = formatting_lit[1]; return str;
      case 1: var str$0 = formatting_lit[1]; return str$0;
      default: var c = formatting_lit[1]; return cat(cst$19, make$1(1, c))
    }
  }
  function bprint_char_literal(buf, chr) { return 37 === chr ? buffer_add_string(buf, cst$20) : buffer_add_char(buf, chr) }
  function bprint_string_literal(buf, str) {
    var _uP_ = caml_ml_string_length(str) - 1 | 0, _uO_ = 0;
    if (_uP_ >= 0) {
      var i = _uO_;
      for (; ;) {
        bprint_char_literal(buf, caml_string_get(str, i));
        var _uQ_ = i + 1 | 0;
        if (_uP_ !== i) { var i = _uQ_; continue }
        break
      }
    }
    return 0
  }
  function bprint_fmtty(buf, fmtty) {
    var fmtty$0 = fmtty;
    for (; ;) {
      if (typeof fmtty$0 === "number") return 0;
      switch (fmtty$0[0]) {
        case 0:
          var rest = fmtty$0[1];
          buffer_add_string(buf, cst_c);
          var fmtty$0 = rest;
          continue;
        case 1:
          var rest$0 = fmtty$0[1];
          buffer_add_string(buf, cst_s);
          var fmtty$0 = rest$0;
          continue;
        case 2:
          var rest$1 = fmtty$0[1];
          buffer_add_string(buf, cst_i);
          var fmtty$0 = rest$1;
          continue;
        case 3:
          var rest$2 = fmtty$0[1];
          buffer_add_string(buf, cst_li);
          var fmtty$0 = rest$2;
          continue;
        case 4:
          var rest$3 = fmtty$0[1];
          buffer_add_string(buf, cst_ni);
          var fmtty$0 = rest$3;
          continue;
        case 5:
          var rest$4 = fmtty$0[1];
          buffer_add_string(buf, cst_Li);
          var fmtty$0 = rest$4;
          continue;
        case 6:
          var rest$5 = fmtty$0[1];
          buffer_add_string(buf, cst_f);
          var fmtty$0 = rest$5;
          continue;
        case 7:
          var rest$6 = fmtty$0[1];
          buffer_add_string(buf, cst_B);
          var fmtty$0 = rest$6;
          continue;
        case 8:
          var rest$7 = fmtty$0[2], sub_fmtty = fmtty$0[1];
          buffer_add_string(buf, cst$21);
          bprint_fmtty(buf, sub_fmtty);
          buffer_add_string(buf, cst$22);
          var fmtty$0 = rest$7;
          continue;
        case 9:
          var rest$8 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
          buffer_add_string(buf, cst$23);
          bprint_fmtty(buf, sub_fmtty$0);
          buffer_add_string(buf, cst$24);
          var fmtty$0 = rest$8;
          continue;
        case 10:
          var rest$9 = fmtty$0[1];
          buffer_add_string(buf, cst_a);
          var fmtty$0 = rest$9;
          continue;
        case 11:
          var rest$10 = fmtty$0[1];
          buffer_add_string(buf, cst_t$0);
          var fmtty$0 = rest$10;
          continue;
        case 12:
          var rest$11 = fmtty$0[1];
          buffer_add_string(buf, cst$25);
          var fmtty$0 = rest$11;
          continue;
        case 13:
          var rest$12 = fmtty$0[1];
          buffer_add_string(buf, cst_r$0);
          var fmtty$0 = rest$12;
          continue;
        default:
          var rest$13 = fmtty$0[1];
          buffer_add_string(buf, cst_r$1);
          var fmtty$0 = rest$13;
          continue
      }
    }
  }
  function int_of_custom_arity(param) {
    if (!param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0
  }
  function string_of_fmt(fmt) {
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag) {
      var fmt$0 = fmt, ign_flag$0 = ign_flag;
      a:
      for (; ;) {
        if (typeof fmt$0 === "number") return 0;
        switch (fmt$0[0]) {
          case 0:
            var rest = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            buffer_add_char(buf, 99);
            var fmt$0 = rest, ign_flag$0 = 0;
            continue;
          case 1:
            var rest$0 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            buffer_add_char(buf, 67);
            var fmt$0 = rest$0, ign_flag$0 = 0;
            continue;
          case 2:
            var rest$1 = fmt$0[2], pad = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_padding(buf, pad);
            buffer_add_char(buf, 115);
            var fmt$0 = rest$1, ign_flag$0 = 0;
            continue;
          case 3:
            var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_padding(buf, pad$0);
            buffer_add_char(buf, 83);
            var fmt$0 = rest$2, ign_flag$0 = 0;
            continue;
          case 4:
            var rest$3 = fmt$0[4], prec = fmt$0[3], pad$1 = fmt$0[2], iconv = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_iconv_flag(buf, iconv);
            bprint_padding(buf, pad$1);
            bprint_precision(buf, prec);
            buffer_add_char(buf, char_of_iconv(iconv));
            var fmt$0 = rest$3, ign_flag$0 = 0;
            continue;
          case 5:
            var
              rest$4 = fmt$0[4],
              prec$0 = fmt$0[3],
              pad$2 = fmt$0[2],
              iconv$0 = fmt$0[1];
            bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
            var fmt$0 = rest$4, ign_flag$0 = 0;
            continue;
          case 6:
            var
              rest$5 = fmt$0[4],
              prec$1 = fmt$0[3],
              pad$3 = fmt$0[2],
              iconv$1 = fmt$0[1];
            bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
            var fmt$0 = rest$5, ign_flag$0 = 0;
            continue;
          case 7:
            var
              rest$6 = fmt$0[4],
              prec$2 = fmt$0[3],
              pad$4 = fmt$0[2],
              iconv$2 = fmt$0[1];
            bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
            var fmt$0 = rest$6, ign_flag$0 = 0;
            continue;
          case 8:
            var
              rest$7 = fmt$0[4],
              prec$3 = fmt$0[3],
              pad$5 = fmt$0[2],
              fconv = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_fconv_flag(buf, fconv);
            bprint_padding(buf, pad$5);
            bprint_precision(buf, prec$3);
            buffer_add_char(buf, char_of_fconv(0, fconv));
            var fmt$0 = rest$7, ign_flag$0 = 0;
            continue;
          case 9:
            var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_padding(buf, pad$6);
            buffer_add_char(buf, 66);
            var fmt$0 = rest$8, ign_flag$0 = 0;
            continue;
          case 10:
            var rest$9 = fmt$0[1];
            buffer_add_string(buf, cst$26);
            var fmt$0 = rest$9;
            continue;
          case 11:
            var rest$10 = fmt$0[2], str = fmt$0[1];
            bprint_string_literal(buf, str);
            var fmt$0 = rest$10;
            continue;
          case 12:
            var rest$11 = fmt$0[2], chr$0 = fmt$0[1];
            bprint_char_literal(buf, chr$0);
            var fmt$0 = rest$11;
            continue;
          case 13:
            var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_pad_opt(buf, pad_opt);
            buffer_add_char(buf, 123);
            bprint_fmtty(buf, fmtty);
            buffer_add_char(buf, 37);
            buffer_add_char(buf, 125);
            var fmt$0 = rest$12, ign_flag$0 = 0;
            continue;
          case 14:
            var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_pad_opt(buf, pad_opt$0);
            buffer_add_char(buf, 40);
            bprint_fmtty(buf, fmtty$0);
            buffer_add_char(buf, 37);
            buffer_add_char(buf, 41);
            var fmt$0 = rest$13, ign_flag$0 = 0;
            continue;
          case 15:
            var rest$14 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            buffer_add_char(buf, 97);
            var fmt$0 = rest$14, ign_flag$0 = 0;
            continue;
          case 16:
            var rest$15 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            buffer_add_char(buf, 116);
            var fmt$0 = rest$15, ign_flag$0 = 0;
            continue;
          case 17:
            var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
            bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
            var fmt$0 = rest$16;
            continue;
          case 18:
            var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
            if (0 === fmting_gen[0]) {
              var match$1 = fmting_gen[1], str$0 = match$1[2];
              buffer_add_string(buf, cst$27);
              buffer_add_string(buf, str$0)
            }
            else {
              var match$2 = fmting_gen[1], str$1 = match$2[2];
              buffer_add_string(buf, cst$28);
              buffer_add_string(buf, str$1)
            }
            var fmt$0 = rest$17;
            continue;
          case 19:
            var rest$18 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            buffer_add_char(buf, 114);
            var fmt$0 = rest$18, ign_flag$0 = 0;
            continue;
          case 20:
            var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_pad_opt(buf, width_opt);
            var
              print_char =
                function (buf, i) {
                  var c = char_of_int(i);
                  return 37 === c
                    ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                    : 64 === c
                      ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                      : buffer_add_char(buf, c)
                };
            buffer_add_char(buf, 91);
            var
              _uE_ =
                is_in_char_set(char_set, 0)
                  ? (buffer_add_char(buf, 94), rev_char_set(char_set))
                  : char_set,
              is_alone$0 =
                function (_uJ_) {
                  function is_alone(c) {
                    var
                    after = chr(c + 1 | 0),
                    before = chr(c - 1 | 0),
                    _uK_ = is_in_char_set(_uJ_, c);
                    if (_uK_)
                      var
                        _uL_ = is_in_char_set(_uJ_, before),
                        _uM_ = _uL_ ? is_in_char_set(_uJ_, after) : _uL_,
                        _uN_ = 1 - _uM_;
                    else
                      var _uN_ = _uK_;
                    return _uN_
                  }
                  return is_alone
                },
              is_alone = is_alone$0(_uE_);
            if (is_alone(93)) buffer_add_char(buf, 93);
            var i = 1;
            b:
            for (; ;) {
              if (i < 256) {
                if (!is_in_char_set(_uE_, char_of_int(i))) { var i$0 = i + 1 | 0, i = i$0; continue }
                var match = char_of_int(i), switcher = match - 45 | 0, switch$0 = 0;
                if (48 < switcher >>> 0)
                  if (210 <= switcher) print_char(buf, 255); else switch$0 = 1;
                else {
                  if (46 < switcher - 1 >>> 0) { var i$2 = i + 1 | 0, i = i$2; continue }
                  switch$0 = 1
                }
                if (switch$0) {
                  var i$1 = i + 1 | 0;
                  if (!is_in_char_set(_uE_, char_of_int(i$1))) {
                    print_char(buf, i$1 - 1 | 0);
                    var i$6 = i$1 + 1 | 0, i = i$6;
                    continue
                  }
                  var
                    match$0 = char_of_int(i$1),
                    switcher$0 = match$0 - 45 | 0,
                    switch$1 = 0;
                  if (48 < switcher$0 >>> 0)
                    if (210 <= switcher$0) { print_char(buf, 254); print_char(buf, 255) }
                    else
                      switch$1 = 1;
                  else
                    if (46 < switcher$0 - 1 >>> 0) {
                      if (!is_in_char_set(_uE_, char_of_int(i$1 + 1 | 0))) {
                        print_char(buf, i$1 - 1 | 0);
                        var i$5 = i$1 + 1 | 0, i = i$5;
                        continue
                      }
                      switch$1 = 1
                    }
                    else
                      switch$1 = 1;
                  if (switch$1) {
                    if (!is_in_char_set(_uE_, char_of_int(i$1 + 1 | 0))) {
                      print_char(buf, i$1 - 1 | 0);
                      print_char(buf, i$1);
                      var i$4 = i$1 + 2 | 0, i = i$4;
                      continue
                    }
                    var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                    for (; ;) {
                      if (256 !== j$0 && is_in_char_set(_uE_, char_of_int(j$0))) { var j$1 = j$0 + 1 | 0, j$0 = j$1; continue }
                      print_char(buf, i$3);
                      print_char(buf, 45);
                      print_char(buf, j$0 - 1 | 0);
                      if (j$0 < 256) { var i$7 = j$0 + 1 | 0, i = i$7; continue b }
                      break
                    }
                  }
                }
              }
              if (is_alone(45)) buffer_add_char(buf, 45);
              buffer_add_char(buf, 93);
              var fmt$0 = rest$19, ign_flag$0 = 0;
              continue a
            }
          case 21:
            var rest$20 = fmt$0[2], counter = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            switch (counter) {
              case 0: var _uF_ = 108; break;
              case 1: var _uF_ = 110; break;
              default: var _uF_ = 78
            }
            buffer_add_char(buf, _uF_);
            var fmt$0 = rest$20, ign_flag$0 = 0;
            continue;
          case 22:
            var rest$21 = fmt$0[1];
            buffer_add_char(buf, 37);
            bprint_ignored_flag(buf, ign_flag$0);
            bprint_string_literal(buf, cst_0c);
            var fmt$0 = rest$21, ign_flag$0 = 0;
            continue;
          case 23:
            var
              rest$22 = fmt$0[2],
              ign = fmt$0[1],
              match$3 = param_format_of_ignored_format(ign, rest$22),
              fmt$1 = match$3[1],
              fmt$0 = fmt$1,
              ign_flag$0 = 1;
            continue;
          default:
            var
              rest$23 = fmt$0[3],
              arity = fmt$0[1],
              _uH_ = int_of_custom_arity(arity),
              _uG_ = 1;
            if (_uH_ >= 1) {
              var i$8 = _uG_;
              for (; ;) {
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 63);
                var _uI_ = i$8 + 1 | 0;
                if (_uH_ !== i$8) { var i$8 = _uI_; continue }
                break
              }
            }
            var fmt$0 = rest$23, ign_flag$0 = 0;
            continue
        }
      }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf)
  }
  function symm(param) {
    if (typeof param === "number") return 0;
    switch (param[0]) {
      case 0: var rest = param[1]; return [0, symm(rest)];
      case 1: var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2: var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3: var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4: var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5: var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6: var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7: var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8: var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
        var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
        return [9, ty2, ty1, symm(rest$8)];
      case 10: var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11: var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12: var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13: var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)]
    }
  }
  function fmtty_rel_det(param) {
    if (typeof param !== "number")
      switch (param[0]) {
        case 0:
          var
            rest = param[1],
            match = fmtty_rel_det(rest),
            de = match[4],
            ed = match[3],
            af = match[2],
            fa = match[1],
            _uj_ = function (param) { caml_call1(af, 0); return 0 };
          return [0, function (param) { caml_call1(fa, 0); return 0 }, _uj_, ed, de];
        case 1:
          var
            rest$0 = param[1],
            match$0 = fmtty_rel_det(rest$0),
            de$0 = match$0[4],
            ed$0 = match$0[3],
            af$0 = match$0[2],
            fa$0 = match$0[1],
            _uk_ = function (param) { caml_call1(af$0, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$0, 0); return 0 },
            _uk_,
            ed$0,
            de$0];
        case 2:
          var
            rest$1 = param[1],
            match$1 = fmtty_rel_det(rest$1),
            de$1 = match$1[4],
            ed$1 = match$1[3],
            af$1 = match$1[2],
            fa$1 = match$1[1],
            _ul_ = function (param) { caml_call1(af$1, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$1, 0); return 0 },
            _ul_,
            ed$1,
            de$1];
        case 3:
          var
            rest$2 = param[1],
            match$2 = fmtty_rel_det(rest$2),
            de$2 = match$2[4],
            ed$2 = match$2[3],
            af$2 = match$2[2],
            fa$2 = match$2[1],
            _um_ = function (param) { caml_call1(af$2, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$2, 0); return 0 },
            _um_,
            ed$2,
            de$2];
        case 4:
          var
            rest$3 = param[1],
            match$3 = fmtty_rel_det(rest$3),
            de$3 = match$3[4],
            ed$3 = match$3[3],
            af$3 = match$3[2],
            fa$3 = match$3[1],
            _un_ = function (param) { caml_call1(af$3, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$3, 0); return 0 },
            _un_,
            ed$3,
            de$3];
        case 5:
          var
            rest$4 = param[1],
            match$4 = fmtty_rel_det(rest$4),
            de$4 = match$4[4],
            ed$4 = match$4[3],
            af$4 = match$4[2],
            fa$4 = match$4[1],
            _uo_ = function (param) { caml_call1(af$4, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$4, 0); return 0 },
            _uo_,
            ed$4,
            de$4];
        case 6:
          var
            rest$5 = param[1],
            match$5 = fmtty_rel_det(rest$5),
            de$5 = match$5[4],
            ed$5 = match$5[3],
            af$5 = match$5[2],
            fa$5 = match$5[1],
            _up_ = function (param) { caml_call1(af$5, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$5, 0); return 0 },
            _up_,
            ed$5,
            de$5];
        case 7:
          var
            rest$6 = param[1],
            match$6 = fmtty_rel_det(rest$6),
            de$6 = match$6[4],
            ed$6 = match$6[3],
            af$6 = match$6[2],
            fa$6 = match$6[1],
            _uq_ = function (param) { caml_call1(af$6, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$6, 0); return 0 },
            _uq_,
            ed$6,
            de$6];
        case 8:
          var
            rest$7 = param[2],
            match$7 = fmtty_rel_det(rest$7),
            de$7 = match$7[4],
            ed$7 = match$7[3],
            af$7 = match$7[2],
            fa$7 = match$7[1],
            _ur_ = function (param) { caml_call1(af$7, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$7, 0); return 0 },
            _ur_,
            ed$7,
            de$7];
        case 9:
          var
            rest$8 = param[3],
            ty2 = param[2],
            ty1 = param[1],
            match$8 = fmtty_rel_det(rest$8),
            de$8 = match$8[4],
            ed$8 = match$8[3],
            af$8 = match$8[2],
            fa$8 = match$8[1],
            ty = trans(symm(ty1), ty2),
            match$9 = fmtty_rel_det(ty),
            jd = match$9[4],
            dj = match$9[3],
            ga = match$9[2],
            ag = match$9[1],
            _us_ = function (param) { caml_call1(jd, 0); caml_call1(de$8, 0); return 0 },
            _ut_ = function (param) { caml_call1(ed$8, 0); caml_call1(dj, 0); return 0 },
            _uu_ = function (param) { caml_call1(ga, 0); caml_call1(af$8, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$8, 0); caml_call1(ag, 0); return 0 },
            _uu_,
            _ut_,
            _us_];
        case 10:
          var
            rest$9 = param[1],
            match$10 = fmtty_rel_det(rest$9),
            de$9 = match$10[4],
            ed$9 = match$10[3],
            af$9 = match$10[2],
            fa$9 = match$10[1],
            _uv_ = function (param) { caml_call1(af$9, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$9, 0); return 0 },
            _uv_,
            ed$9,
            de$9];
        case 11:
          var
            rest$10 = param[1],
            match$11 = fmtty_rel_det(rest$10),
            de$10 = match$11[4],
            ed$10 = match$11[3],
            af$10 = match$11[2],
            fa$10 = match$11[1],
            _uw_ = function (param) { caml_call1(af$10, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$10, 0); return 0 },
            _uw_,
            ed$10,
            de$10];
        case 12:
          var
            rest$11 = param[1],
            match$12 = fmtty_rel_det(rest$11),
            de$11 = match$12[4],
            ed$11 = match$12[3],
            af$11 = match$12[2],
            fa$11 = match$12[1],
            _ux_ = function (param) { caml_call1(af$11, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$11, 0); return 0 },
            _ux_,
            ed$11,
            de$11];
        case 13:
          var
            rest$12 = param[1],
            match$13 = fmtty_rel_det(rest$12),
            de$12 = match$13[4],
            ed$12 = match$13[3],
            af$12 = match$13[2],
            fa$12 = match$13[1],
            _uy_ = function (param) { caml_call1(de$12, 0); return 0 },
            _uz_ = function (param) { caml_call1(ed$12, 0); return 0 },
            _uA_ = function (param) { caml_call1(af$12, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$12, 0); return 0 },
            _uA_,
            _uz_,
            _uy_];
        default:
          var
            rest$13 = param[1],
            match$14 = fmtty_rel_det(rest$13),
            de$13 = match$14[4],
            ed$13 = match$14[3],
            af$13 = match$14[2],
            fa$13 = match$14[1],
            _uB_ = function (param) { caml_call1(de$13, 0); return 0 },
            _uC_ = function (param) { caml_call1(ed$13, 0); return 0 },
            _uD_ = function (param) { caml_call1(af$13, 0); return 0 };
          return [0,
            function (param) { caml_call1(fa$13, 0); return 0 },
            _uD_,
            _uC_,
            _uB_]
      }
    function _ug_(param) { return 0 }
    function _uh_(param) { return 0 }
    function _ui_(param) { return 0 }
    return [0, function (param) { return 0 }, _ui_, _uh_, _ug_]
  }
  function trans(ty1, ty2) {
    var switch$0 = 0;
    if (typeof ty1 === "number") {
      if (typeof ty2 === "number") return 0;
      switch (ty2[0]) {
        case 10: break;
        case 11: switch$0 = 1; break;
        case 12: switch$0 = 2; break;
        case 13: switch$0 = 3; break;
        case 14: switch$0 = 4; break;
        case 8: switch$0 = 5; break;
        case 9: switch$0 = 6; break;
        default: throw [0, Assert_failure, _af_]
      }
    }
    else
      switch (ty1[0]) {
        case 0:
          var switch$1 = 0, _tZ_ = ty1[1];
          if (typeof ty2 !== "number")
            switch (ty2[0]) {
              case 0: var rest2 = ty2[1]; return [0, trans(_tZ_, rest2)];
              case 8: switch$0 = 5; switch$1 = 1; break;
              case 9: switch$0 = 6; switch$1 = 1; break;
              case 10: switch$1 = 1; break;
              case 11: switch$0 = 1; switch$1 = 1; break;
              case 12: switch$0 = 2; switch$1 = 1; break;
              case 13: switch$0 = 3; switch$1 = 1; break;
              case 14: switch$0 = 4; switch$1 = 1; break
            }
          if (!switch$1) switch$0 = 7;
          break;
        case 1:
          var switch$2 = 0, _t0_ = ty1[1];
          if (typeof ty2 !== "number")
            switch (ty2[0]) {
              case 1: var rest2$0 = ty2[1]; return [1, trans(_t0_, rest2$0)];
              case 8: switch$0 = 5; switch$2 = 1; break;
              case 9: switch$0 = 6; switch$2 = 1; break;
              case 10: switch$2 = 1; break;
              case 11: switch$0 = 1; switch$2 = 1; break;
              case 12: switch$0 = 2; switch$2 = 1; break;
              case 13: switch$0 = 3; switch$2 = 1; break;
              case 14: switch$0 = 4; switch$2 = 1; break
            }
          if (!switch$2) switch$0 = 7;
          break;
        case 2:
          var switch$3 = 0, _t1_ = ty1[1];
          if (typeof ty2 === "number")
            switch$3 = 1;
          else
            switch (ty2[0]) {
              case 2: var rest2$1 = ty2[1]; return [2, trans(_t1_, rest2$1)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$3 = 1
            }
          if (switch$3) switch$0 = 7;
          break;
        case 3:
          var switch$4 = 0, _t2_ = ty1[1];
          if (typeof ty2 === "number")
            switch$4 = 1;
          else
            switch (ty2[0]) {
              case 3: var rest2$2 = ty2[1]; return [3, trans(_t2_, rest2$2)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$4 = 1
            }
          if (switch$4) switch$0 = 7;
          break;
        case 4:
          var switch$5 = 0, _t3_ = ty1[1];
          if (typeof ty2 === "number")
            switch$5 = 1;
          else
            switch (ty2[0]) {
              case 4: var rest2$3 = ty2[1]; return [4, trans(_t3_, rest2$3)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$5 = 1
            }
          if (switch$5) switch$0 = 7;
          break;
        case 5:
          var switch$6 = 0, _t4_ = ty1[1];
          if (typeof ty2 === "number")
            switch$6 = 1;
          else
            switch (ty2[0]) {
              case 5: var rest2$4 = ty2[1]; return [5, trans(_t4_, rest2$4)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$6 = 1
            }
          if (switch$6) switch$0 = 7;
          break;
        case 6:
          var switch$7 = 0, _t5_ = ty1[1];
          if (typeof ty2 === "number")
            switch$7 = 1;
          else
            switch (ty2[0]) {
              case 6: var rest2$5 = ty2[1]; return [6, trans(_t5_, rest2$5)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$7 = 1
            }
          if (switch$7) switch$0 = 7;
          break;
        case 7:
          var switch$8 = 0, _t6_ = ty1[1];
          if (typeof ty2 === "number")
            switch$8 = 1;
          else
            switch (ty2[0]) {
              case 7: var rest2$6 = ty2[1]; return [7, trans(_t6_, rest2$6)];
              case 8: switch$0 = 5; break;
              case 9: switch$0 = 6; break;
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$8 = 1
            }
          if (switch$8) switch$0 = 7;
          break;
        case 8:
          var switch$9 = 0, _t7_ = ty1[2], _t8_ = ty1[1];
          if (typeof ty2 === "number")
            switch$9 = 1;
          else
            switch (ty2[0]) {
              case 8:
                var rest2$7 = ty2[2], ty2$0 = ty2[1], _t9_ = trans(_t7_, rest2$7);
                return [8, trans(_t8_, ty2$0), _t9_];
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$9 = 1
            }
          if (switch$9) throw [0, Assert_failure, _ao_];
          break;
        case 9:
          var switch$10 = 0, _t__ = ty1[3], _t$_ = ty1[2], _ua_ = ty1[1];
          if (typeof ty2 === "number")
            switch$10 = 1;
          else
            switch (ty2[0]) {
              case 8: switch$0 = 5; break;
              case 9:
                var
                  rest2$8 = ty2[3],
                  ty22 = ty2[2],
                  ty21 = ty2[1],
                  ty = trans(symm(_t$_), ty21),
                  match = fmtty_rel_det(ty),
                  f4 = match[4],
                  f2 = match[2];
                caml_call1(f2, 0);
                caml_call1(f4, 0);
                return [9, _ua_, ty22, trans(_t__, rest2$8)];
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: switch$0 = 4; break;
              default: switch$10 = 1
            }
          if (switch$10) throw [0, Assert_failure, _ap_];
          break;
        case 10:
          var _ub_ = ty1[1];
          if (typeof ty2 !== "number" && 10 === ty2[0]) { var rest2$9 = ty2[1]; return [10, trans(_ub_, rest2$9)] }
          throw [0, Assert_failure, _aq_];
        case 11:
          var switch$11 = 0, _uc_ = ty1[1];
          if (typeof ty2 === "number")
            switch$11 = 1;
          else
            switch (ty2[0]) {
              case 10: break;
              case 11: var rest2$10 = ty2[1]; return [11, trans(_uc_, rest2$10)];
              default: switch$11 = 1
            }
          if (switch$11) throw [0, Assert_failure, _ar_];
          break;
        case 12:
          var switch$12 = 0, _ud_ = ty1[1];
          if (typeof ty2 === "number")
            switch$12 = 1;
          else
            switch (ty2[0]) {
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: var rest2$11 = ty2[1]; return [12, trans(_ud_, rest2$11)];
              default: switch$12 = 1
            }
          if (switch$12) throw [0, Assert_failure, _as_];
          break;
        case 13:
          var switch$13 = 0, _ue_ = ty1[1];
          if (typeof ty2 === "number")
            switch$13 = 1;
          else
            switch (ty2[0]) {
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: var rest2$12 = ty2[1]; return [13, trans(_ue_, rest2$12)];
              default: switch$13 = 1
            }
          if (switch$13) throw [0, Assert_failure, _at_];
          break;
        default:
          var switch$14 = 0, _uf_ = ty1[1];
          if (typeof ty2 === "number")
            switch$14 = 1;
          else
            switch (ty2[0]) {
              case 10: break;
              case 11: switch$0 = 1; break;
              case 12: switch$0 = 2; break;
              case 13: switch$0 = 3; break;
              case 14: var rest2$13 = ty2[1]; return [14, trans(_uf_, rest2$13)];
              default: switch$14 = 1
            }
          if (switch$14) throw [0, Assert_failure, _au_]
      }
    switch (switch$0) {
      case 0: throw [0, Assert_failure, _ai_];
      case 1: throw [0, Assert_failure, _aj_];
      case 2: throw [0, Assert_failure, _ak_];
      case 3: throw [0, Assert_failure, _al_];
      case 4: throw [0, Assert_failure, _am_];
      case 5: throw [0, Assert_failure, _ag_];
      case 6: throw [0, Assert_failure, _ah_];
      default: throw [0, Assert_failure, _an_]
    }
  }
  function fmtty_of_padding_fmtty(pad, fmtty) { return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty] }
  function fmtty_of_custom(arity, fmtty) {
    if (!arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)]
  }
  function fmtty_of_fmt(fmtty) {
    var fmtty$0 = fmtty;
    for (; ;) {
      if (typeof fmtty$0 === "number") return 0;
      switch (fmtty$0[0]) {
        case 0: var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
        case 1: var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
        case 2:
          var rest$1 = fmtty$0[2], pad = fmtty$0[1];
          return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
        case 3:
          var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
          return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
        case 4:
          var
            rest$3 = fmtty$0[4],
            prec = fmtty$0[3],
            pad$1 = fmtty$0[2],
            ty_rest = fmtty_of_fmt(rest$3),
            prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
          return fmtty_of_padding_fmtty(pad$1, prec_ty);
        case 5:
          var
            rest$4 = fmtty$0[4],
            prec$0 = fmtty$0[3],
            pad$2 = fmtty$0[2],
            ty_rest$0 = fmtty_of_fmt(rest$4),
            prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
          return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
        case 6:
          var
            rest$5 = fmtty$0[4],
            prec$1 = fmtty$0[3],
            pad$3 = fmtty$0[2],
            ty_rest$1 = fmtty_of_fmt(rest$5),
            prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
          return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
        case 7:
          var
            rest$6 = fmtty$0[4],
            prec$2 = fmtty$0[3],
            pad$4 = fmtty$0[2],
            ty_rest$2 = fmtty_of_fmt(rest$6),
            prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
          return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
        case 8:
          var
            rest$7 = fmtty$0[4],
            prec$3 = fmtty$0[3],
            pad$5 = fmtty$0[2],
            ty_rest$3 = fmtty_of_fmt(rest$7),
            prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
          return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
        case 9:
          var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
          return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
        case 10: var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1; continue;
        case 11: var fmtty$2 = fmtty$0[2], fmtty$0 = fmtty$2; continue;
        case 12: var fmtty$3 = fmtty$0[2], fmtty$0 = fmtty$3; continue;
        case 13:
          var rest$9 = fmtty$0[3], ty = fmtty$0[2];
          return [8, ty, fmtty_of_fmt(rest$9)];
        case 14:
          var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
          return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
        case 15: var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
        case 16: var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
        case 17: var fmtty$4 = fmtty$0[2], fmtty$0 = fmtty$4; continue;
        case 18:
          var
            rest$13 = fmtty$0[2],
            fmting_gen = fmtty$0[1],
            _tX_ = fmtty_of_fmt(rest$13);
          if (0 === fmting_gen[0])
            var match = fmting_gen[1], fmt = match[1], _tY_ = fmtty_of_fmt(fmt);
          else
            var
              match$0 = fmting_gen[1],
              fmt$0 = match$0[1],
              _tY_ = fmtty_of_fmt(fmt$0);
          return concat_fmtty(_tY_, _tX_);
        case 19: var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
        case 20: var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
        case 21: var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
        case 22: var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
        case 23:
          var rest$18 = fmtty$0[2], ign = fmtty$0[1];
          if (typeof ign === "number")
            switch (ign) {
              case 0: var fmtty$0 = rest$18; continue;
              case 1: var fmtty$0 = rest$18; continue;
              case 2: return [14, fmtty_of_fmt(rest$18)];
              default: var fmtty$0 = rest$18; continue
            }
          switch (ign[0]) {
            case 0: var fmtty$0 = rest$18; continue;
            case 1: var fmtty$0 = rest$18; continue;
            case 2: var fmtty$0 = rest$18; continue;
            case 3: var fmtty$0 = rest$18; continue;
            case 4: var fmtty$0 = rest$18; continue;
            case 5: var fmtty$0 = rest$18; continue;
            case 6: var fmtty$0 = rest$18; continue;
            case 7: var fmtty$0 = rest$18; continue;
            case 8: var fmtty$0 = rest$18; continue;
            case 9:
              var fmtty$5 = ign[2];
              return concat_fmtty(fmtty$5, fmtty_of_fmt(rest$18));
            case 10: var fmtty$0 = rest$18; continue;
            default: var fmtty$0 = rest$18; continue
          }
        default:
          var rest$19 = fmtty$0[3], arity = fmtty$0[1];
          return fmtty_of_custom(arity, fmtty_of_fmt(rest$19))
      }
    }
  }
  function fmtty_of_precision_fmtty(prec, fmtty) { return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty }
  var
    Type_mismatch =
      [248, cst_CamlinternalFormat_Type_mi, caml_fresh_oo_id(0)];
  function type_padding(pad, fmtty) {
    if (typeof pad === "number") return [0, 0, fmtty];
    if (0 === pad[0]) { var w = pad[2], padty = pad[1]; return [0, [0, padty, w], fmtty] }
    if (typeof fmtty !== "number" && 2 === fmtty[0]) { var rest = fmtty[1], padty$0 = pad[1]; return [0, [1, padty$0], rest] }
    throw Type_mismatch
  }
  function type_padprec(pad, prec, fmtty) {
    var match = type_padding(pad, fmtty);
    if (typeof prec !== "number") {
      var rest$1 = match[2], pad$2 = match[1], p = prec[1];
      return [0, pad$2, [0, p], rest$1]
    }
    if (!prec) { var rest$0 = match[2], pad$1 = match[1]; return [0, pad$1, 0, rest$0] }
    var _tW_ = match[2];
    if (typeof _tW_ !== "number" && 2 === _tW_[0]) { var rest = _tW_[1], pad$0 = match[1]; return [0, pad$0, 1, rest] }
    throw Type_mismatch
  }
  function type_format(fmt, fmtty) {
    var _tV_ = type_format_gen(fmt, fmtty);
    if (typeof _tV_[2] !== "number") throw Type_mismatch;
    var fmt$0 = _tV_[1];
    return fmt$0
  }
  function type_ignored_param_one(ign, fmt, fmtty) {
    var match = type_format_gen(fmt, fmtty), fmtty$0 = match[2], fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0]
  }
  function type_format_gen(fmt, fmtty) {
    if (typeof fmt === "number") return [0, 0, fmtty];
    switch (fmt[0]) {
      case 0:
        if (typeof fmtty !== "number" && 0 === fmtty[0]) {
          var
          fmtty_rest = fmtty[1],
          fmt_rest = fmt[1],
          match = type_format_gen(fmt_rest, fmtty_rest),
          fmtty$0 = match[2],
          fmt$0 = match[1];
          return [0, [0, fmt$0], fmtty$0]
        }
        break;
      case 1:
        if (typeof fmtty !== "number" && 0 === fmtty[0]) {
          var
          fmtty_rest$0 = fmtty[1],
          fmt_rest$0 = fmt[1],
          match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
          fmtty$1 = match$0[2],
          fmt$1 = match$0[1];
          return [0, [1, fmt$1], fmtty$1]
        }
        break;
      case 2:
        var
          fmt_rest$1 = fmt[2],
          pad = fmt[1],
          match$1 = type_padding(pad, fmtty),
          _tE_ = match$1[2],
          _tD_ = match$1[1];
        if (typeof _tE_ !== "number" && 1 === _tE_[0]) {
          var
          fmtty_rest$1 = _tE_[1],
          match$2 = type_format_gen(fmt_rest$1, fmtty_rest$1),
          fmtty$2 = match$2[2],
          fmt$2 = match$2[1];
          return [0, [2, _tD_, fmt$2], fmtty$2]
        }
        throw Type_mismatch;
      case 3:
        var
          fmt_rest$2 = fmt[2],
          pad$0 = fmt[1],
          match$3 = type_padding(pad$0, fmtty),
          _tG_ = match$3[2],
          _tF_ = match$3[1];
        if (typeof _tG_ !== "number" && 1 === _tG_[0]) {
          var
          fmtty_rest$2 = _tG_[1],
          match$4 = type_format_gen(fmt_rest$2, fmtty_rest$2),
          fmtty$3 = match$4[2],
          fmt$3 = match$4[1];
          return [0, [3, _tF_, fmt$3], fmtty$3]
        }
        throw Type_mismatch;
      case 4:
        var
          fmt_rest$3 = fmt[4],
          prec = fmt[3],
          pad$1 = fmt[2],
          iconv = fmt[1],
          match$5 = type_padprec(pad$1, prec, fmtty),
          _tI_ = match$5[3],
          _tH_ = match$5[1];
        if (typeof _tI_ !== "number" && 2 === _tI_[0]) {
          var
          fmtty_rest$3 = _tI_[1],
          prec$0 = match$5[2],
          match$6 = type_format_gen(fmt_rest$3, fmtty_rest$3),
          fmtty$4 = match$6[2],
          fmt$4 = match$6[1];
          return [0, [4, iconv, _tH_, prec$0, fmt$4], fmtty$4]
        }
        throw Type_mismatch;
      case 5:
        var
          fmt_rest$4 = fmt[4],
          prec$1 = fmt[3],
          pad$2 = fmt[2],
          iconv$0 = fmt[1],
          match$7 = type_padprec(pad$2, prec$1, fmtty),
          _tK_ = match$7[3],
          _tJ_ = match$7[1];
        if (typeof _tK_ !== "number" && 3 === _tK_[0]) {
          var
          fmtty_rest$4 = _tK_[1],
          prec$2 = match$7[2],
          match$8 = type_format_gen(fmt_rest$4, fmtty_rest$4),
          fmtty$5 = match$8[2],
          fmt$5 = match$8[1];
          return [0, [5, iconv$0, _tJ_, prec$2, fmt$5], fmtty$5]
        }
        throw Type_mismatch;
      case 6:
        var
          fmt_rest$5 = fmt[4],
          prec$3 = fmt[3],
          pad$3 = fmt[2],
          iconv$1 = fmt[1],
          match$9 = type_padprec(pad$3, prec$3, fmtty),
          _tM_ = match$9[3],
          _tL_ = match$9[1];
        if (typeof _tM_ !== "number" && 4 === _tM_[0]) {
          var
          fmtty_rest$5 = _tM_[1],
          prec$4 = match$9[2],
          match$10 = type_format_gen(fmt_rest$5, fmtty_rest$5),
          fmtty$6 = match$10[2],
          fmt$6 = match$10[1];
          return [0, [6, iconv$1, _tL_, prec$4, fmt$6], fmtty$6]
        }
        throw Type_mismatch;
      case 7:
        var
          fmt_rest$6 = fmt[4],
          prec$5 = fmt[3],
          pad$4 = fmt[2],
          iconv$2 = fmt[1],
          match$11 = type_padprec(pad$4, prec$5, fmtty),
          _tO_ = match$11[3],
          _tN_ = match$11[1];
        if (typeof _tO_ !== "number" && 5 === _tO_[0]) {
          var
          fmtty_rest$6 = _tO_[1],
          prec$6 = match$11[2],
          match$12 = type_format_gen(fmt_rest$6, fmtty_rest$6),
          fmtty$7 = match$12[2],
          fmt$7 = match$12[1];
          return [0, [7, iconv$2, _tN_, prec$6, fmt$7], fmtty$7]
        }
        throw Type_mismatch;
      case 8:
        var
          fmt_rest$7 = fmt[4],
          prec$7 = fmt[3],
          pad$5 = fmt[2],
          fconv = fmt[1],
          match$13 = type_padprec(pad$5, prec$7, fmtty),
          _tQ_ = match$13[3],
          _tP_ = match$13[1];
        if (typeof _tQ_ !== "number" && 6 === _tQ_[0]) {
          var
          fmtty_rest$7 = _tQ_[1],
          prec$8 = match$13[2],
          match$14 = type_format_gen(fmt_rest$7, fmtty_rest$7),
          fmtty$8 = match$14[2],
          fmt$8 = match$14[1];
          return [0, [8, fconv, _tP_, prec$8, fmt$8], fmtty$8]
        }
        throw Type_mismatch;
      case 9:
        var
          fmt_rest$8 = fmt[2],
          pad$6 = fmt[1],
          match$15 = type_padding(pad$6, fmtty),
          _tS_ = match$15[2],
          _tR_ = match$15[1];
        if (typeof _tS_ !== "number" && 7 === _tS_[0]) {
          var
          fmtty_rest$8 = _tS_[1],
          match$16 = type_format_gen(fmt_rest$8, fmtty_rest$8),
          fmtty$9 = match$16[2],
          fmt$9 = match$16[1];
          return [0, [9, _tR_, fmt$9], fmtty$9]
        }
        throw Type_mismatch;
      case 10:
        var
          fmt_rest$9 = fmt[1],
          match$17 = type_format_gen(fmt_rest$9, fmtty),
          fmtty$10 = match$17[2],
          fmt$10 = match$17[1];
        return [0, [10, fmt$10], fmtty$10];
      case 11:
        var
          fmt_rest$10 = fmt[2],
          str = fmt[1],
          match$18 = type_format_gen(fmt_rest$10, fmtty),
          fmtty$11 = match$18[2],
          fmt$11 = match$18[1];
        return [0, [11, str, fmt$11], fmtty$11];
      case 12:
        var
          fmt_rest$11 = fmt[2],
          chr = fmt[1],
          match$19 = type_format_gen(fmt_rest$11, fmtty),
          fmtty$12 = match$19[2],
          fmt$12 = match$19[1];
        return [0, [12, chr, fmt$12], fmtty$12];
      case 13:
        if (typeof fmtty !== "number" && 8 === fmtty[0]) {
          var
          fmtty_rest$9 = fmtty[2],
          sub_fmtty = fmtty[1],
          fmt_rest$12 = fmt[3],
          sub_fmtty$0 = fmt[2],
          pad_opt = fmt[1];
          if (caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
            throw Type_mismatch;
          var
            match$20 = type_format_gen(fmt_rest$12, fmtty_rest$9),
            fmtty$13 = match$20[2],
            fmt$13 = match$20[1];
          return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$13]
        }
        break;
      case 14:
        if (typeof fmtty !== "number" && 9 === fmtty[0]) {
          var
          fmtty_rest$10 = fmtty[3],
          sub_fmtty1 = fmtty[1],
          fmt_rest$13 = fmt[3],
          sub_fmtty$1 = fmt[2],
          pad_opt$0 = fmt[1],
          _tT_ = [0, erase_rel(sub_fmtty1)];
          if (caml_notequal([0, erase_rel(sub_fmtty$1)], _tT_))
            throw Type_mismatch;
          var
            match$21 = type_format_gen(fmt_rest$13, erase_rel(fmtty_rest$10)),
            fmtty$14 = match$21[2],
            fmt$14 = match$21[1];
          return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$14]
        }
        break;
      case 15:
        if (typeof fmtty !== "number" && 10 === fmtty[0]) {
          var
          fmtty_rest$11 = fmtty[1],
          fmt_rest$14 = fmt[1],
          match$22 = type_format_gen(fmt_rest$14, fmtty_rest$11),
          fmtty$15 = match$22[2],
          fmt$15 = match$22[1];
          return [0, [15, fmt$15], fmtty$15]
        }
        break;
      case 16:
        if (typeof fmtty !== "number" && 11 === fmtty[0]) {
          var
          fmtty_rest$12 = fmtty[1],
          fmt_rest$15 = fmt[1],
          match$23 = type_format_gen(fmt_rest$15, fmtty_rest$12),
          fmtty$16 = match$23[2],
          fmt$16 = match$23[1];
          return [0, [16, fmt$16], fmtty$16]
        }
        break;
      case 17:
        var
          fmt_rest$16 = fmt[2],
          formatting_lit = fmt[1],
          match$24 = type_format_gen(fmt_rest$16, fmtty),
          fmtty$17 = match$24[2],
          fmt$17 = match$24[1];
        return [0, [17, formatting_lit, fmt$17], fmtty$17];
      case 18:
        var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
        if (0 === formatting_gen[0]) {
          var
          match$28 = formatting_gen[1],
          str$0 = match$28[2],
          fmt1 = match$28[1],
          match$29 = type_format_gen(fmt1, fmtty),
          fmtty2 = match$29[2],
          fmt2 = match$29[1],
          match$30 = type_format_gen(fmt_rest$17, fmtty2),
          fmtty3 = match$30[2],
          fmt3 = match$30[1];
          return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3]
        }
        var
          match$31 = formatting_gen[1],
          str$1 = match$31[2],
          fmt1$0 = match$31[1],
          match$32 = type_format_gen(fmt1$0, fmtty),
          fmtty2$0 = match$32[2],
          fmt2$0 = match$32[1],
          match$33 = type_format_gen(fmt_rest$17, fmtty2$0),
          fmtty3$0 = match$33[2],
          fmt3$0 = match$33[1];
        return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
        if (typeof fmtty !== "number" && 13 === fmtty[0]) {
          var
          fmtty_rest$13 = fmtty[1],
          fmt_rest$18 = fmt[1],
          match$25 = type_format_gen(fmt_rest$18, fmtty_rest$13),
          fmtty$18 = match$25[2],
          fmt$18 = match$25[1];
          return [0, [19, fmt$18], fmtty$18]
        }
        break;
      case 20:
        if (typeof fmtty !== "number" && 1 === fmtty[0]) {
          var
          fmtty_rest$14 = fmtty[1],
          fmt_rest$19 = fmt[3],
          char_set = fmt[2],
          width_opt = fmt[1],
          match$26 = type_format_gen(fmt_rest$19, fmtty_rest$14),
          fmtty$19 = match$26[2],
          fmt$19 = match$26[1];
          return [0, [20, width_opt, char_set, fmt$19], fmtty$19]
        }
        break;
      case 21:
        if (typeof fmtty !== "number" && 2 === fmtty[0]) {
          var
          fmtty_rest$15 = fmtty[1],
          fmt_rest$20 = fmt[2],
          counter = fmt[1],
          match$27 = type_format_gen(fmt_rest$20, fmtty_rest$15),
          fmtty$20 = match$27[2],
          fmt$20 = match$27[1];
          return [0, [21, counter, fmt$20], fmtty$20]
        }
        break;
      case 23:
        var rest = fmt[2], ign = fmt[1];
        if (typeof ign !== "number")
          switch (ign[0]) {
            case 0: return type_ignored_param_one(ign, rest, fmtty);
            case 1: return type_ignored_param_one(ign, rest, fmtty);
            case 2: return type_ignored_param_one(ign, rest, fmtty);
            case 3: return type_ignored_param_one(ign, rest, fmtty);
            case 4: return type_ignored_param_one(ign, rest, fmtty);
            case 5: return type_ignored_param_one(ign, rest, fmtty);
            case 6: return type_ignored_param_one(ign, rest, fmtty);
            case 7: return type_ignored_param_one(ign, rest, fmtty);
            case 8:
              var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
              return type_ignored_param_one
                ([8, pad_opt$1, sub_fmtty$2], rest, fmtty);
            case 9:
              var
                sub_fmtty$3 = ign[2],
                pad_opt$2 = ign[1],
                _tU_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty),
                match$35 = _tU_[2],
                fmtty$22 = match$35[2],
                fmt$22 = match$35[1],
                sub_fmtty$4 = _tU_[1];
              return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$22];
            case 10: return type_ignored_param_one(ign, rest, fmtty);
            default: return type_ignored_param_one(ign, rest, fmtty)
          }
        switch (ign) {
          case 0: return type_ignored_param_one(ign, rest, fmtty);
          case 1: return type_ignored_param_one(ign, rest, fmtty);
          case 2:
            if (typeof fmtty !== "number" && 14 === fmtty[0]) {
              var
              fmtty_rest$16 = fmtty[1],
              match$34 = type_format_gen(rest, fmtty_rest$16),
              fmtty$21 = match$34[2],
              fmt$21 = match$34[1];
              return [0, [23, 2, fmt$21], fmtty$21]
            }
            throw Type_mismatch;
          default: return type_ignored_param_one(ign, rest, fmtty)
        }
    }
    throw Type_mismatch
  }
  function type_ignored_format_substituti(sub_fmtty, fmt, fmtty) {
    if (typeof sub_fmtty === "number")
      return [0, 0, type_format_gen(fmt, fmtty)];
    switch (sub_fmtty[0]) {
      case 0:
        if (typeof fmtty !== "number" && 0 === fmtty[0]) {
          var
          fmtty_rest = fmtty[1],
          sub_fmtty_rest = sub_fmtty[1],
          match =
            type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
          fmt$0 = match[2],
          sub_fmtty_rest$0 = match[1];
          return [0, [0, sub_fmtty_rest$0], fmt$0]
        }
        break;
      case 1:
        if (typeof fmtty !== "number" && 1 === fmtty[0]) {
          var
          fmtty_rest$0 = fmtty[1],
          sub_fmtty_rest$1 = sub_fmtty[1],
          match$0 =
            type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
          fmt$1 = match$0[2],
          sub_fmtty_rest$2 = match$0[1];
          return [0, [1, sub_fmtty_rest$2], fmt$1]
        }
        break;
      case 2:
        if (typeof fmtty !== "number" && 2 === fmtty[0]) {
          var
          fmtty_rest$1 = fmtty[1],
          sub_fmtty_rest$3 = sub_fmtty[1],
          match$1 =
            type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
          fmt$2 = match$1[2],
          sub_fmtty_rest$4 = match$1[1];
          return [0, [2, sub_fmtty_rest$4], fmt$2]
        }
        break;
      case 3:
        if (typeof fmtty !== "number" && 3 === fmtty[0]) {
          var
          fmtty_rest$2 = fmtty[1],
          sub_fmtty_rest$5 = sub_fmtty[1],
          match$2 =
            type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
          fmt$3 = match$2[2],
          sub_fmtty_rest$6 = match$2[1];
          return [0, [3, sub_fmtty_rest$6], fmt$3]
        }
        break;
      case 4:
        if (typeof fmtty !== "number" && 4 === fmtty[0]) {
          var
          fmtty_rest$3 = fmtty[1],
          sub_fmtty_rest$7 = sub_fmtty[1],
          match$3 =
            type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
          fmt$4 = match$3[2],
          sub_fmtty_rest$8 = match$3[1];
          return [0, [4, sub_fmtty_rest$8], fmt$4]
        }
        break;
      case 5:
        if (typeof fmtty !== "number" && 5 === fmtty[0]) {
          var
          fmtty_rest$4 = fmtty[1],
          sub_fmtty_rest$9 = sub_fmtty[1],
          match$4 =
            type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
          fmt$5 = match$4[2],
          sub_fmtty_rest$10 = match$4[1];
          return [0, [5, sub_fmtty_rest$10], fmt$5]
        }
        break;
      case 6:
        if (typeof fmtty !== "number" && 6 === fmtty[0]) {
          var
          fmtty_rest$5 = fmtty[1],
          sub_fmtty_rest$11 = sub_fmtty[1],
          match$5 =
            type_ignored_format_substituti
              (sub_fmtty_rest$11, fmt, fmtty_rest$5),
          fmt$6 = match$5[2],
          sub_fmtty_rest$12 = match$5[1];
          return [0, [6, sub_fmtty_rest$12], fmt$6]
        }
        break;
      case 7:
        if (typeof fmtty !== "number" && 7 === fmtty[0]) {
          var
          fmtty_rest$6 = fmtty[1],
          sub_fmtty_rest$13 = sub_fmtty[1],
          match$6 =
            type_ignored_format_substituti
              (sub_fmtty_rest$13, fmt, fmtty_rest$6),
          fmt$7 = match$6[2],
          sub_fmtty_rest$14 = match$6[1];
          return [0, [7, sub_fmtty_rest$14], fmt$7]
        }
        break;
      case 8:
        if (typeof fmtty !== "number" && 8 === fmtty[0]) {
          var
          fmtty_rest$7 = fmtty[2],
          sub2_fmtty = fmtty[1],
          sub_fmtty_rest$15 = sub_fmtty[2],
          sub2_fmtty$0 = sub_fmtty[1];
          if (caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
            throw Type_mismatch;
          var
            match$7 =
              type_ignored_format_substituti
                (sub_fmtty_rest$15, fmt, fmtty_rest$7),
            fmt$8 = match$7[2],
            sub_fmtty_rest$16 = match$7[1];
          return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8]
        }
        break;
      case 9:
        if (typeof fmtty !== "number" && 9 === fmtty[0]) {
          var
          fmtty_rest$8 = fmtty[3],
          sub2_fmtty$1 = fmtty[2],
          sub1_fmtty = fmtty[1],
          sub_fmtty_rest$17 = sub_fmtty[3],
          sub2_fmtty$2 = sub_fmtty[2],
          sub1_fmtty$0 = sub_fmtty[1],
          _tB_ = [0, erase_rel(sub1_fmtty)];
          if (caml_notequal([0, erase_rel(sub1_fmtty$0)], _tB_))
            throw Type_mismatch;
          var _tC_ = [0, erase_rel(sub2_fmtty$1)];
          if (caml_notequal([0, erase_rel(sub2_fmtty$2)], _tC_))
            throw Type_mismatch;
          var
            sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
            match$8 = fmtty_rel_det(sub_fmtty$0),
            f4 = match$8[4],
            f2 = match$8[2];
          caml_call1(f2, 0);
          caml_call1(f4, 0);
          var
            match$9 =
              type_ignored_format_substituti
                (erase_rel(sub_fmtty_rest$17), fmt, fmtty_rest$8),
            fmt$9 = match$9[2],
            sub_fmtty_rest$18 = match$9[1];
          return [0,
            [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
            fmt$9]
        }
        break;
      case 10:
        if (typeof fmtty !== "number" && 10 === fmtty[0]) {
          var
          fmtty_rest$9 = fmtty[1],
          sub_fmtty_rest$19 = sub_fmtty[1],
          match$10 =
            type_ignored_format_substituti
              (sub_fmtty_rest$19, fmt, fmtty_rest$9),
          fmt$10 = match$10[2],
          sub_fmtty_rest$20 = match$10[1];
          return [0, [10, sub_fmtty_rest$20], fmt$10]
        }
        break;
      case 11:
        if (typeof fmtty !== "number" && 11 === fmtty[0]) {
          var
          fmtty_rest$10 = fmtty[1],
          sub_fmtty_rest$21 = sub_fmtty[1],
          match$11 =
            type_ignored_format_substituti
              (sub_fmtty_rest$21, fmt, fmtty_rest$10),
          fmt$11 = match$11[2],
          sub_fmtty_rest$22 = match$11[1];
          return [0, [11, sub_fmtty_rest$22], fmt$11]
        }
        break;
      case 13:
        if (typeof fmtty !== "number" && 13 === fmtty[0]) {
          var
          fmtty_rest$11 = fmtty[1],
          sub_fmtty_rest$23 = sub_fmtty[1],
          match$12 =
            type_ignored_format_substituti
              (sub_fmtty_rest$23, fmt, fmtty_rest$11),
          fmt$12 = match$12[2],
          sub_fmtty_rest$24 = match$12[1];
          return [0, [13, sub_fmtty_rest$24], fmt$12]
        }
        break;
      case 14:
        if (typeof fmtty !== "number" && 14 === fmtty[0]) {
          var
          fmtty_rest$12 = fmtty[1],
          sub_fmtty_rest$25 = sub_fmtty[1],
          match$13 =
            type_ignored_format_substituti
              (sub_fmtty_rest$25, fmt, fmtty_rest$12),
          fmt$13 = match$13[2],
          sub_fmtty_rest$26 = match$13[1];
          return [0, [14, sub_fmtty_rest$26], fmt$13]
        }
        break
    }
    throw Type_mismatch
  }
  function recast(fmt, fmtty) { return type_format(fmt, erase_rel(symm(fmtty))) }
  function fix_padding(padty, width, str) {
    var
    len = caml_ml_string_length(str),
    padty$0 = 0 <= width ? padty : 0,
    width$0 = abs(width);
    if (width$0 <= len) return str;
    var _tA_ = 2 === padty$0 ? 48 : 32, res = make$0(width$0, _tA_);
    switch (padty$0) {
      case 0: blit$0(str, 0, res, 0, len); break;
      case 1: blit$0(str, 0, res, width$0 - len | 0, len); break;
      default:
        var switch$0 = 0;
        if (0 < len) {
          var switch$1 = 0;
          if
            (43
            !==
            caml_string_get(str, 0)
            &&
            45
            !==
            caml_string_get(str, 0)
            &&
            32
            !==
            caml_string_get(str, 0)) { switch$0 = 1; switch$1 = 1 }
          if (!switch$1) {
            caml_bytes_set(res, 0, caml_string_get(str, 0));
            blit$0(str, 1, res, (width$0 - len | 0) + 1 | 0, len - 1 | 0)
          }
        }
        else
          switch$0 = 1;
        if (switch$0) {
          var switch$2 = 0;
          if (1 < len && 48 === caml_string_get(str, 0)) {
            var switch$3 = 0;
            if
              (120
              !==
              caml_string_get(str, 1)
              &&
              88
              !==
              caml_string_get(str, 1)) { switch$2 = 1; switch$3 = 1 }
            if (!switch$3) {
              caml_bytes_set(res, 1, caml_string_get(str, 1));
              blit$0(str, 2, res, (width$0 - len | 0) + 2 | 0, len - 2 | 0)
            }
          }
          else
            switch$2 = 1;
          if (switch$2) blit$0(str, 0, res, width$0 - len | 0, len)
        }
    }
    return caml_string_of_bytes(res)
  }
  function fix_int_precision(prec, str) {
    var
    prec$0 = abs(prec),
    len = caml_ml_string_length(str),
    c = caml_string_get(str, 0),
    switch$0 = 0;
    if (58 <= c) {
      if (71 <= c) { if (5 >= c - 97 >>> 0) switch$0 = 1 }
      else
        if (65 <= c) switch$0 = 1
    }
    else {
      var switch$1 = 0;
      if (32 !== c)
        if (43 <= c)
          switch (c - 43 | 0) {
            case 5:
              if (len < (prec$0 + 2 | 0) && 1 < len) {
                var switch$2 = 0;
                if
                  (120
                  ===
                  caml_string_get(str, 1)
                  ||
                  88
                  ===
                  caml_string_get(str, 1))
                  switch$2 = 1;
                if (switch$2) {
                  var res$1 = make$0(prec$0 + 2 | 0, 48);
                  caml_bytes_set(res$1, 1, caml_string_get(str, 1));
                  blit$0(str, 2, res$1, (prec$0 - len | 0) + 4 | 0, len - 2 | 0);
                  return caml_string_of_bytes(res$1)
                }
              }
              switch$0 = 1;
              switch$1 = 1;
              break;
            case 0:
            case 2: break;
            case 1:
            case 3:
            case 4: switch$1 = 1; break;
            default: switch$0 = 1; switch$1 = 1
          }
        else
          switch$1 = 1;
      if (!switch$1 && len < (prec$0 + 1 | 0)) {
        var res$0 = make$0(prec$0 + 1 | 0, 48);
        caml_bytes_set(res$0, 0, c);
        blit$0(str, 1, res$0, (prec$0 - len | 0) + 2 | 0, len - 1 | 0);
        return caml_string_of_bytes(res$0)
      }
    }
    if (switch$0 && len < prec$0) {
      var res = make$0(prec$0, 48);
      blit$0(str, 0, res, prec$0 - len | 0, len);
      return caml_string_of_bytes(res)
    }
    return str
  }
  function string_to_caml_string(str) {
    var
    str$0 = escaped$1(str),
    l = caml_ml_string_length(str$0),
    res = make$0(l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_string_of_bytes(res)
  }
  function format_of_fconv(fconv, prec) {
    var
    prec$0 = abs(prec),
    symb = char_of_fconv(_av_, fconv),
    buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_string_of_jsbytes("" + prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf)
  }
  function transform_int_alt(iconv, s) {
    if (13 > iconv) return s;
    var n = [0, 0], _tv_ = caml_ml_string_length(s) - 1 | 0, _tu_ = 0;
    if (_tv_ >= 0) {
      var i$0 = _tu_;
      for (; ;) {
        var match = caml_string_unsafe_get(s, i$0);
        if (9 >= match - 48 >>> 0) n[1]++;
        var _tz_ = i$0 + 1 | 0;
        if (_tv_ !== i$0) { var i$0 = _tz_; continue }
        break
      }
    }
    var
      digits = n[1],
      buf =
        caml_create_bytes
          (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
      pos = [0, 0];
    function put(c) { caml_bytes_set(buf, pos[1], c); pos[1]++; return 0 }
    var
      left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
      _tx_ = caml_ml_string_length(s) - 1 | 0,
      _tw_ = 0;
    if (_tx_ >= 0) {
      var i = _tw_;
      for (; ;) {
        var c = caml_string_unsafe_get(s, i);
        if (9 < c - 48 >>> 0)
          put(c);
        else { if (0 === left[1]) { put(95); left[1] = 3 } left[1] += -1; put(c) }
        var _ty_ = i + 1 | 0;
        if (_tx_ !== i) { var i = _ty_; continue }
        break
      }
    }
    return caml_string_of_bytes(buf)
  }
  function convert_int(iconv, n) {
    switch (iconv) {
      case 1: var _tt_ = cst_d$3; break;
      case 2: var _tt_ = cst_d$4; break;
      case 4: var _tt_ = cst_i$1; break;
      case 5: var _tt_ = cst_i$2; break;
      case 6: var _tt_ = cst_x; break;
      case 7: var _tt_ = cst_x$0; break;
      case 8: var _tt_ = cst_X$0; break;
      case 9: var _tt_ = cst_X$1; break;
      case 10: var _tt_ = cst_o; break;
      case 11: var _tt_ = cst_o$0; break;
      case 0:
      case 13: var _tt_ = cst_d$2; break;
      case 3:
      case 14: var _tt_ = cst_i$0; break;
      default: var _tt_ = cst_u
    }
    return transform_int_alt(iconv, caml_format_int(_tt_, n))
  }
  function convert_int32(iconv, n) {
    switch (iconv) {
      case 1: var _ts_ = cst_ld$0; break;
      case 2: var _ts_ = cst_ld$1; break;
      case 4: var _ts_ = cst_li$1; break;
      case 5: var _ts_ = cst_li$2; break;
      case 6: var _ts_ = cst_lx; break;
      case 7: var _ts_ = cst_lx$0; break;
      case 8: var _ts_ = cst_lX; break;
      case 9: var _ts_ = cst_lX$0; break;
      case 10: var _ts_ = cst_lo; break;
      case 11: var _ts_ = cst_lo$0; break;
      case 0:
      case 13: var _ts_ = cst_ld; break;
      case 3:
      case 14: var _ts_ = cst_li$0; break;
      default: var _ts_ = cst_lu
    }
    return transform_int_alt(iconv, caml_format_int(_ts_, n))
  }
  function convert_nativeint(iconv, n) {
    switch (iconv) {
      case 1: var _tr_ = cst_nd$0; break;
      case 2: var _tr_ = cst_nd$1; break;
      case 4: var _tr_ = cst_ni$1; break;
      case 5: var _tr_ = cst_ni$2; break;
      case 6: var _tr_ = cst_nx; break;
      case 7: var _tr_ = cst_nx$0; break;
      case 8: var _tr_ = cst_nX; break;
      case 9: var _tr_ = cst_nX$0; break;
      case 10: var _tr_ = cst_no; break;
      case 11: var _tr_ = cst_no$0; break;
      case 0:
      case 13: var _tr_ = cst_nd; break;
      case 3:
      case 14: var _tr_ = cst_ni$0; break;
      default: var _tr_ = cst_nu
    }
    return transform_int_alt(iconv, caml_format_int(_tr_, n))
  }
  function convert_int64(iconv, n) {
    switch (iconv) {
      case 1: var _tq_ = cst_Ld$0; break;
      case 2: var _tq_ = cst_Ld$1; break;
      case 4: var _tq_ = cst_Li$1; break;
      case 5: var _tq_ = cst_Li$2; break;
      case 6: var _tq_ = cst_Lx; break;
      case 7: var _tq_ = cst_Lx$0; break;
      case 8: var _tq_ = cst_LX; break;
      case 9: var _tq_ = cst_LX$0; break;
      case 10: var _tq_ = cst_Lo; break;
      case 11: var _tq_ = cst_Lo$0; break;
      case 0:
      case 13: var _tq_ = cst_Ld; break;
      case 3:
      case 14: var _tq_ = cst_Li$0; break;
      default: var _tq_ = cst_Lu
    }
    return transform_int_alt(iconv, caml_int64_format(_tq_, n))
  }
  function convert_float(fconv, prec, x) {
    function hex(param) {
      switch (fconv[1]) {
        case 0: var sign = 45; break;
        case 1: var sign = 43; break;
        default: var sign = 32
      }
      return runtime.caml_hexstring_of_float(x, prec, sign)
    }
    function caml_special_val(str) {
      var match = runtime.caml_classify_float(x);
      return 3 === match
        ? x < 0. ? cst_neg_infinity : cst_infinity
        : 4 <= match ? cst_nan : str
    }
    switch (fconv[2]) {
      case 5:
        var
          str = caml_format_float(format_of_fconv(fconv, prec), x),
          len = caml_ml_string_length(str),
          i = 0;
        for (; ;) {
          if (i === len)
            var _to_ = 0;
          else {
            var match = caml_string_get(str, i), _tn_ = match - 46 | 0, switch$0 = 0;
            if (23 < _tn_ >>> 0) { if (55 === _tn_) switch$0 = 1 }
            else
              if (21 < _tn_ - 1 >>> 0) switch$0 = 1;
            if (!switch$0) { var i$0 = i + 1 | 0, i = i$0; continue }
            var _to_ = 1
          }
          var _tp_ = _to_ ? str : cat(str, cst$29);
          return caml_special_val(_tp_)
        }
      case 6: return hex(0);
      case 7: return uppercase_ascii$1(hex(0));
      case 8: return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x)
    }
  }
  function string_of_fmtty(fmtty) {
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf)
  }
  function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv) {
    if (typeof pad === "number") {
      if (typeof prec === "number")
        return prec
          ? function (p, x) {
            var str = fix_int_precision(p, caml_call2(trans, iconv, x));
            return make_printf(k, [4, acc, str], fmt)
          }
          : function (x) {
            var str = caml_call2(trans, iconv, x);
            return make_printf(k, [4, acc, str], fmt)
          };
      var p = prec[1];
      return function (x) {
        var str = fix_int_precision(p, caml_call2(trans, iconv, x));
        return make_printf(k, [4, acc, str], fmt)
      }
    }
    if (0 === pad[0]) {
      var _tk_ = pad[2], _tl_ = pad[1];
      if (typeof prec === "number")
        return prec
          ? function (p, x) {
            var
            str =
              fix_padding
                (_tl_, _tk_, fix_int_precision(p, caml_call2(trans, iconv, x)));
            return make_printf(k, [4, acc, str], fmt)
          }
          : function (x) {
            var str = fix_padding(_tl_, _tk_, caml_call2(trans, iconv, x));
            return make_printf(k, [4, acc, str], fmt)
          };
      var p$0 = prec[1];
      return function (x) {
        var
        str =
          fix_padding
            (_tl_, _tk_, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
        return make_printf(k, [4, acc, str], fmt)
      }
    }
    var _tm_ = pad[1];
    if (typeof prec === "number")
      return prec
        ? function (w, p, x) {
          var
          str =
            fix_padding
              (_tm_, w, fix_int_precision(p, caml_call2(trans, iconv, x)));
          return make_printf(k, [4, acc, str], fmt)
        }
        : function (w, x) {
          var str = fix_padding(_tm_, w, caml_call2(trans, iconv, x));
          return make_printf(k, [4, acc, str], fmt)
        };
    var p$1 = prec[1];
    return function (w, x) {
      var
      str =
        fix_padding(_tm_, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt)
    }
  }
  function make_padding(k, acc, fmt, pad, trans) {
    if (typeof pad === "number")
      return function (x) {
        var new_acc = [4, acc, caml_call1(trans, x)];
        return make_printf(k, new_acc, fmt)
      };
    if (0 === pad[0]) {
      var width = pad[2], padty = pad[1];
      return function (x) {
        var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
        return make_printf(k, new_acc, fmt)
      }
    }
    var padty$0 = pad[1];
    return function (w, x) {
      var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt)
    }
  }
  function make_printf$0(counter, k, acc, fmt) {
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for (; ;) {
      if (typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
      switch (fmt$0[0]) {
        case 0:
          var rest = fmt$0[1];
          return function (c) { var new_acc = [5, acc$0, c]; return make_printf(k$0, new_acc, rest) };
        case 1:
          var rest$0 = fmt$0[1];
          return function (c) {
            var
            str = escaped(c),
            l = caml_ml_string_length(str),
            res = make$0(l + 2 | 0, 39);
            caml_blit_string(str, 0, res, 1, l);
            var new_acc = [4, acc$0, caml_string_of_bytes(res)];
            return make_printf(k$0, new_acc, rest$0)
          };
        case 2:
          var rest$1 = fmt$0[2], pad = fmt$0[1];
          return make_padding(k$0, acc$0, rest$1, pad, function (str) { return str });
        case 3:
          var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
          return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
        case 4:
          var rest$3 = fmt$0[4], prec = fmt$0[3], pad$1 = fmt$0[2], iconv = fmt$0[1];
          return make_int_padding_precision
            (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
        case 5:
          var
            rest$4 = fmt$0[4],
            prec$0 = fmt$0[3],
            pad$2 = fmt$0[2],
            iconv$0 = fmt$0[1];
          return make_int_padding_precision
            (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
        case 6:
          var
            rest$5 = fmt$0[4],
            prec$1 = fmt$0[3],
            pad$3 = fmt$0[2],
            iconv$1 = fmt$0[1];
          return make_int_padding_precision
            (k$0, acc$0, rest$5, pad$3, prec$1, convert_nativeint, iconv$1);
        case 7:
          var
            rest$6 = fmt$0[4],
            prec$2 = fmt$0[3],
            pad$4 = fmt$0[2],
            iconv$2 = fmt$0[1];
          return make_int_padding_precision
            (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
        case 8:
          var rest$7 = fmt$0[4], prec$3 = fmt$0[3], pad$5 = fmt$0[2], fconv = fmt$0[1];
          if (typeof pad$5 === "number") {
            if (typeof prec$3 === "number")
              return prec$3
                ? function (p, x) {
                  var str = convert_float(fconv, p, x);
                  return make_printf(k$0, [4, acc$0, str], rest$7)
                }
                : function (x) {
                  var
                  str =
                    convert_float(fconv, default_float_precision(fconv), x);
                  return make_printf(k$0, [4, acc$0, str], rest$7)
                };
            var p = prec$3[1];
            return function (x) {
              var str = convert_float(fconv, p, x);
              return make_printf(k$0, [4, acc$0, str], rest$7)
            }
          }
          if (0 === pad$5[0]) {
            var _th_ = pad$5[2], _ti_ = pad$5[1];
            if (typeof prec$3 === "number")
              return prec$3
                ? function (p, x) {
                  var str = fix_padding(_ti_, _th_, convert_float(fconv, p, x));
                  return make_printf(k$0, [4, acc$0, str], rest$7)
                }
                : function (x) {
                  var
                  str = convert_float(fconv, default_float_precision(fconv), x),
                  str$0 = fix_padding(_ti_, _th_, str);
                  return make_printf(k$0, [4, acc$0, str$0], rest$7)
                };
            var p$0 = prec$3[1];
            return function (x) {
              var str = fix_padding(_ti_, _th_, convert_float(fconv, p$0, x));
              return make_printf(k$0, [4, acc$0, str], rest$7)
            }
          }
          var _tj_ = pad$5[1];
          if (typeof prec$3 === "number")
            return prec$3
              ? function (w, p, x) {
                var str = fix_padding(_tj_, w, convert_float(fconv, p, x));
                return make_printf(k$0, [4, acc$0, str], rest$7)
              }
              : function (w, x) {
                var
                str = convert_float(fconv, default_float_precision(fconv), x),
                str$0 = fix_padding(_tj_, w, str);
                return make_printf(k$0, [4, acc$0, str$0], rest$7)
              };
          var p$1 = prec$3[1];
          return function (w, x) {
            var str = fix_padding(_tj_, w, convert_float(fconv, p$1, x));
            return make_printf(k$0, [4, acc$0, str], rest$7)
          };
        case 9:
          var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
          return make_padding(k$0, acc$0, rest$8, pad$6, string_of_bool);
        case 10:
          var fmt$1 = fmt$0[1], acc$1 = [7, acc$0], acc$0 = acc$1, fmt$0 = fmt$1;
          continue;
        case 11:
          var
            fmt$2 = fmt$0[2],
            str = fmt$0[1],
            acc$2 = [2, acc$0, str],
            acc$0 = acc$2,
            fmt$0 = fmt$2;
          continue;
        case 12:
          var
            fmt$3 = fmt$0[2],
            chr = fmt$0[1],
            acc$3 = [3, acc$0, chr],
            acc$0 = acc$3,
            fmt$0 = fmt$3;
          continue;
        case 13:
          var
            rest$9 = fmt$0[3],
            sub_fmtty = fmt$0[2],
            ty = string_of_fmtty(sub_fmtty);
          return function (str) { return make_printf(k$0, [4, acc$0, ty], rest$9) };
        case 14:
          var rest$10 = fmt$0[3], fmtty = fmt$0[2];
          return function (param) {
            var fmt = param[1];
            return make_printf
              (k$0, acc$0, concat_fmt(recast(fmt, fmtty), rest$10))
          };
        case 15:
          var rest$11 = fmt$0[1];
          return function (f, x) {
            return make_printf
              (k$0,
                [6, acc$0, function (o) { return caml_call2(f, o, x) }],
                rest$11)
          };
        case 16:
          var rest$12 = fmt$0[1];
          return function (f) { return make_printf(k$0, [6, acc$0, f], rest$12) };
        case 17:
          var
            fmt$4 = fmt$0[2],
            fmting_lit = fmt$0[1],
            acc$4 = [0, acc$0, fmting_lit],
            acc$0 = acc$4,
            fmt$0 = fmt$4;
          continue;
        case 18:
          var _tf_ = fmt$0[1];
          if (0 === _tf_[0]) {
            var
            rest$13 = fmt$0[2],
            match = _tf_[1],
            fmt$5 = match[1],
            k$3 =
              function (acc, k, rest) {
                function k$0(kacc) { return make_printf(k, [1, acc, [0, kacc]], rest) }
                return k$0
              },
            k$1 = k$3(acc$0, k$0, rest$13),
            k$0 = k$1,
            acc$0 = 0,
            fmt$0 = fmt$5;
            continue
          }
          var
            rest$14 = fmt$0[2],
            match$0 = _tf_[1],
            fmt$6 = match$0[1],
            k$4 =
              function (acc, k, rest) {
                function k$0(kacc) { return make_printf(k, [1, acc, [1, kacc]], rest) }
                return k$0
              },
            k$2 = k$4(acc$0, k$0, rest$14),
            k$0 = k$2,
            acc$0 = 0,
            fmt$0 = fmt$6;
          continue;
        case 19: throw [0, Assert_failure, _aw_];
        case 20:
          var rest$15 = fmt$0[3], new_acc = [8, acc$0, cst_Printf_bad_conversion];
          return function (param) { return make_printf(k$0, new_acc, rest$15) };
        case 21:
          var rest$16 = fmt$0[2];
          return function (n) {
            var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
            return make_printf(k$0, new_acc, rest$16)
          };
        case 22:
          var rest$17 = fmt$0[1];
          return function (c) { var new_acc = [5, acc$0, c]; return make_printf(k$0, new_acc, rest$17) };
        case 23:
          var rest$18 = fmt$0[2], ign = fmt$0[1];
          if (counter >= 50)
            return caml_trampoline_return
              (make_ignored_param$0, [0, k$0, acc$0, ign, rest$18]);
          var counter$1 = counter + 1 | 0;
          return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$18);
        default:
          var
            rest$19 = fmt$0[3],
            f = fmt$0[2],
            arity = fmt$0[1],
            _tg_ = caml_call1(f, 0);
          if (counter >= 50)
            return caml_trampoline_return
              (make_custom$0, [0, k$0, acc$0, rest$19, arity, _tg_]);
          var counter$0 = counter + 1 | 0;
          return make_custom$0(counter$0, k$0, acc$0, rest$19, arity, _tg_)
      }
    }
  }
  function make_ignored_param$0(counter, k, acc, ign, fmt) {
    if (typeof ign === "number")
      switch (ign) {
        case 0:
          if (counter >= 50)
            return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
          var counter$0 = counter + 1 | 0;
          return make_invalid_arg(counter$0, k, acc, fmt);
        case 1:
          if (counter >= 50)
            return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
          var counter$1 = counter + 1 | 0;
          return make_invalid_arg(counter$1, k, acc, fmt);
        case 2: throw [0, Assert_failure, _ax_];
        default:
          if (counter >= 50)
            return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
          var counter$2 = counter + 1 | 0;
          return make_invalid_arg(counter$2, k, acc, fmt)
      }
    switch (ign[0]) {
      case 0:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$3 = counter + 1 | 0;
        return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$4 = counter + 1 | 0;
        return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$5 = counter + 1 | 0;
        return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$6 = counter + 1 | 0;
        return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$7 = counter + 1 | 0;
        return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$8 = counter + 1 | 0;
        return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$9 = counter + 1 | 0;
        return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$10 = counter + 1 | 0;
        return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$11 = counter + 1 | 0;
        return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
        var fmtty = ign[2];
        if (counter >= 50)
          return caml_trampoline_return(make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
        var counter$14 = counter + 1 | 0;
        return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$12 = counter + 1 | 0;
        return make_invalid_arg(counter$12, k, acc, fmt);
      default:
        if (counter >= 50)
          return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$13 = counter + 1 | 0;
        return make_invalid_arg(counter$13, k, acc, fmt)
    }
  }
  function make_from_fmtty$0(counter, k, acc, fmtty, fmt) {
    if (typeof fmtty !== "number")
      switch (fmtty[0]) {
        case 0:
          var rest = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest, fmt) };
        case 1:
          var rest$0 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$0, fmt) };
        case 2:
          var rest$1 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$1, fmt) };
        case 3:
          var rest$2 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$2, fmt) };
        case 4:
          var rest$3 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$3, fmt) };
        case 5:
          var rest$4 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$4, fmt) };
        case 6:
          var rest$5 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$5, fmt) };
        case 7:
          var rest$6 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$6, fmt) };
        case 8:
          var rest$7 = fmtty[2];
          return function (param) { return make_from_fmtty(k, acc, rest$7, fmt) };
        case 9:
          var
            rest$8 = fmtty[3],
            ty2 = fmtty[2],
            ty1 = fmtty[1],
            ty = trans(symm(ty1), ty2);
          return function (param) { return make_from_fmtty(k, acc, concat_fmtty(ty, rest$8), fmt) };
        case 10:
          var rest$9 = fmtty[1];
          return function (param, _te_) { return make_from_fmtty(k, acc, rest$9, fmt) };
        case 11:
          var rest$10 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$10, fmt) };
        case 12:
          var rest$11 = fmtty[1];
          return function (param) { return make_from_fmtty(k, acc, rest$11, fmt) };
        case 13: throw [0, Assert_failure, _ay_];
        default: throw [0, Assert_failure, _az_]
      }
    if (counter >= 50)
      return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt)
  }
  function make_invalid_arg(counter, k, acc, fmt) {
    var _td_ = [8, acc, cst_Printf_bad_conversion$0];
    if (counter >= 50)
      return caml_trampoline_return(make_printf$0, [0, k, _td_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _td_, fmt)
  }
  function make_custom$0(counter, k, acc, rest, arity, f) {
    if (arity) {
      var arity$0 = arity[1];
      return function (x) { return make_custom(k, acc, rest, arity$0, caml_call1(f, x)) }
    }
    var _tc_ = [4, acc, f];
    if (counter >= 50)
      return caml_trampoline_return(make_printf$0, [0, k, _tc_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _tc_, rest)
  }
  function make_printf(k, acc, fmt) { return caml_trampoline(make_printf$0(0, k, acc, fmt)) }
  function make_ignored_param(k, acc, ign, fmt) { return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt)) }
  function make_from_fmtty(k, acc, fmtty, fmt) { return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt)) }
  function make_custom(k, acc, rest, arity, f) { return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f)) }
  function fn_of_padding_precision(k, o, fmt, pad, prec) {
    if (typeof pad === "number") {
      if (typeof prec !== "number") { var _sN_ = make_iprintf(k, o, fmt); return function (_tb_) { return _sN_ } }
      if (prec) {
        var _sK_ = make_iprintf(k, o, fmt), _sL_ = function (_ta_) { return _sK_ };
        return function (_s$_) { return _sL_ }
      }
      var _sM_ = make_iprintf(k, o, fmt);
      return function (_s__) { return _sM_ }
    }
    if (0 === pad[0]) {
      if (typeof prec !== "number") { var _sR_ = make_iprintf(k, o, fmt); return function (_s9_) { return _sR_ } }
      if (prec) {
        var _sO_ = make_iprintf(k, o, fmt), _sP_ = function (_s8_) { return _sO_ };
        return function (_s7_) { return _sP_ }
      }
      var _sQ_ = make_iprintf(k, o, fmt);
      return function (_s6_) { return _sQ_ }
    }
    if (typeof prec !== "number") {
      var _sX_ = make_iprintf(k, o, fmt), _sY_ = function (_s5_) { return _sX_ };
      return function (_s4_) { return _sY_ }
    }
    if (prec) {
      var
      _sS_ = make_iprintf(k, o, fmt),
      _sT_ = function (_s3_) { return _sS_ },
      _sU_ = function (_s2_) { return _sT_ };
      return function (_s1_) { return _sU_ }
    }
    var _sV_ = make_iprintf(k, o, fmt);
    function _sW_(_s0_) { return _sV_ }
    return function (_sZ_) { return _sW_ }
  }
  function make_iprintf$0(counter, k, o, fmt) {
    var k$0 = k, fmt$0 = fmt;
    for (; ;) {
      if (typeof fmt$0 === "number") return caml_call1(k$0, o);
      switch (fmt$0[0]) {
        case 0:
          var rest = fmt$0[1], _r1_ = make_iprintf(k$0, o, rest);
          return function (_sJ_) { return _r1_ };
        case 1:
          var rest$0 = fmt$0[1], _r2_ = make_iprintf(k$0, o, rest$0);
          return function (_sI_) { return _r2_ };
        case 2:
          var _r3_ = fmt$0[1];
          if (typeof _r3_ === "number") {
            var rest$1 = fmt$0[2], _r4_ = make_iprintf(k$0, o, rest$1);
            return function (_sH_) { return _r4_ }
          }
          if (0 === _r3_[0]) {
            var rest$2 = fmt$0[2], _r5_ = make_iprintf(k$0, o, rest$2);
            return function (_sG_) { return _r5_ }
          }
          var
            rest$3 = fmt$0[2],
            _r6_ = make_iprintf(k$0, o, rest$3),
            _r7_ = function (_sF_) { return _r6_ };
          return function (_sE_) { return _r7_ };
        case 3:
          var _r8_ = fmt$0[1];
          if (typeof _r8_ === "number") {
            var rest$4 = fmt$0[2], _r9_ = make_iprintf(k$0, o, rest$4);
            return function (_sD_) { return _r9_ }
          }
          if (0 === _r8_[0]) {
            var rest$5 = fmt$0[2], _r__ = make_iprintf(k$0, o, rest$5);
            return function (_sC_) { return _r__ }
          }
          var
            rest$6 = fmt$0[2],
            _r$_ = make_iprintf(k$0, o, rest$6),
            _sa_ = function (_sB_) { return _r$_ };
          return function (_sA_) { return _sa_ };
        case 4:
          var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
          return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
        case 5:
          var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
          return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
        case 6:
          var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
          return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
        case 7:
          var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
          return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
        case 8:
          var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
          return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
        case 9:
          var _sb_ = fmt$0[1];
          if (typeof _sb_ === "number") {
            var rest$12 = fmt$0[2], _sc_ = make_iprintf(k$0, o, rest$12);
            return function (_sz_) { return _sc_ }
          }
          if (0 === _sb_[0]) {
            var rest$13 = fmt$0[2], _sd_ = make_iprintf(k$0, o, rest$13);
            return function (_sy_) { return _sd_ }
          }
          var
            rest$14 = fmt$0[2],
            _se_ = make_iprintf(k$0, o, rest$14),
            _sf_ = function (_sx_) { return _se_ };
          return function (_sw_) { return _sf_ };
        case 10: var fmt$1 = fmt$0[1], fmt$0 = fmt$1; continue;
        case 11: var fmt$2 = fmt$0[2], fmt$0 = fmt$2; continue;
        case 12: var fmt$3 = fmt$0[2], fmt$0 = fmt$3; continue;
        case 13:
          var rest$15 = fmt$0[3], _sg_ = make_iprintf(k$0, o, rest$15);
          return function (_sv_) { return _sg_ };
        case 14:
          var rest$16 = fmt$0[3], fmtty = fmt$0[2];
          return function (param) {
            var fmt = param[1];
            return make_iprintf(k$0, o, concat_fmt(recast(fmt, fmtty), rest$16))
          };
        case 15:
          var
            rest$17 = fmt$0[1],
            _sh_ = make_iprintf(k$0, o, rest$17),
            _si_ = function (_su_) { return _sh_ };
          return function (_st_) { return _si_ };
        case 16:
          var rest$18 = fmt$0[1], _sj_ = make_iprintf(k$0, o, rest$18);
          return function (_ss_) { return _sj_ };
        case 17: var fmt$4 = fmt$0[2], fmt$0 = fmt$4; continue;
        case 18:
          var _sk_ = fmt$0[1];
          if (0 === _sk_[0]) {
            var
            rest$19 = fmt$0[2],
            match = _sk_[1],
            fmt$5 = match[1],
            k$3 =
              function (k, rest) { function k$0(koc) { return make_iprintf(k, koc, rest) } return k$0 },
            k$1 = k$3(k$0, rest$19),
            k$0 = k$1,
            fmt$0 = fmt$5;
            continue
          }
          var
            rest$20 = fmt$0[2],
            match$0 = _sk_[1],
            fmt$6 = match$0[1],
            k$4 =
              function (k, rest) { function k$0(koc) { return make_iprintf(k, koc, rest) } return k$0 },
            k$2 = k$4(k$0, rest$20),
            k$0 = k$2,
            fmt$0 = fmt$6;
          continue;
        case 19: throw [0, Assert_failure, _aA_];
        case 20:
          var rest$21 = fmt$0[3], _sl_ = make_iprintf(k$0, o, rest$21);
          return function (_sr_) { return _sl_ };
        case 21:
          var rest$22 = fmt$0[2], _sm_ = make_iprintf(k$0, o, rest$22);
          return function (_sq_) { return _sm_ };
        case 22:
          var rest$23 = fmt$0[1], _sn_ = make_iprintf(k$0, o, rest$23);
          return function (_sp_) { return _sn_ };
        case 23:
          var rest$24 = fmt$0[2], ign = fmt$0[1], _so_ = 0;
          return make_ignored_param
            (function (param) { return caml_call1(k$0, o) }, _so_, ign, rest$24);
        default:
          var rest$25 = fmt$0[3], arity = fmt$0[1];
          if (counter >= 50)
            return caml_trampoline_return
              (fn_of_custom_arity$0, [0, k$0, o, rest$25, arity]);
          var counter$0 = counter + 1 | 0;
          return fn_of_custom_arity$0(counter$0, k$0, o, rest$25, arity)
      }
    }
  }
  function fn_of_custom_arity$0(counter, k, o, fmt, param) {
    if (param) {
      var arity = param[1], _rZ_ = fn_of_custom_arity(k, o, fmt, arity);
      return function (_r0_) { return _rZ_ }
    }
    if (counter >= 50)
      return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt)
  }
  function make_iprintf(k, o, fmt) { return caml_trampoline(make_iprintf$0(0, k, o, fmt)) }
  function fn_of_custom_arity(k, o, fmt, param) { return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param)) }
  function output_acc(o, acc) {
    var acc$0 = acc;
    for (; ;) {
      if (typeof acc$0 === "number") return 0;
      switch (acc$0[0]) {
        case 0:
          var
            fmting_lit = acc$0[2],
            p = acc$0[1],
            s = string_of_formatting_lit(fmting_lit);
          output_acc(o, p);
          return output_string(o, s);
        case 1:
          var _rX_ = acc$0[2], _rY_ = acc$0[1];
          if (0 === _rX_[0]) {
            var acc$1 = _rX_[1];
            output_acc(o, _rY_);
            output_string(o, cst$30);
            var acc$0 = acc$1;
            continue
          }
          var acc$2 = _rX_[1];
          output_acc(o, _rY_);
          output_string(o, cst$31);
          var acc$0 = acc$2;
          continue;
        case 6:
          var f = acc$0[2], p$2 = acc$0[1];
          output_acc(o, p$2);
          return caml_call1(f, o);
        case 7: var p$3 = acc$0[1]; output_acc(o, p$3); return caml_ml_flush(o);
        case 8:
          var msg = acc$0[2], p$4 = acc$0[1];
          output_acc(o, p$4);
          return invalid_arg(msg);
        case 2:
        case 4:
          var s$0 = acc$0[2], p$0 = acc$0[1];
          output_acc(o, p$0);
          return output_string(o, s$0);
        default:
          var c = acc$0[2], p$1 = acc$0[1];
          output_acc(o, p$1);
          return caml_ml_output_char(o, c)
      }
    }
  }
  function bufput_acc(b, acc) {
    var acc$0 = acc;
    for (; ;) {
      if (typeof acc$0 === "number") return 0;
      switch (acc$0[0]) {
        case 0:
          var
            fmting_lit = acc$0[2],
            p = acc$0[1],
            s = string_of_formatting_lit(fmting_lit);
          bufput_acc(b, p);
          return add_string(b, s);
        case 1:
          var _rV_ = acc$0[2], _rW_ = acc$0[1];
          if (0 === _rV_[0]) {
            var acc$1 = _rV_[1];
            bufput_acc(b, _rW_);
            add_string(b, cst$32);
            var acc$0 = acc$1;
            continue
          }
          var acc$2 = _rV_[1];
          bufput_acc(b, _rW_);
          add_string(b, cst$33);
          var acc$0 = acc$2;
          continue;
        case 6:
          var f = acc$0[2], p$2 = acc$0[1];
          bufput_acc(b, p$2);
          return caml_call1(f, b);
        case 7: var acc$3 = acc$0[1], acc$0 = acc$3; continue;
        case 8:
          var msg = acc$0[2], p$3 = acc$0[1];
          bufput_acc(b, p$3);
          return invalid_arg(msg);
        case 2:
        case 4:
          var s$0 = acc$0[2], p$0 = acc$0[1];
          bufput_acc(b, p$0);
          return add_string(b, s$0);
        default:
          var c = acc$0[2], p$1 = acc$0[1]; bufput_acc(b, p$1); return add_char(b, c)
      }
    }
  }
  function strput_acc(b, acc) {
    var acc$0 = acc;
    for (; ;) {
      if (typeof acc$0 === "number") return 0;
      switch (acc$0[0]) {
        case 0:
          var
            fmting_lit = acc$0[2],
            p = acc$0[1],
            s = string_of_formatting_lit(fmting_lit);
          strput_acc(b, p);
          return add_string(b, s);
        case 1:
          var _rT_ = acc$0[2], _rU_ = acc$0[1];
          if (0 === _rT_[0]) {
            var acc$1 = _rT_[1];
            strput_acc(b, _rU_);
            add_string(b, cst$34);
            var acc$0 = acc$1;
            continue
          }
          var acc$2 = _rT_[1];
          strput_acc(b, _rU_);
          add_string(b, cst$35);
          var acc$0 = acc$2;
          continue;
        case 6:
          var f = acc$0[2], p$2 = acc$0[1];
          strput_acc(b, p$2);
          return add_string(b, caml_call1(f, 0));
        case 7: var acc$3 = acc$0[1], acc$0 = acc$3; continue;
        case 8:
          var msg = acc$0[2], p$3 = acc$0[1];
          strput_acc(b, p$3);
          return invalid_arg(msg);
        case 2:
        case 4:
          var s$0 = acc$0[2], p$0 = acc$0[1];
          strput_acc(b, p$0);
          return add_string(b, s$0);
        default:
          var c = acc$0[2], p$1 = acc$0[1]; strput_acc(b, p$1); return add_char(b, c)
      }
    }
  }
  function failwith_message(param) {
    var fmt = param[1], buf = create$2(256);
    function k(acc) { strput_acc(buf, acc); return failwith(contents(buf)) }
    return make_printf(k, 0, fmt)
  }
  function open_box_of_string(str) {
    if (caml_string_equal(str, cst$36)) return _aB_;
    var len = caml_ml_string_length(str);
    function invalid_box(param) { return caml_call1(failwith_message(_aC_), str) }
    function parse_spaces(i) {
      var i$0 = i;
      for (; ;) {
        if (i$0 === len) return i$0;
        var match = caml_string_get(str, i$0);
        if (9 !== match && 32 !== match) return i$0;
        var i$1 = i$0 + 1 | 0, i$0 = i$1
      }
    }
    function parse_lword(i, j) {
      var j$0 = j;
      for (; ;) {
        if (j$0 === len) return j$0;
        var match = caml_string_get(str, j$0);
        if (25 < match - 97 >>> 0) return j$0;
        var j$1 = j$0 + 1 | 0, j$0 = j$1
      }
    }
    function parse_int(i, j) {
      var j$0 = j;
      for (; ;) {
        if (j$0 === len) return j$0;
        var match = caml_string_get(str, j$0), switch$0 = 0;
        if (48 <= match) { if (58 > match) switch$0 = 1 }
        else
          if (45 === match) switch$0 = 1;
        if (!switch$0) return j$0;
        var j$1 = j$0 + 1 | 0, j$0 = j$1
      }
    }
    var
      wstart = parse_spaces(0),
      wend = parse_lword(wstart, wstart),
      box_name = sub$0(str, wstart, wend - wstart | 0),
      nstart = parse_spaces(wend),
      nend = parse_int(nstart, nstart);
    if (nstart === nend)
      var indent = 0;
    else
      try {
        var
        _rR_ = caml_int_of_string(sub$0(str, nstart, nend - nstart | 0)),
        indent = _rR_
      }
      catch (_rS_) {
        _rS_ = caml_wrap_exception(_rS_);
        if (_rS_[1] !== Failure) throw _rS_;
        var indent = invalid_box(0)
      }
    var exp_end = parse_spaces(nend);
    if (exp_end !== len) invalid_box(0);
    var switch$0 = 0;
    if
      (caml_string_notequal(box_name, cst$37)
      &&
      caml_string_notequal(box_name, cst_b$0))
      var
        box_type =
          caml_string_notequal(box_name, cst_h)
            ? caml_string_notequal(box_name, cst_hov)
              ? caml_string_notequal(box_name, cst_hv)
                ? caml_string_notequal(box_name, cst_v) ? invalid_box(0) : 1
                : 2
              : 3
            : 0;
    else
      switch$0 = 1;
    if (switch$0) var box_type = 4;
    return [0, indent, box_type]
  }
  function make_padding_fmt_ebb(pad, fmt) {
    if (typeof pad === "number") return [0, 0, fmt];
    if (0 === pad[0]) { var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt] }
    var s$0 = pad[1];
    return [0, [1, s$0], fmt]
  }
  function make_padprec_fmt_ebb(pad, prec, fmt) {
    if (typeof prec === "number")
      var match = prec ? [0, 1, fmt] : [0, 0, fmt];
    else
      var p = prec[1], match = [0, [0, p], fmt];
    var prec$0 = match[1];
    if (typeof pad === "number") return [0, 0, prec$0, fmt];
    if (0 === pad[0]) { var w = pad[2], s = pad[1]; return [0, [0, s, w], prec$0, fmt] }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt]
  }
  function fmt_ebb_of_string(legacy_behavior, str) {
    if (legacy_behavior)
      var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
      var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg) { return caml_call3(failwith_message(_aD_), str, str_ind, msg) }
    function unexpected_end_of_format(end_ind) { return invalid_format_message(end_ind, cst_unexpected_end_of_format) }
    function invalid_format_without(str_ind, c, s) { return caml_call4(failwith_message(_aE_), str, str_ind, c, s) }
    function expected_character(str_ind, expected, read) { return caml_call4(failwith_message(_aF_), str, str_ind, expected, read) }
    function add_literal(lit_start, str_ind, fmt) {
      var size = str_ind - lit_start | 0;
      return 0 === size
        ? [0, fmt]
        : 1 === size
          ? [0, [12, caml_string_get(str, lit_start), fmt]]
          : [0, [11, sub$0(str, lit_start, size), fmt]]
    }
    function parse(lit_start, end_ind) {
      var str_ind = lit_start;
      for (; ;) {
        if (str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
        var match = caml_string_get(str, str_ind);
        if (37 === match) {
          var str_ind$2 = str_ind + 1 | 0;
          if (str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
          var
            match$1 = caml_string_get(str, str_ind$2),
            _rQ_ =
              95 === match$1
                ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
                : parse_flags(str_ind, str_ind$2, end_ind, 0),
            fmt_rest = _rQ_[1];
          return add_literal(lit_start, str_ind, fmt_rest)
        }
        if (64 !== match) { var str_ind$1 = str_ind + 1 | 0, str_ind = str_ind$1; continue }
        var str_ind$0 = str_ind + 1 | 0;
        if (str_ind$0 === end_ind)
          var match$0 = _aR_;
        else {
          var c = caml_string_get(str, str_ind$0), switch$0 = 0;
          if (65 <= c)
            if (94 <= c) {
              var switcher = c - 123 | 0;
              if (2 < switcher >>> 0)
                switch$0 = 1;
              else
                switch (switcher) {
                  case 0:
                    var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break;
                  case 1: switch$0 = 1; break;
                  default:
                    var
                      match$3 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$2 = match$3[1],
                      match$0 = [0, [17, 1, fmt_rest$2]]
                }
            }
            else
              if (91 <= c)
                switch (c - 91 | 0) {
                  case 0:
                    var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break;
                  case 1: switch$0 = 1; break;
                  default:
                    var
                      match$4 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$3 = match$4[1],
                      match$0 = [0, [17, 0, fmt_rest$3]]
                }
              else
                switch$0 = 1;
          else
            if (10 === c)
              var
                match$5 = parse(str_ind$0 + 1 | 0, end_ind),
                fmt_rest$4 = match$5[1],
                match$0 = [0, [17, 3, fmt_rest$4]];
            else
              if (32 <= c)
                switch (c - 32 | 0) {
                  case 0:
                    var
                      match$6 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$5 = match$6[1],
                      match$0 = [0, [17, _aS_, fmt_rest$5]];
                    break;
                  case 5:
                    var switch$1 = 0;
                    if
                      ((str_ind$0 + 1 | 0)
                      <
                      end_ind
                      &&
                      37
                      ===
                      caml_string_get(str, str_ind$0 + 1 | 0)) {
                      var
                      match$7 = parse(str_ind$0 + 2 | 0, end_ind),
                      fmt_rest$6 = match$7[1],
                      match$0 = [0, [17, 6, fmt_rest$6]];
                      switch$1 = 1
                    }
                    if (!switch$1)
                      var
                        match$8 = parse(str_ind$0, end_ind),
                        fmt_rest$7 = match$8[1],
                        match$0 = [0, [12, 64, fmt_rest$7]];
                    break;
                  case 12:
                    var
                      match$9 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$8 = match$9[1],
                      match$0 = [0, [17, _aT_, fmt_rest$8]];
                    break;
                  case 14:
                    var
                      match$10 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$9 = match$10[1],
                      match$0 = [0, [17, 4, fmt_rest$9]];
                    break;
                  case 27:
                    var match$0 = parse_good_break(str_ind$0 + 1 | 0, end_ind);
                    break;
                  case 28:
                    var match$0 = parse_magic_size(str_ind$0 + 1 | 0, end_ind);
                    break;
                  case 31:
                    var
                      match$11 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$10 = match$11[1],
                      match$0 = [0, [17, 2, fmt_rest$10]];
                    break;
                  case 32:
                    var
                      match$12 = parse(str_ind$0 + 1 | 0, end_ind),
                      fmt_rest$11 = match$12[1],
                      match$0 = [0, [17, 5, fmt_rest$11]];
                    break;
                  default: switch$0 = 1
                }
              else
                switch$0 = 1;
          if (switch$0)
            var
              match$2 = parse(str_ind$0 + 1 | 0, end_ind),
              fmt_rest$1 = match$2[1],
              match$0 = [0, [17, [2, c], fmt_rest$1]]
        }
        var fmt_rest$0 = match$0[1];
        return add_literal(lit_start, str_ind, fmt_rest$0)
      }
    }
    function parse_conversion
      (pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
      var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
      function get_plus(param) { plus_used[1] = 1; return plus }
      function get_hash(param) { hash_used[1] = 1; return hash }
      function get_space(param) { space_used[1] = 1; return space }
      function get_ign(param) { ign_used[1] = 1; return ign }
      function get_pad(param) { pad_used[1] = 1; return pad }
      function get_prec(param) { prec_used[1] = 1; return prec }
      function get_padprec(param) { pad_used[1] = 1; return padprec }
      function get_int_pad(param) {
        var pad = get_pad(0), match = get_prec(0);
        if (typeof match === "number" && !match) return pad;
        if (typeof pad === "number") return 0;
        if (0 !== pad[0])
          return 2 <= pad[1]
            ? legacy_behavior$0
              ? _aL_
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
            : pad;
        if (2 > pad[1]) return pad;
        var n = pad[2];
        return legacy_behavior$0
          ? [0, 1, n]
          : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0)
      }
      function check_no_0(symb, pad) {
        if (typeof pad === "number") return pad;
        if (0 !== pad[0])
          return 2 <= pad[1]
            ? legacy_behavior$0
              ? _aM_
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
            : pad;
        if (2 > pad[1]) return pad;
        var width = pad[2];
        return legacy_behavior$0
          ? [0, 1, width]
          : incompatible_flag(pct_ind, str_ind, symb, cst_0$0)
      }
      function opt_of_pad(c, pad) {
        if (typeof pad === "number") return 0;
        if (0 === pad[0])
          switch (pad[1]) {
            case 0:
              var width = pad[2];
              return legacy_behavior$0
                ? [0, width]
                : incompatible_flag(pct_ind, str_ind, c, cst$38);
            case 1: var width$0 = pad[2]; return [0, width$0];
            default:
              var width$1 = pad[2];
              return legacy_behavior$0
                ? [0, width$1]
                : incompatible_flag(pct_ind, str_ind, c, cst_0$2)
          }
        return incompatible_flag(pct_ind, str_ind, c, cst$39)
      }
      function get_pad_opt(c) { return opt_of_pad(c, get_pad(0)) }
      function get_padprec_opt(c) { return opt_of_pad(c, get_padprec(0)) }
      var switch$0 = 0;
      if (124 <= symb)
        switch$0 = 1;
      else
        switch (symb) {
          case 33:
            var
              match$6 = parse(str_ind, end_ind),
              fmt_rest$5 = match$6[1],
              fmt_result = [0, [10, fmt_rest$5]];
            break;
          case 40:
            var
              sub_end = search_subformat_end(str_ind, end_ind, 41),
              match$8 = parse(sub_end + 2 | 0, end_ind),
              fmt_rest$7 = match$8[1],
              match$9 = parse(str_ind, sub_end),
              sub_fmt = match$9[1],
              sub_fmtty = fmtty_of_fmt(sub_fmt);
            if (get_ign(0))
              var
                ignored$2 = [9, get_pad_opt(95), sub_fmtty],
                _rn_ = [0, [23, ignored$2, fmt_rest$7]];
            else
              var _rn_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
            var fmt_result = _rn_;
            break;
          case 44: var fmt_result = parse(str_ind, end_ind); break;
          case 67:
            var
              match$12 = parse(str_ind, end_ind),
              fmt_rest$10 = match$12[1],
              _rp_ = get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
              fmt_result = _rp_;
            break;
          case 78:
            var
              match$16 = parse(str_ind, end_ind),
              fmt_rest$14 = match$16[1],
              counter$0 = 2;
            if (get_ign(0))
              var ignored$6 = [11, counter$0], _rv_ = [0, [23, ignored$6, fmt_rest$14]];
            else
              var _rv_ = [0, [21, counter$0, fmt_rest$14]];
            var fmt_result = _rv_;
            break;
          case 83:
            var
              pad$6 = check_no_0(symb, get_padprec(0)),
              match$17 = parse(str_ind, end_ind),
              fmt_rest$15 = match$17[1];
            if (get_ign(0))
              var
                ignored$7 = [1, get_padprec_opt(95)],
                _rw_ = [0, [23, ignored$7, fmt_rest$15]];
            else
              var
                match$18 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
                fmt_rest$16 = match$18[2],
                pad$7 = match$18[1],
                _rw_ = [0, [3, pad$7, fmt_rest$16]];
            var fmt_result = _rw_;
            break;
          case 91:
            if (str_ind === end_ind) unexpected_end_of_format(end_ind);
            var
              char_set = create_char_set(0),
              add_char = function (c) { return add_in_char_set(char_set, c) },
              add_range =
                function (c$0, c) {
                  if (c >= c$0) {
                    var i = c$0;
                    for (; ;) {
                      add_in_char_set(char_set, char_of_int(i));
                      var _rP_ = i + 1 | 0;
                      if (c !== i) { var i = _rP_; continue }
                      break
                    }
                  }
                  return 0
                },
              fail_single_percent =
                function (str_ind) { return caml_call2(failwith_message(_aV_), str, str_ind) },
              parse_char_set_content =
                function (counter, str_ind, end_ind) {
                  var str_ind$0 = str_ind;
                  for (; ;) {
                    if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
                    var c = caml_string_get(str, str_ind$0);
                    if (45 === c) {
                      add_char(45);
                      var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
                      continue
                    }
                    if (93 === c) return str_ind$0 + 1 | 0;
                    var _rO_ = str_ind$0 + 1 | 0;
                    if (counter >= 50)
                      return caml_trampoline_return
                        (parse_char_set_after_char$0, [0, _rO_, end_ind, c]);
                    var counter$0 = counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0, _rO_, end_ind, c)
                  }
                },
              parse_char_set_after_char$0 =
                function (counter, str_ind, end_ind, c) {
                  var str_ind$0 = str_ind, c$0 = c;
                  for (; ;) {
                    if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
                    var c$1 = caml_string_get(str, str_ind$0), switch$0 = 0;
                    if (46 <= c$1) {
                      if (64 === c$1)
                        switch$0 = 1;
                      else
                        if (93 === c$1) { add_char(c$0); return str_ind$0 + 1 | 0 }
                    }
                    else
                      if (37 === c$1)
                        switch$0 = 1;
                      else
                        if (45 <= c$1) {
                          var str_ind$2 = str_ind$0 + 1 | 0;
                          if (str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
                          var c$2 = caml_string_get(str, str_ind$2);
                          if (37 === c$2) {
                            if ((str_ind$2 + 1 | 0) === end_ind)
                              unexpected_end_of_format(end_ind);
                            var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                            if (37 !== c$3 && 64 !== c$3)
                              return fail_single_percent(str_ind$2);
                            add_range(c$0, c$3);
                            var _rM_ = str_ind$2 + 2 | 0;
                            if (counter >= 50)
                              return caml_trampoline_return
                                (parse_char_set_content, [0, _rM_, end_ind]);
                            var counter$2 = counter + 1 | 0;
                            return parse_char_set_content(counter$2, _rM_, end_ind)
                          }
                          if (93 === c$2) { add_char(c$0); add_char(45); return str_ind$2 + 1 | 0 }
                          add_range(c$0, c$2);
                          var _rN_ = str_ind$2 + 1 | 0;
                          if (counter >= 50)
                            return caml_trampoline_return
                              (parse_char_set_content, [0, _rN_, end_ind]);
                          var counter$1 = counter + 1 | 0;
                          return parse_char_set_content(counter$1, _rN_, end_ind)
                        }
                    if (switch$0 && 37 === c$0) {
                      add_char(c$1);
                      var _rL_ = str_ind$0 + 1 | 0;
                      if (counter >= 50)
                        return caml_trampoline_return
                          (parse_char_set_content, [0, _rL_, end_ind]);
                      var counter$0 = counter + 1 | 0;
                      return parse_char_set_content(counter$0, _rL_, end_ind)
                    }
                    if (37 === c$0) fail_single_percent(str_ind$0);
                    add_char(c$0);
                    var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1, c$0 = c$1
                  }
                },
              parse_char_set_after_char =
                function (str_ind, end_ind, c) {
                  return caml_trampoline
                    (parse_char_set_after_char$0(0, str_ind, end_ind, c))
                };
            if (str_ind === end_ind) unexpected_end_of_format(end_ind);
            var match$31 = caml_string_get(str, str_ind);
            if (94 === match$31)
              var str_ind$0 = str_ind + 1 | 0, reverse = 1, str_ind$1 = str_ind$0;
            else
              var reverse = 0, str_ind$1 = str_ind;
            if (str_ind$1 === end_ind) unexpected_end_of_format(end_ind);
            var
              c = caml_string_get(str, str_ind$1),
              next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
              char_set$0 = freeze_char_set(char_set),
              char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
              match$21 = parse(next_ind, end_ind),
              fmt_rest$19 = match$21[1];
            if (get_ign(0))
              var
                ignored$9 = [10, get_pad_opt(95), char_set$1],
                _rB_ = [0, [23, ignored$9, fmt_rest$19]];
            else
              var _rB_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
            var fmt_result = _rB_;
            break;
          case 97:
            var
              match$22 = parse(str_ind, end_ind),
              fmt_rest$20 = match$22[1],
              fmt_result = [0, [15, fmt_rest$20]];
            break;
          case 99:
            var
              char_format =
                function (fmt_rest) { return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]] },
              match$23 = parse(str_ind, end_ind),
              fmt_rest$21 = match$23[1],
              match$24 = get_pad_opt(99);
            if (match$24) {
              if (0 === match$24[1])
                var
                  _rC_ = get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
                  _rD_ = _rC_;
              else
                var
                  _rD_ =
                    legacy_behavior$0
                      ? char_format(fmt_rest$21)
                      : invalid_format_message
                        (str_ind, cst_non_zero_widths_are_unsupp);
              var _rE_ = _rD_
            }
            else
              var _rE_ = char_format(fmt_rest$21);
            var fmt_result = _rE_;
            break;
          case 114:
            var
              match$25 = parse(str_ind, end_ind),
              fmt_rest$22 = match$25[1],
              _rF_ = get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
              fmt_result = _rF_;
            break;
          case 115:
            var
              pad$9 = check_no_0(symb, get_padprec(0)),
              match$26 = parse(str_ind, end_ind),
              fmt_rest$23 = match$26[1];
            if (get_ign(0))
              var
                ignored$10 = [0, get_padprec_opt(95)],
                _rG_ = [0, [23, ignored$10, fmt_rest$23]];
            else
              var
                match$27 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
                fmt_rest$24 = match$27[2],
                pad$10 = match$27[1],
                _rG_ = [0, [2, pad$10, fmt_rest$24]];
            var fmt_result = _rG_;
            break;
          case 116:
            var
              match$28 = parse(str_ind, end_ind),
              fmt_rest$25 = match$28[1],
              fmt_result = [0, [16, fmt_rest$25]];
            break;
          case 123:
            var
              sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
              match$29 = parse(str_ind, sub_end$0),
              sub_fmt$0 = match$29[1],
              match$30 = parse(sub_end$0 + 2 | 0, end_ind),
              fmt_rest$26 = match$30[1],
              sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
            if (get_ign(0))
              var
                ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
                _rH_ = [0, [23, ignored$11, fmt_rest$26]];
            else
              var _rH_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
            var fmt_result = _rH_;
            break;
          case 66:
          case 98:
            var
              pad$3 = check_no_0(symb, get_padprec(0)),
              match$10 = parse(str_ind, end_ind),
              fmt_rest$8 = match$10[1];
            if (get_ign(0))
              var
                ignored$3 = [7, get_padprec_opt(95)],
                _ro_ = [0, [23, ignored$3, fmt_rest$8]];
            else
              var
                match$11 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
                fmt_rest$9 = match$11[2],
                pad$4 = match$11[1],
                _ro_ = [0, [9, pad$4, fmt_rest$9]];
            var fmt_result = _ro_;
            break;
          case 37:
          case 64:
            var
              match$7 = parse(str_ind, end_ind),
              fmt_rest$6 = match$7[1],
              fmt_result = [0, [12, symb, fmt_rest$6]];
            break;
          case 76:
          case 108:
          case 110:
            var switch$1 = 0;
            if (str_ind !== end_ind) {
              var
              symb$0 = caml_string_get(str, str_ind),
              _rI_ = symb$0 - 88 | 0,
              switch$2 = 0;
              if (32 >= _rI_ >>> 0)
                switch (_rI_) {
                  case 0:
                  case 12:
                  case 17:
                  case 23:
                  case 29:
                  case 32: var _ru_ = 1; switch$2 = 1; break
                }
              if (!switch$2) var _ru_ = 0;
              if (_ru_) { switch$0 = 1; switch$1 = 1 }
            }
            if (!switch$1) {
              var
              match$15 = parse(str_ind, end_ind),
              fmt_rest$13 = match$15[1],
              switch$3 = 0;
              if (108 <= symb) {
                if (111 > symb)
                  switch (symb - 108 | 0) {
                    case 0: var counter = 0; switch$3 = 1; break;
                    case 1: break;
                    default: var counter = 1; switch$3 = 1
                  }
              }
              else
                if (76 === symb) { var counter = 2; switch$3 = 1 }
              if (!switch$3) throw [0, Assert_failure, _aZ_];
              if (get_ign(0))
                var ignored$5 = [11, counter], _rt_ = [0, [23, ignored$5, fmt_rest$13]];
              else
                var _rt_ = [0, [21, counter, fmt_rest$13]];
              var fmt_result = _rt_
            }
            break;
          case 32:
          case 35:
          case 43:
          case 45:
          case 95:
            var
              fmt_result =
                caml_call3(failwith_message(_aQ_), str, pct_ind, symb);
            break;
          case 88:
          case 100:
          case 105:
          case 111:
          case 117:
          case 120:
            var
              _rx_ = get_space(0),
              _ry_ = get_hash(0),
              iconv$2 =
                compute_int_conv(pct_ind, str_ind, get_plus(0), _ry_, _rx_, symb),
              match$19 = parse(str_ind, end_ind),
              fmt_rest$17 = match$19[1];
            if (get_ign(0))
              var
                ignored$8 = [2, iconv$2, get_pad_opt(95)],
                _rz_ = [0, [23, ignored$8, fmt_rest$17]];
            else
              var
                _rA_ = get_prec(0),
                match$20 = make_padprec_fmt_ebb(get_int_pad(0), _rA_, fmt_rest$17),
                fmt_rest$18 = match$20[3],
                prec$4 = match$20[2],
                pad$8 = match$20[1],
                _rz_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
            var fmt_result = _rz_;
            break;
          case 69:
          case 70:
          case 71:
          case 72:
          case 101:
          case 102:
          case 103:
          case 104:
            var
              space$1 = get_space(0),
              hash$1 = get_hash(0),
              plus$2 = get_plus(0),
              flag =
                plus$2
                  ? space$1
                    ? legacy_behavior$0
                      ? 1
                      : incompatible_flag(pct_ind, str_ind, 32, cst$50)
                    : 1
                  : space$1 ? 2 : 0,
              switch$4 = 0;
            if (73 <= symb) {
              var switcher = symb - 101 | 0;
              if (3 < switcher >>> 0)
                switch$4 = 1;
              else {
                switch (switcher) {
                  case 0: var _rJ_ = 1; break;
                  case 1: var _rJ_ = 0; break;
                  case 2: var _rJ_ = 3; break;
                  default: var _rJ_ = 6
                }
                var kind = _rJ_
              }
            }
            else
              if (69 <= symb) {
                var switch$5 = 0;
                switch (symb - 69 | 0) {
                  case 0: var _rK_ = 2; break;
                  case 1: switch$4 = 1; switch$5 = 1; break;
                  case 2: var _rK_ = 4; break;
                  default: var _rK_ = 7
                }
                if (!switch$5) var kind = _rK_
              }
              else
                switch$4 = 1;
            if (switch$4) {
              var switch$6 = 0;
              if (hash$1)
                if (70 === symb) var kind = 8; else switch$6 = 1;
              else
                if (70 === symb) var kind = 5; else switch$6 = 1;
              if (switch$6) throw [0, Assert_failure, _a1_]
            }
            var
              fconv = [0, flag, kind],
              match$13 = parse(str_ind, end_ind),
              fmt_rest$11 = match$13[1];
            if (get_ign(0)) {
              var match = get_prec(0);
              if (typeof match === "number")
                var _rq_ = match ? incompatible_flag(pct_ind, str_ind, 95, cst$40) : 0;
              else
                var ndec = match[1], _rq_ = [0, ndec];
              var
                ignored$4 = [6, get_pad_opt(95), _rq_],
                _rr_ = [0, [23, ignored$4, fmt_rest$11]]
            }
            else
              var
                _rs_ = get_prec(0),
                match$14 = make_padprec_fmt_ebb(get_pad(0), _rs_, fmt_rest$11),
                fmt_rest$12 = match$14[3],
                prec$3 = match$14[2],
                pad$5 = match$14[1],
                _rr_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
            var fmt_result = _rr_;
            break;
          default: switch$0 = 1
        }
      if (switch$0) {
        var switch$7 = 0;
        if (108 <= symb)
          if (111 <= symb)
            switch$7 = 1;
          else {
            var switch$8 = 0;
            switch (symb - 108 | 0) {
              case 0:
                var
                  _q9_ = caml_string_get(str, str_ind),
                  _q__ = get_space(0),
                  _q$_ = get_hash(0),
                  iconv =
                    compute_int_conv
                      (pct_ind, str_ind + 1 | 0, get_plus(0), _q$_, _q__, _q9_),
                  match$0 = parse(str_ind + 1 | 0, end_ind),
                  fmt_rest = match$0[1];
                if (get_ign(0))
                  var
                    ignored = [3, iconv, get_pad_opt(95)],
                    _ra_ = [0, [23, ignored, fmt_rest]];
                else
                  var
                    _rc_ = get_prec(0),
                    match$1 = make_padprec_fmt_ebb(get_int_pad(0), _rc_, fmt_rest),
                    fmt_rest$0 = match$1[3],
                    prec$0 = match$1[2],
                    pad$0 = match$1[1],
                    _ra_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
                var _rb_ = _ra_;
                break;
              case 1: switch$7 = 1; switch$8 = 1; break;
              default:
                var
                  _rd_ = caml_string_get(str, str_ind),
                  _re_ = get_space(0),
                  _rf_ = get_hash(0),
                  iconv$0 =
                    compute_int_conv
                      (pct_ind, str_ind + 1 | 0, get_plus(0), _rf_, _re_, _rd_),
                  match$2 = parse(str_ind + 1 | 0, end_ind),
                  fmt_rest$1 = match$2[1];
                if (get_ign(0))
                  var
                    ignored$0 = [4, iconv$0, get_pad_opt(95)],
                    _rg_ = [0, [23, ignored$0, fmt_rest$1]];
                else
                  var
                    _rh_ = get_prec(0),
                    match$3 = make_padprec_fmt_ebb(get_int_pad(0), _rh_, fmt_rest$1),
                    fmt_rest$2 = match$3[3],
                    prec$1 = match$3[2],
                    pad$1 = match$3[1],
                    _rg_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
                var _rb_ = _rg_
            }
            if (!switch$8) var fmt_result = _rb_
          }
        else
          if (76 === symb) {
            var
            _ri_ = caml_string_get(str, str_ind),
            _rj_ = get_space(0),
            _rk_ = get_hash(0),
            iconv$1 =
              compute_int_conv
                (pct_ind, str_ind + 1 | 0, get_plus(0), _rk_, _rj_, _ri_),
            match$4 = parse(str_ind + 1 | 0, end_ind),
            fmt_rest$3 = match$4[1];
            if (get_ign(0))
              var
                ignored$1 = [5, iconv$1, get_pad_opt(95)],
                _rl_ = [0, [23, ignored$1, fmt_rest$3]];
            else
              var
                _rm_ = get_prec(0),
                match$5 = make_padprec_fmt_ebb(get_int_pad(0), _rm_, fmt_rest$3),
                fmt_rest$4 = match$5[3],
                prec$2 = match$5[2],
                pad$2 = match$5[1],
                _rl_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
            var fmt_result = _rl_
          }
          else
            switch$7 = 1;
        if (switch$7)
          var
            fmt_result =
              caml_call3(failwith_message(_aN_), str, str_ind - 1 | 0, symb)
      }
      if (1 - legacy_behavior$0) {
        var _q0_ = 1 - plus_used[1], plus$0 = _q0_ ? plus : _q0_;
        if (plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$41);
        var _q1_ = 1 - hash_used[1], hash$0 = _q1_ ? hash : _q1_;
        if (hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$42);
        var _q2_ = 1 - space_used[1], space$0 = _q2_ ? space : _q2_;
        if (space$0) incompatible_flag(pct_ind, str_ind, symb, cst$43);
        var _q3_ = 1 - pad_used[1], _q4_ = _q3_ ? caml_notequal([0, pad], _aO_) : _q3_;
        if (_q4_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
        var
          _q5_ = 1 - prec_used[1],
          _q6_ = _q5_ ? caml_notequal([0, prec], _aP_) : _q5_;
        if (_q6_) {
          var _q7_ = ign ? 95 : symb;
          incompatible_flag(pct_ind, str_ind, _q7_, cst_precision$2)
        }
        var plus$1 = ign ? plus : ign;
        if (plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$44)
      }
      var _q8_ = 1 - ign_used[1], ign$0 = _q8_ ? ign : _q8_;
      if (ign$0) {
        var switch$9 = 0;
        if (38 <= symb) { if (44 !== symb && 64 !== symb) switch$9 = 1 }
        else
          if (33 !== symb && 37 > symb) switch$9 = 1;
        var switch$10 = 0;
        if (switch$9 || !legacy_behavior$0) switch$10 = 1;
        if (switch$10) incompatible_flag(pct_ind, str_ind, symb, cst$45)
      }
      return fmt_result
    }
    function parse_after_precision
      (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
      if (str_ind === end_ind) unexpected_end_of_format(end_ind);
      function parse_conv(padprec) {
        return parse_conversion
          (pct_ind,
            str_ind + 1 | 0,
            end_ind,
            plus,
            hash,
            space,
            ign,
            pad,
            prec,
            padprec,
            caml_string_get(str, str_ind))
      }
      if (typeof pad !== "number") return parse_conv(pad);
      if (typeof prec === "number" && !prec) return parse_conv(0);
      if (minus) {
        if (typeof prec === "number") return parse_conv(_aJ_);
        var n = prec[1];
        return parse_conv([0, 0, n])
      }
      if (typeof prec === "number") return parse_conv(_aK_);
      var n$0 = prec[1];
      return parse_conv([0, 1, n$0])
    }
    function parse_after_padding
      (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
      if (str_ind === end_ind) unexpected_end_of_format(end_ind);
      var symb = caml_string_get(str, str_ind);
      if (46 !== symb)
        return parse_conversion
          (pct_ind,
            str_ind + 1 | 0,
            end_ind,
            plus,
            hash,
            space,
            ign,
            pad,
            0,
            pad,
            symb);
      var str_ind$0 = str_ind + 1 | 0;
      if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      function parse_literal(minus, str_ind) {
        var
        match = parse_positive(str_ind, end_ind, 0),
        prec = match[2],
        new_ind = match[1];
        return parse_after_precision
          (pct_ind,
            new_ind,
            end_ind,
            minus,
            plus,
            hash,
            space,
            ign,
            pad,
            [0, prec])
      }
      var symb$0 = caml_string_get(str, str_ind$0);
      if (48 <= symb$0) { if (58 > symb$0) return parse_literal(minus, str_ind$0) }
      else
        if (42 <= symb$0)
          switch (symb$0 - 42 | 0) {
            case 0:
              return parse_after_precision
                (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
            case 1:
            case 3:
              if (legacy_behavior$0) {
                var
                _qZ_ = str_ind$0 + 1 | 0,
                minus$0 = minus || (45 === symb$0 ? 1 : 0);
                return parse_literal(minus$0, _qZ_)
              }
              break
          }
      return legacy_behavior$0
        ? parse_after_precision
          (pct_ind,
            str_ind$0,
            end_ind,
            minus,
            plus,
            hash,
            space,
            ign,
            pad,
            _aI_)
        : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision)
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign) {
      var zero = [0, 0], minus = [0, 0], plus = [0, 0], space = [0, 0], hash = [0, 0];
      function set_flag(str_ind, flag) {
        var _qW_ = flag[1], _qX_ = _qW_ ? 1 - legacy_behavior$0 : _qW_;
        if (_qX_) {
          var _qY_ = caml_string_get(str, str_ind);
          caml_call3(failwith_message(_aG_), str, str_ind, _qY_)
        }
        flag[1] = 1;
        return 0
      }
      var str_ind$0 = str_ind;
      for (; ;) {
        if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
        var match = caml_string_get(str, str_ind$0), switcher = match - 32 | 0;
        if (16 >= switcher >>> 0)
          switch (switcher) {
            case 0:
              set_flag(str_ind$0, space);
              var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
              continue;
            case 3:
              set_flag(str_ind$0, hash);
              var str_ind$2 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$2;
              continue;
            case 11:
              set_flag(str_ind$0, plus);
              var str_ind$3 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$3;
              continue;
            case 13:
              set_flag(str_ind$0, minus);
              var str_ind$4 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$4;
              continue;
            case 16:
              set_flag(str_ind$0, zero);
              var str_ind$5 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$5;
              continue
          }
        var
          _qR_ = space[1],
          _qS_ = hash[1],
          _qT_ = plus[1],
          _qU_ = minus[1],
          _qV_ = zero[1];
        if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
        var
          padty =
            _qV_
              ? _qU_
                ? legacy_behavior$0
                  ? 0
                  : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
                : 2
              : _qU_ ? 0 : 1,
          match$0 = caml_string_get(str, str_ind$0);
        if (48 <= match$0) {
          if (58 > match$0) {
            var
            match$1 = parse_positive(str_ind$0, end_ind, 0),
            width = match$1[2],
            new_ind = match$1[1];
            return parse_after_padding
              (pct_ind,
                new_ind,
                end_ind,
                _qU_,
                _qT_,
                _qS_,
                _qR_,
                ign,
                [0, padty, width])
          }
        }
        else
          if (42 === match$0)
            return parse_after_padding
              (pct_ind,
                str_ind$0 + 1 | 0,
                end_ind,
                _qU_,
                _qT_,
                _qS_,
                _qR_,
                ign,
                [1, padty]);
        switch (padty) {
          case 0:
            if (1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
            return parse_after_padding
              (pct_ind, str_ind$0, end_ind, _qU_, _qT_, _qS_, _qR_, ign, 0);
          case 1:
            return parse_after_padding
              (pct_ind, str_ind$0, end_ind, _qU_, _qT_, _qS_, _qR_, ign, 0);
          default:
            return parse_after_padding
              (pct_ind, str_ind$0, end_ind, _qU_, _qT_, _qS_, _qR_, ign, _aH_)
        }
      }
    }
    function parse_tag(is_open_tag, str_ind, end_ind) {
      try {
        if (str_ind === end_ind) throw Not_found;
        var match$0 = caml_string_get(str, str_ind);
        if (60 !== match$0) throw Not_found;
        var ind = index_from$0(str, str_ind + 1 | 0, 62);
        if (end_ind <= ind) throw Not_found;
        var
          sub_str = sub$0(str, str_ind, (ind - str_ind | 0) + 1 | 0),
          match$1 = parse(ind + 1 | 0, end_ind),
          fmt_rest$0 = match$1[1],
          match$2 = parse(str_ind, ind + 1 | 0),
          sub_fmt = match$2[1],
          sub_format$0 = [0, sub_fmt, sub_str],
          formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
          _qP_ = [0, [18, formatting$0, fmt_rest$0]];
        return _qP_
      }
      catch (_qQ_) {
        _qQ_ = caml_wrap_exception(_qQ_);
        if (_qQ_ !== Not_found) throw _qQ_;
        var
          match = parse(str_ind, end_ind),
          fmt_rest = match[1],
          formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
        return [0, [18, formatting, fmt_rest]]
      }
    }
    function parse_good_break(str_ind, end_ind) {
      try {
        var
        _qI_ = str_ind === end_ind ? 1 : 0,
        _qJ_ = _qI_ || (60 !== caml_string_get(str, str_ind) ? 1 : 0);
        if (_qJ_) throw Not_found;
        var
          str_ind_1 = parse_spaces(str_ind + 1 | 0, end_ind),
          match$0 = caml_string_get(str, str_ind_1),
          switch$0 = 0;
        if (48 <= match$0) { if (58 > match$0) switch$0 = 1 }
        else
          if (45 === match$0) switch$0 = 1;
        if (!switch$0) throw Not_found;
        var
          match$1 = parse_integer(str_ind_1, end_ind),
          width = match$1[2],
          str_ind_2 = match$1[1],
          str_ind_3 = parse_spaces(str_ind_2, end_ind),
          match$2 = caml_string_get(str, str_ind_3),
          switcher = match$2 - 45 | 0,
          switch$1 = 0;
        if (12 < switcher >>> 0)
          if (17 === switcher)
            var
              s = sub$0(str, str_ind - 2 | 0, (str_ind_3 - str_ind | 0) + 3 | 0),
              _qK_ = [0, s, width, 0],
              _qL_ = str_ind_3 + 1 | 0,
              formatting_lit$0 = _qK_,
              next_ind = _qL_;
          else
            switch$1 = 1;
        else
          if (1 < switcher - 1 >>> 0) {
            var
            match$3 = parse_integer(str_ind_3, end_ind),
            offset = match$3[2],
            str_ind_4 = match$3[1],
            str_ind_5 = parse_spaces(str_ind_4, end_ind);
            if (62 !== caml_string_get(str, str_ind_5)) throw Not_found;
            var
              s$0 = sub$0(str, str_ind - 2 | 0, (str_ind_5 - str_ind | 0) + 3 | 0),
              _qM_ = [0, s$0, width, offset],
              _qN_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _qM_,
              next_ind = _qN_
          }
          else
            switch$1 = 1;
        if (switch$1) throw Not_found
      }
      catch (_qO_) {
        _qO_ = caml_wrap_exception(_qO_);
        if (_qO_ !== Not_found && _qO_[1] !== Failure) throw _qO_;
        var formatting_lit$0 = formatting_lit, next_ind = str_ind
      }
      var match = parse(next_ind, end_ind), fmt_rest = match[1];
      return [0, [17, formatting_lit$0, fmt_rest]]
    }
    function parse_magic_size(str_ind, end_ind) {
      try {
        var
        str_ind_1 = parse_spaces(str_ind, end_ind),
        match$2 = caml_string_get(str, str_ind_1),
        switch$0 = 0;
        if (48 <= match$2) { if (58 > match$2) switch$0 = 1 }
        else
          if (45 === match$2) switch$0 = 1;
        if (switch$0) {
          var
          match$3 = parse_integer(str_ind_1, end_ind),
          size = match$3[2],
          str_ind_2 = match$3[1],
          str_ind_3 = parse_spaces(str_ind_2, end_ind);
          if (62 !== caml_string_get(str, str_ind_3)) throw Not_found;
          var
            s = sub$0(str, str_ind - 2 | 0, (str_ind_3 - str_ind | 0) + 3 | 0),
            _qG_ = [0, [0, str_ind_3 + 1 | 0, [1, s, size]]]
        }
        else
          var _qG_ = 0;
        var _qF_ = _qG_
      }
      catch (_qH_) {
        _qH_ = caml_wrap_exception(_qH_);
        if (_qH_ !== Not_found && _qH_[1] !== Failure) throw _qH_;
        var _qF_ = 0
      }
      if (_qF_) {
        var
        match = _qF_[1],
        formatting_lit = match[2],
        next_ind = match[1],
        match$0 = parse(next_ind, end_ind),
        fmt_rest = match$0[1];
        return [0, [17, formatting_lit, fmt_rest]]
      }
      var match$1 = parse(str_ind, end_ind), fmt_rest$0 = match$1[1];
      return [0, [17, _aU_, fmt_rest$0]]
    }
    function parse_spaces(str_ind, end_ind) {
      var str_ind$0 = str_ind;
      for (; ;) {
        if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
        if (32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
        var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1
      }
    }
    function parse_positive(str_ind, end_ind, acc) {
      var str_ind$0 = str_ind, acc$0 = acc;
      for (; ;) {
        if (str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
        var c = caml_string_get(str, str_ind$0);
        if (9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
        var acc$1 = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
        if (max_string_length < acc$1)
          return caml_call3
            (failwith_message(_aW_), str, acc$1, max_string_length);
        var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1, acc$0 = acc$1
      }
    }
    function parse_integer(str_ind, end_ind) {
      if (str_ind === end_ind) unexpected_end_of_format(end_ind);
      var match = caml_string_get(str, str_ind);
      if (48 <= match) { if (58 > match) return parse_positive(str_ind, end_ind, 0) }
      else
        if (45 === match) {
          if ((str_ind + 1 | 0) === end_ind) unexpected_end_of_format(end_ind);
          var c = caml_string_get(str, str_ind + 1 | 0);
          if (9 < c - 48 >>> 0)
            return expected_character(str_ind + 1 | 0, cst_digit, c);
          var
            match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
            n = match$0[2],
            next_ind = match$0[1];
          return [0, next_ind, - n | 0]
        }
      throw [0, Assert_failure, _aX_]
    }
    function search_subformat_end(str_ind, end_ind, c) {
      var str_ind$0 = str_ind;
      for (; ;) {
        if (str_ind$0 === end_ind)
          caml_call3(failwith_message(_aY_), str, c, end_ind);
        var match = caml_string_get(str, str_ind$0);
        if (37 !== match) { var str_ind$7 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$7; continue }
        if ((str_ind$0 + 1 | 0) === end_ind)
          unexpected_end_of_format(end_ind);
        if (caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
        var match$0 = caml_string_get(str, str_ind$0 + 1 | 0);
        if (95 <= match$0) {
          if (123 <= match$0) {
            if (126 > match$0)
              switch (match$0 - 123 | 0) {
                case 0:
                  var
                    sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
                    str_ind$2 = sub_end + 2 | 0,
                    str_ind$0 = str_ind$2;
                  continue;
                case 1: break;
                default:
                  return expected_character
                    (str_ind$0 + 1 | 0, cst_character, 125)
              }
          }
          else
            if (96 > match$0) {
              if ((str_ind$0 + 2 | 0) === end_ind)
                unexpected_end_of_format(end_ind);
              var match$1 = caml_string_get(str, str_ind$0 + 2 | 0);
              if (40 === match$1) {
                var
                sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
                str_ind$3 = sub_end$0 + 2 | 0,
                str_ind$0 = str_ind$3;
                continue
              }
              if (123 === match$1) {
                var
                sub_end$1 =
                  search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
                str_ind$4 = sub_end$1 + 2 | 0,
                str_ind$0 = str_ind$4;
                continue
              }
              var str_ind$5 = str_ind$0 + 3 | 0, str_ind$0 = str_ind$5;
              continue
            }
        }
        else {
          if (40 === match$0) {
            var
            sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
            str_ind$6 = sub_end$2 + 2 | 0,
            str_ind$0 = str_ind$6;
            continue
          }
          if (41 === match$0)
            return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41)
        }
        var str_ind$1 = str_ind$0 + 2 | 0, str_ind$0 = str_ind$1
      }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option) {
      var subfmt = sub$0(str, pct_ind, str_ind - pct_ind | 0);
      return caml_call5
        (failwith_message(_a2_), str, pct_ind, option, symb, subfmt)
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb) {
      var plus$0 = plus, hash$0 = hash, space$0 = space;
      for (; ;) {
        var switch$0 = 0;
        if (plus$0) {
          if (hash$0)
            switch$0 = 1;
          else
            if (!space$0) { if (100 === symb) return 1; if (105 === symb) return 4 }
        }
        else
          if (hash$0)
            if (space$0)
              switch$0 = 1;
            else {
              var switcher$0 = symb - 88 | 0;
              if (32 < switcher$0 >>> 0)
                switch$0 = 1;
              else
                switch (switcher$0) {
                  case 0: return 9;
                  case 12: return 13;
                  case 17: return 14;
                  case 23: return 11;
                  case 29: return 15;
                  case 32: return 7;
                  default: switch$0 = 1
                }
            }
          else
            if (space$0) { if (100 === symb) return 2; if (105 === symb) return 5 }
            else {
              var switcher$1 = symb - 88 | 0;
              if (32 >= switcher$1 >>> 0)
                switch (switcher$1) {
                  case 0: return 8;
                  case 12: return 0;
                  case 17: return 3;
                  case 23: return 10;
                  case 29: return 12;
                  case 32: return 6
                }
            }
        if (switch$0) {
          var switcher = symb - 88 | 0;
          if (32 >= switcher >>> 0)
            switch (switcher) {
              case 0: if (legacy_behavior$0) return 9; break;
              case 23: if (legacy_behavior$0) return 11; break;
              case 32: if (legacy_behavior$0) return 7; break;
              case 12:
              case 17:
              case 29:
                if (!legacy_behavior$0)
                  return incompatible_flag(pct_ind, str_ind, symb, cst$49);
                var hash$0 = 0;
                continue
            }
        }
        if (!plus$0) {
          if (!space$0) throw [0, Assert_failure, _a0_];
          if (!legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$48);
          var space$0 = 0;
          continue
        }
        if (space$0) {
          if (!legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, 32, cst$46);
          var space$0 = 0;
          continue
        }
        if (!legacy_behavior$0)
          return incompatible_flag(pct_ind, str_ind, symb, cst$47);
        var plus$0 = 0
      }
    }
    return parse(0, caml_ml_string_length(str))
  }
  function format_of_string_fmtty(str, fmtty) {
    var match = fmt_ebb_of_string(0, str), fmt = match[1];
    try { var _qD_ = [0, type_format(fmt, fmtty), str]; return _qD_ }
    catch (_qE_) {
      _qE_ = caml_wrap_exception(_qE_);
      if (_qE_ !== Type_mismatch) throw _qE_;
      var _qC_ = string_of_fmtty(fmtty);
      return caml_call2(failwith_message(_a3_), str, _qC_)
    }
  }
  function format_of_string_format(str, param) {
    var
    str$0 = param[2],
    fmt = param[1],
    match = fmt_ebb_of_string(0, str),
    fmt$0 = match[1];
    try { var _qA_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str]; return _qA_ }
    catch (_qB_) {
      _qB_ = caml_wrap_exception(_qB_);
      if (_qB_ === Type_mismatch)
        return caml_call2(failwith_message(_a4_), str, str$0);
      throw _qB_
    }
  }
  var
    CamlinternalFormat =
      [0,
        is_in_char_set,
        rev_char_set,
        create_char_set,
        add_in_char_set,
        freeze_char_set,
        param_format_of_ignored_format,
        make_printf,
        make_iprintf,
        output_acc,
        bufput_acc,
        strput_acc,
        type_format,
        fmt_ebb_of_string,
        format_of_string_fmtty,
        format_of_string_format,
        char_of_iconv,
        string_of_formatting_lit,
        string_of_fmtty,
        string_of_fmt,
        open_box_of_string,
        symm,
        trans,
        recast];
  caml_register_global(807, CamlinternalFormat, "CamlinternalFormat");
  function kfprintf(k, o, param) {
    var fmt = param[1], _qz_ = 0;
    return make_printf
      (function (acc) { output_acc(o, acc); return caml_call1(k, o) },
        _qz_,
        fmt)
  }
  function kbprintf(k, b, param) {
    var fmt = param[1], _qy_ = 0;
    return make_printf
      (function (acc) { bufput_acc(b, acc); return caml_call1(k, b) },
        _qy_,
        fmt)
  }
  function ikfprintf(k, oc, param) { var fmt = param[1]; return make_iprintf(k, oc, fmt) }
  function fprintf(oc, fmt) { return kfprintf(function (_qx_) { return 0 }, oc, fmt) }
  function bprintf(b, fmt) { return kbprintf(function (_qw_) { return 0 }, b, fmt) }
  function ifprintf(oc, fmt) { return ikfprintf(function (_qv_) { return 0 }, oc, fmt) }
  function ibprintf(b, fmt) { return ikfprintf(function (_qu_) { return 0 }, b, fmt) }
  function printf(fmt) { return fprintf(stdout, fmt) }
  function eprintf(fmt) { return fprintf(stderr, fmt) }
  function ksprintf(k, param) {
    var fmt = param[1];
    function k$0(acc) {
      var buf = create$2(64);
      strput_acc(buf, acc);
      return caml_call1(k, contents(buf))
    }
    return make_printf(k$0, 0, fmt)
  }
  function sprintf(fmt) { return ksprintf(function (s) { return s }, fmt) }
  var
    Stdlib_Printf =
      [0,
        fprintf,
        printf,
        eprintf,
        sprintf,
        bprintf,
        ifprintf,
        ibprintf,
        kfprintf,
        ikfprintf,
        ksprintf,
        kbprintf,
        ikfprintf,
        ksprintf];
  caml_register_global(808, Stdlib_Printf, "Stdlib__Printf");
  var
    Bad = [248, cst_Stdlib_Arg_Bad, caml_fresh_oo_id(0)],
    Help = [248, cst_Stdlib_Arg_Help, caml_fresh_oo_id(0)],
    Stop = [248, cst_Stdlib_Arg_Stop, caml_fresh_oo_id(0)];
  function assoc3(x, l) {
    var l$0 = l;
    for (; ;) {
      if (!l$0) throw Not_found;
      var match = l$0[1], y2 = match[2], y1 = match[1];
      if (caml_equal(y1, x)) return y2;
      var l$1 = l$0[2], l$0 = l$1
    }
  }
  function split$1(s) {
    var
    i = index$0(s, 61),
    len = caml_ml_string_length(s),
    _qt_ = sub$0(s, i + 1 | 0, len - (i + 1 | 0) | 0);
    return [0, sub$0(s, 0, i), _qt_]
  }
  function make_symlist(prefix, sep, suffix, l) {
    if (!l) return cst_none;
    var t = l[2], h = l[1], _qs_ = cat(prefix, h);
    return cat
      (fold_left$0(function (x, y) { return cat(x, cat(sep, y)) }, _qs_, t),
        suffix)
  }
  function help_action(param) { throw [0, Stop, _a7_] }
  function add_help(speclist) {
    try { assoc3(cst_help$2, speclist); var _qp_ = 0, _qn_ = _qp_ }
    catch (_qr_) {
      _qr_ = caml_wrap_exception(_qr_);
      if (_qr_ !== Not_found) throw _qr_;
      var
        _qn_ =
          [0, [0, cst_help, [0, help_action], cst_Display_this_list_of_optio], 0]
    }
    try { assoc3(cst_help$1, speclist); var _qo_ = 0, add2 = _qo_ }
    catch (_qq_) {
      _qq_ = caml_wrap_exception(_qq_);
      if (_qq_ !== Not_found) throw _qq_;
      var
        add2 =
          [0,
            [0, cst_help$0, [0, help_action], cst_Display_this_list_of_optio$0],
            0]
    }
    return append(speclist, append(_qn_, add2))
  }
  function usage_b(buf, speclist, errmsg) {
    caml_call1(bprintf(buf, _a8_), errmsg);
    var _qk_ = add_help(speclist);
    return iter$2
      (function (param) {
        var
        doc = param[3],
        spec = param[2],
        key = param[1],
        _ql_ = 0 < caml_ml_string_length(doc) ? 1 : 0;
        if (!_ql_) return _ql_;
        if (11 !== spec[0])
          return caml_call2(bprintf(buf, _a5_), key, doc);
        var l = spec[1], _qm_ = make_symlist(cst$53, cst$52, cst$51, l);
        return caml_call3(bprintf(buf, _a6_), key, _qm_, doc)
      },
        _qk_)
  }
  function usage_string(speclist, errmsg) { var b = create$2(200); usage_b(b, speclist, errmsg); return contents(b) }
  function usage(speclist, errmsg) {
    var _qj_ = usage_string(speclist, errmsg);
    return caml_call1(eprintf(_a9_), _qj_)
  }
  var current = [0, 0];
  function bool_of_string_opt$0(x) {
    try { var _qh_ = [0, bool_of_string(x)]; return _qh_ }
    catch (_qi_) {
      _qi_ = caml_wrap_exception(_qi_);
      if (_qi_[1] === Invalid_argument) return 0;
      throw _qi_
    }
  }
  function int_of_string_opt$0(x) {
    try { var _qf_ = [0, caml_int_of_string(x)]; return _qf_ }
    catch (_qg_) {
      _qg_ = caml_wrap_exception(_qg_);
      if (_qg_[1] === Failure) return 0;
      throw _qg_
    }
  }
  function float_of_string_opt(x) {
    try { var _qd_ = [0, caml_float_of_string(x)]; return _qd_ }
    catch (_qe_) {
      _qe_ = caml_wrap_exception(_qe_);
      if (_qe_[1] === Failure) return 0;
      throw _qe_
    }
  }
  function parse_and_expand_argv_dynamic_
    (allow_expand, current, argv, speclist, anonfun, errmsg) {
    var initpos = current[1];
    function convert_error(error) {
      var
      b = create$2(200),
      progname =
        initpos < argv[1].length - 1
          ? caml_check_bound(argv[1], initpos)[1 + initpos]
          : cst$54;
      switch (error[0]) {
        case 0:
          var _qc_ = error[1];
          if
            (caml_string_notequal(_qc_, cst_help$3)
            &&
            caml_string_notequal(_qc_, cst_help$4))
            caml_call2(bprintf(b, _a__), progname, _qc_);
          break;
        case 1:
          var expected = error[3], arg = error[2], opt = error[1];
          caml_call4(bprintf(b, _bb_), progname, arg, opt, expected);
          break;
        case 2: var s = error[1]; caml_call2(bprintf(b, _bc_), progname, s); break;
        default: var s$0 = error[1]; caml_call2(bprintf(b, _bd_), progname, s$0)
      }
      usage_b(b, speclist[1], errmsg);
      if (!caml_equal(error, _a$_) && !caml_equal(error, _ba_))
        return [0, Bad, contents(b)];
      return [0, Help, contents(b)]
    }
    current[1]++;
    for (; ;) {
      if (current[1] >= argv[1].length - 1) return 0;
      try {
        var
        _p5_ = current[1],
        s = caml_check_bound(argv[1], _p5_)[1 + _p5_],
        switch$0 = 0;
        if (1 <= caml_ml_string_length(s) && 45 === caml_string_get(s, 0)) {
          try {
            var
            follow$1 = 0,
            _p7_ = assoc3(s, speclist[1]),
            follow$0 = follow$1,
            action = _p7_
          }
          catch (_qa_) {
            _qa_ = caml_wrap_exception(_qa_);
            if (_qa_ !== Not_found) throw _qa_;
            try {
              var
              match = split$1(s),
              arg = match[2],
              keyword = match[1],
              follow = [0, arg],
              _p6_ = assoc3(keyword, speclist[1])
            }
            catch (_qb_) {
              _qb_ = caml_wrap_exception(_qb_);
              if (_qb_ === Not_found) throw [0, Stop, [0, s]];
              throw _qb_
            }
            var follow$0 = follow, action = _p6_
          }
          var
            no_arg$0 =
              function (s, follow) {
                function no_arg(param) {
                  if (!follow) return 0;
                  var arg = follow[1];
                  throw [0, Stop, [1, s, arg, cst_no_argument]]
                }
                return no_arg
              },
            no_arg = no_arg$0(s, follow$0),
            get_arg$0 =
              function (s, follow) {
                function get_arg(param) {
                  if (follow) { var arg = follow[1]; return arg }
                  if ((current[1] + 1 | 0) >= argv[1].length - 1)
                    throw [0, Stop, [2, s]];
                  var _p$_ = current[1] + 1 | 0;
                  return caml_check_bound(argv[1], _p$_)[1 + _p$_]
                }
                return get_arg
              },
            get_arg = get_arg$0(s, follow$0),
            consume_arg$0 =
              function (follow) {
                function consume_arg(param) { return follow ? 0 : (current[1]++, 0) }
                return consume_arg
              },
            consume_arg = consume_arg$0(follow$0),
            treat_action$0 =
              function (s, no_arg, get_arg, consume_arg) {
                function treat_action(param) {
                  switch (param[0]) {
                    case 0: var f = param[1]; no_arg(0); return caml_call1(f, 0);
                    case 1:
                      var
                        f$0 = param[1],
                        arg = get_arg(0),
                        match = bool_of_string_opt$0(arg);
                      if (!match) throw [0, Stop, [1, s, arg, cst_a_boolean]];
                      var s$0 = match[1];
                      caml_call1(f$0, s$0);
                      return consume_arg(0);
                    case 2: var r = param[1]; no_arg(0); r[1] = 1; return 0;
                    case 3: var r$0 = param[1]; no_arg(0); r$0[1] = 0; return 0;
                    case 4:
                      var f$1 = param[1], arg$0 = get_arg(0);
                      caml_call1(f$1, arg$0);
                      return consume_arg(0);
                    case 5:
                      var r$1 = param[1]; r$1[1] = get_arg(0); return consume_arg(0);
                    case 6:
                      var
                        f$2 = param[1],
                        arg$1 = get_arg(0),
                        match$0 = int_of_string_opt$0(arg$1);
                      if (!match$0) throw [0, Stop, [1, s, arg$1, cst_an_integer]];
                      var x = match$0[1];
                      caml_call1(f$2, x);
                      return consume_arg(0);
                    case 7:
                      var
                        r$2 = param[1],
                        arg$2 = get_arg(0),
                        match$1 = int_of_string_opt$0(arg$2);
                      if (!match$1) throw [0, Stop, [1, s, arg$2, cst_an_integer$0]];
                      var x$0 = match$1[1];
                      r$2[1] = x$0;
                      return consume_arg(0);
                    case 8:
                      var
                        f$3 = param[1],
                        arg$3 = get_arg(0),
                        match$2 = float_of_string_opt(arg$3);
                      if (!match$2) throw [0, Stop, [1, s, arg$3, cst_a_float]];
                      var x$1 = match$2[1];
                      caml_call1(f$3, x$1);
                      return consume_arg(0);
                    case 9:
                      var
                        r$3 = param[1],
                        arg$4 = get_arg(0),
                        match$3 = float_of_string_opt(arg$4);
                      if (!match$3) throw [0, Stop, [1, s, arg$4, cst_a_float$0]];
                      var x$2 = match$3[1];
                      r$3[1] = x$2;
                      return consume_arg(0);
                    case 10:
                      var specs = param[1];
                      no_arg(0);
                      return iter$2(treat_action, specs);
                    case 11:
                      var f$4 = param[2], symb = param[1], arg$5 = get_arg(0);
                      if (!mem(arg$5, symb))
                        throw [0,
                          Stop,
                          [1,
                            s,
                            arg$5,
                            cat(cst_one_of, make_symlist(cst$57, cst$56, cst$55, symb))]];
                      caml_call1(f$4, arg$5);
                      return consume_arg(0);
                    case 12:
                      var f$5 = param[1];
                      no_arg(0);
                      for (; ;) {
                        if (current[1] >= (argv[1].length - 1 - 1 | 0)) return 0;
                        var _p8_ = current[1] + 1 | 0;
                        caml_call1(f$5, caml_check_bound(argv[1], _p8_)[1 + _p8_]);
                        consume_arg(0)
                      }
                    case 13:
                      var f$6 = param[1];
                      no_arg(0);
                      var acc = [0, 0];
                      for (; ;) {
                        if (current[1] >= (argv[1].length - 1 - 1 | 0))
                          return caml_call1(f$6, rev(acc[1]));
                        var _p__ = current[1] + 1 | 0, _p9_ = acc[1];
                        acc[1] = [0, caml_check_bound(argv[1], _p__)[1 + _p__], _p9_];
                        consume_arg(0)
                      }
                    default:
                      var f$7 = param[1];
                      if (1 - allow_expand)
                        throw [0, Invalid_argument, cst_Arg_Expand_is_is_only_allo];
                      var arg$6 = get_arg(0), newarg = caml_call1(f$7, arg$6);
                      consume_arg(0);
                      var
                        before = sub$1(argv[1], 0, current[1] + 1 | 0),
                        after =
                          sub$1
                            (argv[1],
                              current[1] + 1 | 0,
                              (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                      argv[1]
                        =
                        caml_array_concat([0, before, [0, newarg, [0, after, 0]]]);
                      return 0
                  }
                }
                return treat_action
              },
            treat_action = treat_action$0(s, no_arg, get_arg, consume_arg);
          treat_action(action);
          switch$0 = 1
        }
        if (!switch$0) caml_call1(anonfun, s)
      }
      catch (exn) {
        exn = caml_wrap_exception(exn);
        if (exn[1] === Bad) { var m = exn[2]; throw convert_error([3, m]) }
        if (exn[1] !== Stop) throw exn;
        var e = exn[2];
        throw convert_error(e)
      }
      current[1]++
    }
  }
  function parse_and_expand_argv_dynamic
    (current, argv, speclist, anonfun, errmsg) {
    return parse_and_expand_argv_dynamic_
      (1, current, argv, speclist, anonfun, errmsg)
  }
  function parse_argv_dynamic(opt, argv, speclist, anonfun, errmsg) {
    if (opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_and_expand_argv_dynamic_
      (0, current$0, [0, argv], speclist, anonfun, errmsg)
  }
  function parse_argv(opt, argv, speclist, anonfun, errmsg) {
    if (opt) var sth = opt[1], current$0 = sth; else var current$0 = current;
    return parse_argv_dynamic
      ([0, current$0], argv, [0, speclist], anonfun, errmsg)
  }
  function parse(l, f, msg) {
    try { var _p4_ = parse_argv(0, caml_sys_argv(0), l, f, msg); return _p4_ }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (exn[1] === Bad) { var msg$0 = exn[2]; caml_call1(eprintf(_be_), msg$0); return exit(2) }
      if (exn[1] !== Help) throw exn;
      var msg$1 = exn[2];
      caml_call1(printf(_bf_), msg$1);
      return exit(0)
    }
  }
  function parse_dynamic(l, f, msg) {
    try { var _p3_ = parse_argv_dynamic(0, caml_sys_argv(0), l, f, msg); return _p3_ }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (exn[1] === Bad) { var msg$0 = exn[2]; caml_call1(eprintf(_bg_), msg$0); return exit(2) }
      if (exn[1] !== Help) throw exn;
      var msg$1 = exn[2];
      caml_call1(printf(_bh_), msg$1);
      return exit(0)
    }
  }
  function parse_expand(l, f, msg) {
    try {
      var
      argv = [0, caml_sys_argv(0)],
      spec = [0, l],
      current$0 = [0, current[1]],
      _p2_ = parse_and_expand_argv_dynamic(current$0, argv, spec, f, msg);
      return _p2_
    }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (exn[1] === Bad) { var msg$0 = exn[2]; caml_call1(eprintf(_bi_), msg$0); return exit(2) }
      if (exn[1] !== Help) throw exn;
      var msg$1 = exn[2];
      caml_call1(printf(_bj_), msg$1);
      return exit(0)
    }
  }
  function second_word(s) {
    var len = caml_ml_string_length(s);
    function loop(n) {
      var n$0 = n;
      for (; ;) {
        if (len <= n$0) return len;
        if (32 !== caml_string_get(s, n$0)) return n$0;
        var n$1 = n$0 + 1 | 0, n$0 = n$1
      }
    }
    try { var n$0 = index$0(s, 9) }
    catch (_p0_) {
      _p0_ = caml_wrap_exception(_p0_);
      if (_p0_ !== Not_found) throw _p0_;
      try { var n = index$0(s, 32) }
      catch (_p1_) {
        _p1_ = caml_wrap_exception(_p1_);
        if (_p1_ === Not_found) return len;
        throw _p1_
      }
      return loop(n + 1 | 0)
    }
    return loop(n$0 + 1 | 0)
  }
  function max_arg_len(cur, param) {
    var doc = param[3], spec = param[2], kwd = param[1];
    return 11 === spec[0]
      ? max$1(cur, caml_ml_string_length(kwd))
      : max$1(cur, caml_ml_string_length(kwd) + second_word(doc) | 0)
  }
  function replace_leading_tab(s) {
    var seen = [0, 0];
    return map$6
      (function (c) { if (9 === c && !seen[1]) { seen[1] = 1; return 32 } return c },
        s)
  }
  function align(opt, speclist) {
    if (opt) var sth = opt[1], limit = sth; else var limit = max_int;
    var
      completed = add_help(speclist),
      len = fold_left$0(max_arg_len, 0, completed),
      len$0 = min$1(len, limit);
    return map$4
      (function (ksd) {
        var _pY_ = ksd[1], _pZ_ = ksd[2];
        if (!caml_string_notequal(ksd[3], cst$58)) return ksd;
        if (11 === _pZ_[0]) {
          var
          msg$0 = ksd[3],
          cutcol$0 = second_word(msg$0),
          spaces$0 = make$1(max$1(0, len$0 - cutcol$0 | 0) + 3 | 0, 32);
          return [0,
            _pY_,
            _pZ_,
            cat(cst$59, cat(spaces$0, replace_leading_tab(msg$0)))]
        }
        var
          msg = ksd[3],
          spec = ksd[2],
          cutcol = second_word(msg),
          kwd_len = caml_ml_string_length(_pY_),
          diff = (len$0 - kwd_len | 0) - cutcol | 0;
        if (0 >= diff) return [0, _pY_, spec, replace_leading_tab(msg)];
        var
          spaces = make$1(diff, 32),
          prefix = sub$0(replace_leading_tab(msg), 0, cutcol),
          suffix =
            sub$0(msg, cutcol, caml_ml_string_length(msg) - cutcol | 0);
        return [0, _pY_, spec, cat(prefix, cat(spaces, suffix))]
      },
        completed)
  }
  function read_aux(trim, sep, file) {
    var ic = open_bin$0(file), buf = create$2(200), words = [0, 0];
    function stash(param) {
      var s = contents(buf);
      if (trim) {
        var len = caml_ml_string_length(s), switch$0 = 0;
        if (0 < len && 13 === caml_string_get(s, len - 1 | 0)) { var _pX_ = sub$0(s, 0, len - 1 | 0); switch$0 = 1 }
        if (!switch$0) var _pX_ = s;
        var word = _pX_
      }
      else
        var word = s;
      words[1] = [0, word, words[1]];
      return clear$1(buf)
    }
    try {
      for (; ;) {
        var c = caml_ml_input_char(ic);
        if (c === sep) stash(0); else add_char(buf, c)
      }
    }
    catch (_pW_) {
      _pW_ = caml_wrap_exception(_pW_);
      if (_pW_ !== End_of_file) throw _pW_;
      if (0 < buf[2]) stash(0);
      caml_ml_close_channel(ic);
      return of_list(rev(words[1]))
    }
  }
  var _bk_ = 10, _bl_ = 1;
  function read_arg(_pV_) { return read_aux(_bl_, _bk_, _pV_) }
  var _bm_ = 0, _bn_ = 0;
  function read_arg0(_pU_) { return read_aux(_bn_, _bm_, _pU_) }
  function write_aux(sep, file, args) {
    var oc = open_bin(file);
    iter$5(function (s) { return caml_call2(fprintf(oc, _bo_), s, sep) }, args);
    return close(oc)
  }
  var _bp_ = 10;
  function write_arg(_pS_, _pT_) { return write_aux(_bp_, _pS_, _pT_) }
  var _bq_ = 0;
  function write_arg0(_pQ_, _pR_) { return write_aux(_bq_, _pQ_, _pR_) }
  var
    Stdlib_Arg =
      [0,
        parse,
        parse_dynamic,
        parse_argv,
        parse_argv_dynamic,
        parse_and_expand_argv_dynamic,
        parse_expand,
        Help,
        Bad,
        usage,
        usage_string,
        align,
        current,
        read_arg,
        read_arg0,
        write_arg,
        write_arg0];
  caml_register_global(809, Stdlib_Arg, "Stdlib__Arg");
  var
    Stdlib_Atomic =
      [0, make, get, set, exchange, compare_and_set, fetch_and_add, incr, decr];
  caml_register_global(810, Stdlib_Atomic, "Stdlib__Atomic");
  var printers = [0, 0];
  function field(x, i) {
    var f = x[1 + i];
    return is_block(f)
      ? caml_obj_tag(f) === 252
        ? caml_call1(sprintf(_br_), f)
        : caml_obj_tag(f) === 253 ? to_string(f) : cst$60
      : caml_call1(sprintf(_bs_), f)
  }
  function other_fields(x, i) {
    if (x.length - 1 <= i) return cst$61;
    var _pO_ = other_fields(x, i + 1 | 0), _pP_ = field(x, i);
    return caml_call2(sprintf(_bt_), _pP_, _pO_)
  }
  function use_printers(x) {
    function conv(param) {
      var param$0 = param;
      for (; ;) {
        if (!param$0) return 0;
        var tl = param$0[2], hd = param$0[1];
        try { var switch$0 = 0, val = caml_call1(hd, x); switch$0 = 1 } catch (_pN_) { }
        if (switch$0 && val) { var s = val[1]; return [0, s] }
        var param$0 = tl
      }
    }
    return conv(printers[1])
  }
  function to_string_default(x) {
    if (x === Out_of_memory) return cst_Out_of_memory;
    if (x === Stack_overflow) return cst_Stack_overflow;
    if (x[1] === Match_failure) {
      var match$0 = x[2], char$0 = match$0[3], line = match$0[2], file = match$0[1];
      return caml_call5
        (sprintf(locfmt),
          file,
          line,
          char$0,
          char$0 + 5 | 0,
          cst_Pattern_matching_failed)
    }
    if (x[1] === Assert_failure) {
      var
      match$1 = x[2],
      char$1 = match$1[3],
      line$0 = match$1[2],
      file$0 = match$1[1];
      return caml_call5
        (sprintf(locfmt),
          file$0,
          line$0,
          char$1,
          char$1 + 6 | 0,
          cst_Assertion_failed)
    }
    if (x[1] === Undefined_recursive_module) {
      var
      match$2 = x[2],
      char$2 = match$2[3],
      line$1 = match$2[2],
      file$1 = match$2[1];
      return caml_call5
        (sprintf(locfmt),
          file$1,
          line$1,
          char$2,
          char$2 + 6 | 0,
          cst_Undefined_recursive_module)
    }
    if (0 !== caml_obj_tag(x)) return x[1];
    var constructor = x[1][1], match = x.length - 1;
    if (2 < match >>> 0)
      var
        _pJ_ = other_fields(x, 2),
        _pK_ = field(x, 1),
        _pM_ = caml_call2(sprintf(_bu_), _pK_, _pJ_);
    else
      switch (match) {
        case 0: var _pM_ = cst$62; break;
        case 1: var _pM_ = cst$63; break;
        default: var _pL_ = field(x, 1), _pM_ = caml_call1(sprintf(_bv_), _pL_)
      }
    return cat(constructor, _pM_)
  }
  function to_string$6(e) {
    var match = use_printers(e);
    if (!match) return to_string_default(e);
    var s = match[1];
    return s
  }
  function print(fct, arg) {
    try { var _pI_ = caml_call1(fct, arg); return _pI_ }
    catch (x) {
      x = caml_wrap_exception(x);
      var _pH_ = to_string$6(x);
      caml_call1(eprintf(_bw_), _pH_);
      caml_ml_flush(stderr);
      throw x
    }
  }
  function catch$0(fct, arg) {
    try { var _pG_ = caml_call1(fct, arg); return _pG_ }
    catch (x) {
      x = caml_wrap_exception(x);
      caml_ml_flush(stdout);
      var _pF_ = to_string$6(x);
      caml_call1(eprintf(_bx_), _pF_);
      return exit(2)
    }
  }
  function raw_backtrace_entries(bt) { return bt }
  function convert_raw_backtrace(bt) { return [0, runtime.caml_convert_raw_backtrace(bt)] }
  function format_backtrace_slot(pos, slot) {
    function info(is_raise) {
      return is_raise
        ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
        : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from
    }
    if (0 === slot[0]) {
      var
      _px_ = slot[5],
      _py_ = slot[4],
      _pz_ = slot[3],
      _pA_ = slot[6] ? cst_inlined : cst$64,
      _pB_ = slot[2],
      _pC_ = slot[7],
      _pD_ = info(slot[1]);
      return [0,
        caml_call7(sprintf(_by_), _pD_, _pC_, _pB_, _pA_, _pz_, _py_, _px_)]
    }
    if (slot[1]) return 0;
    var _pE_ = info(0);
    return [0, caml_call1(sprintf(_bz_), _pE_)]
  }
  function print_raw_backtrace(outchan, raw_backtrace) {
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if (!backtrace) return fprintf(outchan, _bB_);
    var a = backtrace[1], _pv_ = a.length - 1 - 1 | 0, _pu_ = 0;
    if (_pv_ >= 0) {
      var i = _pu_;
      for (; ;) {
        var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
        if (match) { var str = match[1]; caml_call1(fprintf(outchan, _bA_), str) }
        var _pw_ = i + 1 | 0;
        if (_pv_ !== i) { var i = _pw_; continue }
        break
      }
    }
    return 0
  }
  function print_backtrace(outchan) { return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0)) }
  function raw_backtrace_to_string(raw_backtrace) {
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if (!backtrace) return cst_Program_not_linked_with_g_;
    var a = backtrace[1], b = create$2(1024), _ps_ = a.length - 1 - 1 | 0, _pr_ = 0;
    if (_ps_ >= 0) {
      var i = _pr_;
      for (; ;) {
        var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
        if (match) { var str = match[1]; caml_call1(bprintf(b, _bC_), str) }
        var _pt_ = i + 1 | 0;
        if (_ps_ !== i) { var i = _pt_; continue }
        break
      }
    }
    return contents(b)
  }
  function backtrace_slot_is_raise(param) { return 0 === param[0] ? param[1] : param[1] }
  function backtrace_slot_is_inline(param) { return 0 === param[0] ? param[6] : 0 }
  function backtrace_slot_location(param) { return 0 === param[0] ? [0, [0, param[2], param[3], param[4], param[5]]] : 0 }
  function backtrace_slot_defname(param) {
    if (0 === param[0] && caml_string_notequal(param[7], cst$65))
      return [0, param[7]];
    return 0
  }
  function backtrace_slots(raw_backtrace) {
    var match = convert_raw_backtrace(raw_backtrace);
    if (!match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 1 - 1 | 0, i = i$1;
    for (; ;) {
      if (-1 === i)
        var _pq_ = 0;
      else {
        var
        param = caml_check_bound(backtrace, i)[1 + i],
        _pp_ = 0 === param[0] ? 1 : 0;
        if (!_pp_) { var i$0 = i - 1 | 0, i = i$0; continue }
        var _pq_ = _pp_
      }
      return _pq_ ? [0, backtrace] : 0
    }
  }
  function backtrace_slots_of_raw_entry(entry) { return backtrace_slots([0, entry]) }
  function raw_backtrace_length(bt) { return bt.length - 1 }
  function get_backtrace(param) { return raw_backtrace_to_string(caml_get_exception_raw_backtra(0)) }
  function register_printer(fn) {
    for (; ;) {
      var
      old_printers = printers[1],
      new_printers = [0, fn, old_printers],
      success = compare_and_set(printers, old_printers, new_printers),
      _po_ = 1 - success;
      if (_po_) continue;
      return _po_
    }
  }
  function exn_slot(x) { return 0 === caml_obj_tag(x) ? x[1] : x }
  function exn_slot_id(x) { var slot = exn_slot(x); return slot[2] }
  function exn_slot_name(x) { var slot = exn_slot(x); return slot[1] }
  var errors = _bD_.slice();
  function default_uncaught_exception_han(exn, raw_backtrace) {
    var _pm_ = to_string$6(exn);
    caml_call1(eprintf(_bE_), _pm_);
    print_raw_backtrace(stderr, raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if (status < 0) {
      var _pn_ = abs(status);
      prerr_endline(caml_check_bound(errors, _pn_)[1 + _pn_])
    }
    return caml_ml_flush(stderr)
  }
  var uncaught_exception_handler = [0, default_uncaught_exception_han];
  function set_uncaught_exception_handler(fn) { uncaught_exception_handler[1] = fn; return 0 }
  var empty_backtrace = [0];
  function handle_uncaught_exception(exn, debugger_in_use) {
    try {
      try {
        var
        raw_backtrace =
          debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
        try { do_at_exit(0) } catch (_pl_) { }
        try {
          var
          _ph_ = caml_call2(uncaught_exception_handler[1], exn, raw_backtrace),
          _pg_ = _ph_
        }
        catch (exn$0) {
          exn$0 = caml_wrap_exception(exn$0);
          var
            raw_backtrace$0 = caml_get_exception_raw_backtra(0),
            _pe_ = to_string$6(exn);
          caml_call1(eprintf(_bF_), _pe_);
          print_raw_backtrace(stderr, raw_backtrace);
          var _pf_ = to_string$6(exn$0);
          caml_call1(eprintf(_bG_), _pf_);
          print_raw_backtrace(stderr, raw_backtrace$0);
          var _pg_ = caml_ml_flush(stderr)
        }
        var _pi_ = _pg_
      }
      catch (_pk_) {
        _pk_ = caml_wrap_exception(_pk_);
        if (_pk_ !== Out_of_memory) throw _pk_;
        var _pi_ = prerr_endline(cst_Fatal_error_out_of_memory_)
      }
      return _pi_
    }
    catch (_pj_) { return 0 }
  }
  caml_register_named_value
    (caml_string_of_jsbytes("Printexc.handle_uncaught_exception"),
      handle_uncaught_exception);
  function _bH_(_pd_) { return runtime.caml_raw_backtrace_next_slot(_pd_) }
  function _bI_(_pc_) { return runtime.caml_convert_raw_backtrace_slot(_pc_) }
  function _bJ_(_pb_, _pa_) { return runtime.caml_raw_backtrace_slot(_pb_, _pa_) }
  var
    _bK_ =
      [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot];
  function _bL_(_o$_) { return caml_get_exception_raw_backtra(_o$_) }
  function _bM_(_o__) { return runtime.caml_backtrace_status(_o__) }
  var
    Stdlib_Printexc =
      [0,
        to_string$6,
        to_string_default,
        print,
        catch$0,
        print_backtrace,
        get_backtrace,
        function (_o9_) { return runtime.caml_record_backtrace(_o9_) },
        _bM_,
        register_printer,
        use_printers,
        raw_backtrace_entries,
        _bL_,
        print_raw_backtrace,
        raw_backtrace_to_string,
        default_uncaught_exception_han,
        set_uncaught_exception_handler,
        backtrace_slots,
        backtrace_slots_of_raw_entry,
        _bK_,
        raw_backtrace_length,
        _bJ_,
        _bI_,
        _bH_,
        exn_slot_id,
        exn_slot_name];
  caml_register_global(811, Stdlib_Printexc, "Stdlib__Printexc");
  function const$0(c, param) { return c }
  function flip(f, x, y) { return caml_call2(f, y, x) }
  function negate(p, v) { return 1 - caml_call1(p, v) }
  var
    Finally_raised =
      [248, cst_Stdlib_Fun_Finally_raised, caml_fresh_oo_id(0)];
  register_printer
    (function (param) {
      if (param[1] !== Finally_raised) return 0;
      var exn = param[2];
      return [0, cat(cst_Fun_Finally_raised, to_string$6(exn))]
    });
  function protect(finally$0, work) {
    function finally_no_exn(param) {
      try { var _o8_ = caml_call1(finally$0, 0); return _o8_ }
      catch (e) {
        e = caml_wrap_exception(e);
        var bt = caml_get_exception_raw_backtra(0), exn = [0, Finally_raised, e];
        caml_restore_raw_backtrace(exn, bt);
        throw exn
      }
    }
    try { var result = caml_call1(work, 0) }
    catch (work_exn) {
      work_exn = caml_wrap_exception(work_exn);
      var work_bt = caml_get_exception_raw_backtra(0);
      finally_no_exn(0);
      caml_restore_raw_backtrace(work_exn, work_bt);
      throw work_exn
    }
    finally_no_exn(0);
    return result
  }
  var Stdlib_Fun = [0, const$0, flip, negate, protect, Finally_raised];
  caml_register_global(812, Stdlib_Fun, "Stdlib__Fun");
  function print_stat(c) {
    var st = runtime.caml_gc_stat(0), _oQ_ = st[4];
    caml_call1(fprintf(c, _bN_), _oQ_);
    var _oR_ = st[5];
    caml_call1(fprintf(c, _bO_), _oR_);
    var _oS_ = st[14];
    caml_call1(fprintf(c, _bP_), _oS_);
    var _oT_ = st[17];
    caml_call1(fprintf(c, _bQ_), _oT_);
    fprintf(c, _bR_);
    var
      _oU_ = st[1],
      l1 = caml_ml_string_length(caml_call1(sprintf(_bS_), _oU_)),
      _oV_ = st[1];
    caml_call2(fprintf(c, _bT_), l1, _oV_);
    var _oW_ = st[2];
    caml_call2(fprintf(c, _bU_), l1, _oW_);
    var _oX_ = st[3];
    caml_call2(fprintf(c, _bV_), l1, _oX_);
    fprintf(c, _bW_);
    var
      _oY_ = st[15],
      l2 = caml_ml_string_length(caml_call1(sprintf(_bX_), _oY_)),
      _oZ_ = st[15];
    caml_call2(fprintf(c, _bY_), l2, _oZ_);
    var _o0_ = st[6];
    caml_call2(fprintf(c, _bZ_), l2, _o0_);
    var _o1_ = st[8];
    caml_call2(fprintf(c, _b0_), l2, _o1_);
    var _o2_ = st[10];
    caml_call2(fprintf(c, _b1_), l2, _o2_);
    var _o3_ = st[12];
    caml_call2(fprintf(c, _b2_), l2, _o3_);
    var _o4_ = st[13];
    caml_call2(fprintf(c, _b3_), l2, _o4_);
    fprintf(c, _b4_);
    var _o5_ = st[9];
    caml_call1(fprintf(c, _b5_), _o5_);
    var _o6_ = st[11];
    caml_call1(fprintf(c, _b6_), _o6_);
    var _o7_ = st[7];
    return caml_call1(fprintf(c, _b7_), _o7_)
  }
  function allocated_bytes(param) {
    var
    match = runtime.caml_gc_counters(0),
    ma = match[3],
    pro = match[2],
    mi = match[1];
    return (mi + ma - pro) * 4
  }
  function create_alarm(f) { return [0, 1] }
  function delete_alarm(a) { a[1] = 0; return 0 }
  function _b8_(param) { return 0 }
  function _b9_(param) { return 0 }
  function _b__(param) { return 0 }
  function _b$_(param) { return 0 }
  var null_tracker = [0, function (param) { return 0 }, _b$_, _b__, _b9_, _b8_];
  function start(sampling_rate, opt, tracker) {
    if (opt)
      var sth = opt[1], callstack_size = sth;
    else
      var callstack_size = max_int;
    return runtime.caml_memprof_start(sampling_rate, callstack_size, tracker)
  }
  var _ca_ = [0, null_tracker, start, runtime.caml_memprof_stop];
  function _cb_(_oP_) { return runtime.caml_final_release(_oP_) }
  var
    _cc_ = runtime.caml_final_register_called_without_value,
    Stdlib_Gc =
      [0,
        print_stat,
        allocated_bytes,
        function (_oO_, _oN_) { return runtime.caml_final_register(_oO_, _oN_) },
        _cc_,
        _cb_,
        create_alarm,
        delete_alarm,
        _ca_];
  caml_register_global(813, Stdlib_Gc, "Stdlib__Gc");
  function string(str) { return caml_md5_string(str, 0, caml_ml_string_length(str)) }
  function bytes(b) { return string(caml_string_of_bytes(b)) }
  function substring(str, ofs, len) {
    if
      (0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
      return caml_md5_string(str, ofs, len);
    return invalid_arg(cst_Digest_substring)
  }
  function subbytes(b, ofs, len) { return substring(caml_string_of_bytes(b), ofs, len) }
  function file(filename) {
    var ic = open_bin$0(filename);
    try { var d = runtime.caml_md5_chan(ic, -1) }
    catch (e) { e = caml_wrap_exception(e); caml_ml_close_channel(ic); throw e }
    caml_ml_close_channel(ic);
    return d
  }
  function output$0(chan, digest) { return output_string(chan, digest) }
  function input$0(chan) { return really_input_string(chan, 16) }
  function char_hex(n) { var _oM_ = 10 <= n ? 87 : 48; return n + _oM_ | 0 }
  function to_hex(d) {
    if (16 !== caml_ml_string_length(d)) invalid_arg(cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for (; ;) {
      var x = caml_string_get(d, i);
      caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
      caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
      var _oL_ = i + 1 | 0;
      if (15 === i) return caml_string_of_bytes(result);
      var i = _oL_
    }
  }
  function from_hex(s) {
    if (32 !== caml_ml_string_length(s)) invalid_arg(cst_Digest_from_hex);
    function digit(c) {
      if (65 <= c) {
        if (97 <= c) { if (103 > c) return (c - 97 | 0) + 10 | 0 }
        else
          if (71 > c) return (c - 65 | 0) + 10 | 0
      }
      else
        if (9 >= c - 48 >>> 0) return c - 48 | 0;
      throw [0, Invalid_argument, cst_Digest_from_hex$0]
    }
    var result = caml_create_bytes(16), i = 0;
    for (; ;) {
      var i$0 = 2 * i | 0, _oJ_ = digit(caml_string_get(s, i$0 + 1 | 0));
      caml_bytes_set
        (result, i, chr((digit(caml_string_get(s, i$0)) << 4) + _oJ_ | 0));
      var _oK_ = i + 1 | 0;
      if (15 === i) return caml_string_of_bytes(result);
      var i = _oK_
    }
  }
  var
    Stdlib_Digest =
      [0,
        compare$9,
        equal$9,
        string,
        bytes,
        substring,
        subbytes,
        file,
        output$0,
        input$0,
        to_hex,
        from_hex];
  caml_register_global(814, Stdlib_Digest, "Stdlib__Digest");
  function new_state(param) { return [0, caml_make_vect(55, 0), 0] }
  function assign(st1, st2) { blit$1(st2[1], 0, st1[1], 0, 55); st1[2] = st2[2]; return 0 }
  function full_init(s, seed) {
    var seed$0 = 0 === seed.length - 1 ? [0, 0] : seed, l = seed$0.length - 1, i$0 = 0;
    for (; ;) {
      caml_check_bound(s[1], i$0)[1 + i$0] = i$0;
      var _oI_ = i$0 + 1 | 0;
      if (54 !== i$0) { var i$0 = _oI_; continue }
      var accu = [0, cst_x$1], _oE_ = 54 + max$1(55, l) | 0, _oD_ = 0;
      if (_oE_ >= 0) {
        var i = _oD_;
        for (; ;) {
          var
          j = i % 55 | 0,
          k = caml_mod(i, l),
          x = caml_check_bound(seed$0, k)[1 + k];
          accu[1] = string(cat(accu[1], caml_string_of_jsbytes("" + x)));
          var
            _oF_ = accu[1],
            _oz_ = caml_string_get(_oF_, 3) << 24,
            _oA_ = caml_string_get(_oF_, 2) << 16,
            _oB_ = caml_string_get(_oF_, 1) << 8,
            _oC_ = ((caml_string_get(_oF_, 0) + _oB_ | 0) + _oA_ | 0) + _oz_ | 0,
            _oG_ = (caml_check_bound(s[1], j)[1 + j] ^ _oC_) & 1073741823;
          caml_check_bound(s[1], j)[1 + j] = _oG_;
          var _oH_ = i + 1 | 0;
          if (_oE_ !== i) { var i = _oH_; continue }
          break
        }
      }
      s[2] = 0;
      return 0
    }
  }
  function make$3(seed) { var result = new_state(0); full_init(result, seed); return result }
  function make_self_init(param) { return make$3(caml_sys_random_seed(0)) }
  function copy$5(s) { var result = new_state(0); assign(result, s); return result }
  function bits(s) {
    s[2] = (s[2] + 1 | 0) % 55 | 0;
    var
      _ow_ = s[2],
      curval = caml_check_bound(s[1], _ow_)[1 + _ow_],
      _ox_ = (s[2] + 24 | 0) % 55 | 0,
      newval =
        caml_check_bound(s[1], _ox_)[1 + _ox_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
      newval30 = newval & 1073741823,
      _oy_ = s[2];
    caml_check_bound(s[1], _oy_)[1 + _oy_] = newval30;
    return newval30
  }
  function intaux(s, n) {
    for (; ;) {
      var r = bits(s), v = caml_mod(r, n);
      if (((1073741823 - n | 0) + 1 | 0) < (r - v | 0)) continue;
      return v
    }
  }
  function int$0(s, bound) {
    if (1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return invalid_arg(cst_Random_int)
  }
  function full_int(s, bound) {
    if (0 >= bound) return invalid_arg(cst_Random_full_int);
    if (1073741823 >= bound) return intaux(s, bound);
    for (; ;) {
      var b1 = bits(s), b2 = bits(s);
      if (bound <= 2147483647)
        var bpos = (b2 & 1073725440) << 1 | b1 >>> 15 | 0, r = bpos;
      else
        var
          b3 = bits(s),
          r$0 = ((b3 & 1073741312) << 12 | b2 >>> 9 | 0) << 20 | b1 >>> 10 | 0,
          r = r$0;
      var v = caml_mod(r, bound);
      if (((2147483647 - bound | 0) + 1 | 0) < (r - v | 0)) continue;
      return v
    }
  }
  function int32(s, bound) {
    if (caml_lessequal(bound, 0)) return invalid_arg(cst_Random_int32);
    for (; ;) {
      var b1 = bits(s), b2 = (bits(s) & 1) << 30, r = b1 | b2, v = caml_mod(r, bound);
      if (caml_greaterthan(r - v | 0, (2147483647 - bound | 0) + 1 | 0))
        continue;
      return v
    }
  }
  function int64(s, bound) {
    if (caml_lessequal(bound, _ce_)) return invalid_arg(cst_Random_int64);
    for (; ;) {
      var
      b1 = caml_int64_of_int32(bits(s)),
      b2 = caml_int64_shift_left(caml_int64_of_int32(bits(s)), 30),
      b3 = caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7), 60),
      r = caml_int64_or(b1, caml_int64_or(b2, b3)),
      v = runtime.caml_int64_mod(r, bound);
      if
        (caml_greaterthan
          (caml_int64_sub(r, v),
            caml_int64_add(caml_int64_sub(max_int$2, bound), _cd_)))
        continue;
      return v
    }
  }
  function nativeint(s, bound) { return int32(s, bound) }
  function float$0(s, bound) {
    var r1 = bits(s), r2 = bits(s);
    return (r1 / 1073741824. + r2) / 1073741824. * bound
  }
  function bool(s) { return 0 === (bits(s) & 1) ? 1 : 0 }
  function bits32(s) { var b1 = bits(s) >>> 14 | 0, b2 = bits(s) >>> 14 | 0; return b1 | b2 << 16 }
  function bits64(s) {
    var
    b1 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
    b2 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
    b3 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 8);
    return caml_int64_or
      (b1,
        caml_int64_or
          (caml_int64_shift_left(b2, 21), caml_int64_shift_left(b3, 42)))
  }
  function nativebits(s) { return bits32(s) }
  var default$0 = [0, _cf_.slice(), 0];
  function bits$0(param) { return bits(default$0) }
  function int$1(bound) { return int$0(default$0, bound) }
  function full_int$0(bound) { return full_int(default$0, bound) }
  function int32$0(bound) { return int32(default$0, bound) }
  function nativeint$0(bound) { return nativeint(default$0, bound) }
  function int64$0(bound) { return int64(default$0, bound) }
  function float$1(scale) { return float$0(default$0, scale) }
  function bool$0(param) { return bool(default$0) }
  function bits32$0(param) { return bits32(default$0) }
  function bits64$0(param) { return bits64(default$0) }
  function nativebits$0(param) { return nativebits(default$0) }
  function full_init$0(seed) { return full_init(default$0, seed) }
  function init$5(seed) { return full_init(default$0, [0, seed]) }
  function self_init(param) { return full_init$0(caml_sys_random_seed(0)) }
  function get_state(param) { return copy$5(default$0) }
  function set_state(s) { return assign(default$0, s) }
  var
    _cg_ =
      [0,
        make$3,
        make_self_init,
        copy$5,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits],
    Stdlib_Random =
      [0,
        init$5,
        full_init$0,
        self_init,
        bits$0,
        int$1,
        full_int$0,
        int32$0,
        nativeint$0,
        int64$0,
        float$1,
        bool$0,
        bits32$0,
        bits64$0,
        nativebits$0,
        _cg_,
        get_state,
        set_state];
  caml_register_global(815, Stdlib_Random, "Stdlib__Random");
  function ongoing_traversal(h) { var _ou_ = h.length - 1 < 4 ? 1 : 0, _ov_ = _ou_ || (h[4] < 0 ? 1 : 0); return _ov_ }
  function flip_ongoing_traversal(h) { h[4] = - h[4] | 0; return 0 }
  try { var _c3_ = caml_sys_getenv(cst_OCAMLRUNPARAM), params = _c3_ }
  catch (_os_) {
    _os_ = caml_wrap_exception(_os_);
    if (_os_ !== Not_found) throw _os_;
    try { var _c2_ = caml_sys_getenv(cst_CAMLRUNPARAM), _ch_ = _c2_ }
    catch (_ot_) {
      _ot_ = caml_wrap_exception(_ot_);
      if (_ot_ !== Not_found) throw _ot_;
      var _ch_ = cst$66
    }
    var params = _ch_
  }
  var
    randomized_default = contains$0(params, 82),
    randomized = [0, randomized_default];
  function randomize(param) { randomized[1] = 1; return 0 }
  function is_randomized(param) { return randomized[1] }
  var prng = [246, function (_or_) { return caml_call1(_cg_[2], 0) }];
  function power_2_above(x, n) {
    var x$0 = x;
    for (; ;) {
      if (n <= x$0) return x$0;
      if (max_array_length < (x$0 * 2 | 0)) return x$0;
      var x$1 = x$0 * 2 | 0, x$0 = x$1
    }
  }
  function create$3(opt, initial_size) {
    if (opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, initial_size);
    if (random)
      var
        _op_ = caml_obj_tag(prng),
        _oq_ = 250 === _op_ ? prng[1] : 246 === _op_ ? force_lazy_block(prng) : prng,
        seed = caml_call1(_cg_[4], _oq_);
    else
      var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s]
  }
  function clear$2(h) {
    var _oo_ = 0 < h[1] ? 1 : 0;
    return _oo_ ? (h[1] = 0, fill$0(h[2], 0, h[2].length - 1, 0)) : _oo_
  }
  function reset$0(h) {
    var len = h[2].length - 1;
    if (4 <= h.length - 1 && len !== abs(h[4])) { h[1] = 0; h[2] = caml_make_vect(abs(h[4]), 0); return 0 }
    return clear$2(h)
  }
  function copy_bucketlist(param) {
    if (!param) return 0;
    var
      key = param[1],
      data = param[2],
      next = param[3],
      prec$0 = [0, key, data, next],
      prec = prec$0,
      param$0 = next;
    for (; ;) {
      if (!param$0) return prec$0;
      var
        key$0 = param$0[1],
        data$0 = param$0[2],
        next$0 = param$0[3],
        r = [0, key$0, data$0, next$0];
      prec[3] = r;
      var prec = r, param$0 = next$0
    }
  }
  function copy$6(init) {
    var _ol_ = init[4], _om_ = init[3], _on_ = map$7(copy_bucketlist, init[2]);
    return [0, init[1], _on_, _om_, _ol_]
  }
  function length$5(h) { return h[1] }
  function insert_all_buckets(indexfun, inplace, odata, ndata) {
    var
    nsize = ndata.length - 1,
    ndata_tail = caml_make_vect(nsize, 0),
    _of_ = odata.length - 1 - 1 | 0,
    _oe_ = 0;
    if (_of_ >= 0) {
      var i$0 = _oe_;
      a:
      for (; ;) {
        var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
        for (; ;) {
          if (cell) {
            var
            key = cell[1],
            data = cell[2],
            next = cell[3],
            cell$0 = inplace ? cell : [0, key, data, 0],
            nidx = caml_call1(indexfun, key),
            match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
            if (match)
              match[3] = cell$0;
            else
              caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
            caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
            var cell = next;
            continue
          }
          var _ok_ = i$0 + 1 | 0;
          if (_of_ !== i$0) { var i$0 = _ok_; continue a }
          break
        }
        break
      }
    }
    if (inplace) {
      var _oh_ = nsize - 1 | 0, _og_ = 0;
      if (_oh_ >= 0) {
        var i = _og_;
        for (; ;) {
          var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
          if (match$0) match$0[3] = 0;
          var _oj_ = i + 1 | 0;
          if (_oh_ !== i) { var i = _oj_; continue }
          break
        }
      }
      var _oi_ = 0
    }
    else
      var _oi_ = inplace;
    return _oi_
  }
  function resize$0(indexfun, h) {
    var
    odata = h[2],
    osize = odata.length - 1,
    nsize = osize * 2 | 0,
    _od_ = nsize < max_array_length ? 1 : 0;
    if (!_od_) return _od_;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata)
  }
  function iter$10(f, h) {
    function do_bucket(param) {
      var param$0 = param;
      for (; ;) {
        if (!param$0) return 0;
        var key = param$0[1], data = param$0[2], next = param$0[3];
        caml_call2(f, key, data);
        var param$0 = next
      }
    }
    var old_trav = ongoing_traversal(h);
    if (1 - old_trav) flip_ongoing_traversal(h);
    try {
      var d = h[2], _n$_ = d.length - 1 - 1 | 0, _n__ = 0;
      if (_n$_ >= 0) {
        var i = _n__;
        for (; ;) {
          do_bucket(caml_check_bound(d, i)[1 + i]);
          var _oc_ = i + 1 | 0;
          if (_n$_ !== i) { var i = _oc_; continue }
          break
        }
      }
      var _oa_ = 1 - old_trav, _ob_ = _oa_ ? flip_ongoing_traversal(h) : _oa_;
      return _ob_
    }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (old_trav) throw exn;
      flip_ongoing_traversal(h);
      throw exn
    }
  }
  function filter_map_inplace_bucket(f, h, i, prec, slot) {
    var prec$0 = prec, slot$0 = slot;
    for (; ;) {
      if (!slot$0)
        return prec$0
          ? (prec$0[3] = 0, 0)
          : (caml_check_bound(h[2], i)[1 + i] = 0, 0);
      var
        key = slot$0[1],
        data = slot$0[2],
        next = slot$0[3],
        match = caml_call2(f, key, data);
      if (!match) { h[1] = h[1] - 1 | 0; var slot$0 = next; continue }
      var data$0 = match[1];
      if (prec$0)
        prec$0[3] = slot$0;
      else
        caml_check_bound(h[2], i)[1 + i] = slot$0;
      slot$0[2] = data$0;
      var prec$0 = slot$0, slot$0 = next
    }
  }
  function filter_map_inplace(f, h) {
    var d = h[2], old_trav = ongoing_traversal(h);
    if (1 - old_trav) flip_ongoing_traversal(h);
    try {
      var _n6_ = d.length - 1 - 1 | 0, _n5_ = 0;
      if (_n6_ >= 0) {
        var i = _n5_;
        for (; ;) {
          filter_map_inplace_bucket(f, h, i, 0, caml_check_bound(h[2], i)[1 + i]);
          var _n9_ = i + 1 | 0;
          if (_n6_ !== i) { var i = _n9_; continue }
          break
        }
      }
      var _n7_ = 1 - old_trav, _n8_ = _n7_ ? flip_ongoing_traversal(h) : _n7_;
      return _n8_
    }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (old_trav) throw exn;
      flip_ongoing_traversal(h);
      throw exn
    }
  }
  function fold$4(f, h, init) {
    function do_bucket(b, accu) {
      var b$0 = b, accu$0 = accu;
      for (; ;) {
        if (!b$0) return accu$0;
        var
          key = b$0[1],
          data = b$0[2],
          next = b$0[3],
          accu$1 = caml_call3(f, key, data, accu$0),
          b$0 = next,
          accu$0 = accu$1
      }
    }
    var old_trav = ongoing_traversal(h);
    if (1 - old_trav) flip_ongoing_traversal(h);
    try {
      var d = h[2], accu = [0, init], _n1_ = d.length - 1 - 1 | 0, _n0_ = 0;
      if (_n1_ >= 0) {
        var i = _n0_;
        for (; ;) {
          var _n3_ = accu[1];
          accu[1] = do_bucket(caml_check_bound(d, i)[1 + i], _n3_);
          var _n4_ = i + 1 | 0;
          if (_n1_ !== i) { var i = _n4_; continue }
          break
        }
      }
      if (1 - old_trav) flip_ongoing_traversal(h);
      var _n2_ = accu[1];
      return _n2_
    }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (old_trav) throw exn;
      flip_ongoing_traversal(h);
      throw exn
    }
  }
  function bucket_length(accu, param) {
    var accu$0 = accu, param$0 = param;
    for (; ;) {
      if (!param$0) return accu$0;
      var
        param$1 = param$0[3],
        accu$1 = accu$0 + 1 | 0,
        accu$0 = accu$1,
        param$0 = param$1
    }
  }
  function stats(h) {
    var
    _nW_ = h[2],
    _nX_ = 0,
    mbl =
      fold_left$3
        (function (m, b) { return max$1(m, bucket_length(0, b)) }, _nX_, _nW_),
    histo = caml_make_vect(mbl + 1 | 0, 0),
    _nY_ = h[2];
    iter$5
      (function (b) {
        var
        l = bucket_length(0, b),
        _nZ_ = caml_check_bound(histo, l)[1 + l] + 1 | 0;
        caml_check_bound(histo, l)[1 + l] = _nZ_;
        return 0
      },
        _nY_);
    return [0, h[1], h[2].length - 1, mbl, histo]
  }
  function to_seq$9(tbl) {
    var tbl_data = tbl[2];
    function aux(i, buck, param) {
      var i$0 = i, buck$0 = buck;
      for (; ;) {
        if (buck$0) {
          var key = buck$0[1], data = buck$0[2], next = buck$0[3];
          return [0, [0, key, data], function (_nV_) { return aux(i$0, next, _nV_) }]
        }
        if (i$0 === tbl_data.length - 1) return 0;
        var
          buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
          i$1 = i$0 + 1 | 0,
          i$0 = i$1,
          buck$0 = buck$1
      }
    }
    var _nS_ = 0, _nT_ = 0;
    return function (_nU_) { return aux(_nT_, _nS_, _nU_) }
  }
  function to_seq_keys(m) {
    var _nO_ = to_seq$9(m);
    function _nP_(_nR_) { return _nR_[1] }
    return function (_nQ_) { return map$1(_nP_, _nO_, _nQ_) }
  }
  function to_seq_values(m) {
    var _nK_ = to_seq$9(m);
    function _nL_(_nN_) { return _nN_[2] }
    return function (_nM_) { return map$1(_nL_, _nK_, _nM_) }
  }
  function MakeSeeded(H) {
    function key_index(h, key) {
      var _nJ_ = h[2].length - 1 - 1 | 0;
      return caml_call2(H[2], h[3], key) & _nJ_
    }
    function add(h, key, data) {
      var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
      caml_check_bound(h[2], i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _nI_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      return _nI_ ? resize$0(key_index, h) : _nI_
    }
    function remove(h, key) {
      var
      i = key_index(h, key),
      c$0 = caml_check_bound(h[2], i)[1 + i],
      prec = 0,
      c = c$0;
      for (; ;) {
        if (!c) return 0;
        var k = c[1], next = c[3];
        if (caml_call2(H[1], k, key)) {
          h[1] = h[1] - 1 | 0;
          return prec
            ? (prec[3] = next, 0)
            : (caml_check_bound(h[2], i)[1 + i] = next, 0)
        }
        var prec = c, c = next
      }
    }
    function find(h, key) {
      var _nH_ = key_index(h, key), match = caml_check_bound(h[2], _nH_)[1 + _nH_];
      if (!match) throw Not_found;
      var k1 = match[1], d1 = match[2], next1 = match[3];
      if (caml_call2(H[1], key, k1)) return d1;
      if (!next1) throw Not_found;
      var k2 = next1[1], d2 = next1[2], next2 = next1[3];
      if (caml_call2(H[1], key, k2)) return d2;
      if (!next2) throw Not_found;
      var k3 = next2[1], d3 = next2[2], next3 = next2[3];
      if (caml_call2(H[1], key, k3)) return d3;
      var param = next3;
      for (; ;) {
        if (!param) throw Not_found;
        var k = param[1], data = param[2], next = param[3];
        if (caml_call2(H[1], key, k)) return data;
        var param = next
      }
    }
    function find_opt(h, key) {
      var _nG_ = key_index(h, key), match = caml_check_bound(h[2], _nG_)[1 + _nG_];
      if (!match) return 0;
      var k1 = match[1], d1 = match[2], next1 = match[3];
      if (caml_call2(H[1], key, k1)) return [0, d1];
      if (!next1) return 0;
      var k2 = next1[1], d2 = next1[2], next2 = next1[3];
      if (caml_call2(H[1], key, k2)) return [0, d2];
      if (!next2) return 0;
      var k3 = next2[1], d3 = next2[2], next3 = next2[3];
      if (caml_call2(H[1], key, k3)) return [0, d3];
      var param = next3;
      for (; ;) {
        if (!param) return 0;
        var k = param[1], data = param[2], next = param[3];
        if (caml_call2(H[1], key, k)) return [0, data];
        var param = next
      }
    }
    function find_all(h, key) {
      function find_in_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) return 0;
          var k = param$0[1], d = param$0[2], next = param$0[3];
          if (caml_call2(H[1], k, key)) return [0, d, find_in_bucket(next)];
          var param$0 = next
        }
      }
      var _nF_ = key_index(h, key);
      return find_in_bucket(caml_check_bound(h[2], _nF_)[1 + _nF_])
    }
    function replace(h, key, data) {
      var
      i = key_index(h, key),
      param$0 = caml_check_bound(h[2], i)[1 + i],
      param = param$0;
      for (; ;) {
        if (param) {
          var k = param[1], next = param[3];
          if (!caml_call2(H[1], k, key)) { var param = next; continue }
          param[1] = key;
          param[2] = data;
          var _nC_ = 0
        }
        else
          var _nC_ = 1;
        if (_nC_) {
          caml_check_bound(h[2], i)[1 + i] = [0, key, data, param$0];
          h[1] = h[1] + 1 | 0;
          var _nD_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
          if (_nD_) return resize$0(key_index, h);
          var _nE_ = _nD_
        }
        else
          var _nE_ = _nC_;
        return _nE_
      }
    }
    function mem(h, key) {
      var
      _nB_ = key_index(h, key),
      param$0 = caml_check_bound(h[2], _nB_)[1 + _nB_],
      param = param$0;
      for (; ;) {
        if (!param) return 0;
        var k = param[1], next = param[3], _nA_ = caml_call2(H[1], k, key);
        if (_nA_) return _nA_;
        var param = next
      }
    }
    function add_seq(tbl, i) {
      return iter
        (function (param) { var v = param[2], k = param[1]; return add(tbl, k, v) },
          i)
    }
    function replace_seq(tbl, i) {
      return iter
        (function (param) { var v = param[2], k = param[1]; return replace(tbl, k, v) },
          i)
    }
    function of_seq(i) { var tbl = create$3(0, 16); replace_seq(tbl, i); return tbl }
    return [0,
      create$3,
      clear$2,
      reset$0,
      copy$6,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter$10,
      filter_map_inplace,
      fold$4,
      length$5,
      stats,
      to_seq$9,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq]
  }
  function Make$0(H) {
    var equal = H[1];
    function hash(seed, x) { return caml_call1(H[2], x) }
    var
      include = MakeSeeded([0, equal, hash]),
      clear = include[2],
      reset = include[3],
      copy = include[4],
      add = include[5],
      remove = include[6],
      find = include[7],
      find_opt = include[8],
      find_all = include[9],
      replace = include[10],
      mem = include[11],
      iter = include[12],
      filter_map_inplace = include[13],
      fold = include[14],
      length = include[15],
      stats = include[16],
      to_seq = include[17],
      to_seq_keys = include[18],
      to_seq_values = include[19],
      add_seq = include[20],
      replace_seq = include[21],
      _nz_ = include[1];
    function create(sz) { return caml_call2(_nz_, _ci_, sz) }
    function of_seq(i) { var tbl = create(16); caml_call2(replace_seq, tbl, i); return tbl }
    return [0,
      create,
      clear,
      reset,
      copy,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter,
      filter_map_inplace,
      fold,
      length,
      stats,
      to_seq,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq]
  }
  function hash$1(x) { return caml_hash(10, 100, 0, x) }
  function hash_param(n1, n2, x) { return caml_hash(n1, n2, 0, x) }
  function seeded_hash(seed, x) { return caml_hash(10, 100, seed, x) }
  function key_index(h, key) {
    return 4 <= h.length - 1
      ? caml_hash(10, 100, h[3], key) & (h[2].length - 1 - 1 | 0)
      : invalid_arg(cst_Hashtbl_unsupported_hash_t)
  }
  function add$0(h, key, data) {
    var
    i = key_index(h, key),
    bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _ny_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _ny_ ? resize$0(key_index, h) : _ny_
  }
  function remove(h, key) {
    var i = key_index(h, key), c$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, c = c$0;
    for (; ;) {
      if (!c) return 0;
      var k = c[1], next = c[3];
      if (0 === caml_compare(k, key)) {
        h[1] = h[1] - 1 | 0;
        return prec
          ? (prec[3] = next, 0)
          : (caml_check_bound(h[2], i)[1 + i] = next, 0)
      }
      var prec = c, c = next
    }
  }
  function find$1(h, key) {
    var _nx_ = key_index(h, key), match = caml_check_bound(h[2], _nx_)[1 + _nx_];
    if (!match) throw Not_found;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if (0 === caml_compare(key, k1)) return d1;
    if (!next1) throw Not_found;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if (0 === caml_compare(key, k2)) return d2;
    if (!next2) throw Not_found;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if (0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for (; ;) {
      if (!param) throw Not_found;
      var k = param[1], data = param[2], next = param[3];
      if (0 === caml_compare(key, k)) return data;
      var param = next
    }
  }
  function find_opt$1(h, key) {
    var _nw_ = key_index(h, key), match = caml_check_bound(h[2], _nw_)[1 + _nw_];
    if (!match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if (0 === caml_compare(key, k1)) return [0, d1];
    if (!next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if (0 === caml_compare(key, k2)) return [0, d2];
    if (!next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if (0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for (; ;) {
      if (!param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if (0 === caml_compare(key, k)) return [0, data];
      var param = next
    }
  }
  function find_all$0(h, key) {
    function find_in_bucket(param) {
      var param$0 = param;
      for (; ;) {
        if (!param$0) return 0;
        var k = param$0[1], data = param$0[2], next = param$0[3];
        if (0 === caml_compare(k, key)) return [0, data, find_in_bucket(next)];
        var param$0 = next
      }
    }
    var _nv_ = key_index(h, key);
    return find_in_bucket(caml_check_bound(h[2], _nv_)[1 + _nv_])
  }
  function replace(h, key, data) {
    var
    i = key_index(h, key),
    param$0 = caml_check_bound(h[2], i)[1 + i],
    param = param$0;
    for (; ;) {
      if (param) {
        var k = param[1], next = param[3];
        if (0 !== caml_compare(k, key)) { var param = next; continue }
        param[1] = key;
        param[2] = data;
        var _ns_ = 0
      }
      else
        var _ns_ = 1;
      if (_ns_) {
        caml_check_bound(h[2], i)[1 + i] = [0, key, data, param$0];
        h[1] = h[1] + 1 | 0;
        var _nt_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
        if (_nt_) return resize$0(key_index, h);
        var _nu_ = _nt_
      }
      else
        var _nu_ = _ns_;
      return _nu_
    }
  }
  function mem$2(h, key) {
    var
    _nr_ = key_index(h, key),
    param$0 = caml_check_bound(h[2], _nr_)[1 + _nr_],
    param = param$0;
    for (; ;) {
      if (!param) return 0;
      var k = param[1], next = param[3], _nq_ = 0 === caml_compare(k, key) ? 1 : 0;
      if (_nq_) return _nq_;
      var param = next
    }
  }
  function add_seq$2(tbl, i) {
    return iter
      (function (param) { var v = param[2], k = param[1]; return add$0(tbl, k, v) },
        i)
  }
  function replace_seq(tbl, i) {
    return iter
      (function (param) { var v = param[2], k = param[1]; return replace(tbl, k, v) },
        i)
  }
  function of_seq$7(i) { var tbl = create$3(0, 16); replace_seq(tbl, i); return tbl }
  function rebuild(opt, h) {
    if (opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, h[2].length - 1);
    if (random)
      var
        _nj_ = caml_obj_tag(prng),
        _nk_ = 250 === _nj_ ? prng[1] : 246 === _nj_ ? force_lazy_block(prng) : prng,
        seed = caml_call1(_cg_[4], _nk_);
    else
      var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
      _nl_ = 4 <= h.length - 1 ? h[4] : s,
      h$0 = [0, h[1], caml_make_vect(s, 0), seed, _nl_],
      _nm_ = h$0[2],
      _nn_ = h[2],
      _no_ = 0;
    insert_all_buckets
      (function (_np_) { return key_index(h$0, _np_) }, _no_, _nn_, _nm_);
    return h$0
  }
  var
    Stdlib_Hashtbl =
      [0,
        create$3,
        clear$2,
        reset$0,
        copy$6,
        add$0,
        find$1,
        find_opt$1,
        find_all$0,
        mem$2,
        remove,
        replace,
        iter$10,
        filter_map_inplace,
        fold$4,
        length$5,
        randomize,
        is_randomized,
        rebuild,
        stats,
        to_seq$9,
        to_seq_keys,
        to_seq_values,
        add_seq$2,
        replace_seq,
        of_seq$7,
        Make$0,
        MakeSeeded,
        hash$1,
        seeded_hash,
        hash_param,
        caml_hash];
  caml_register_global(816, Stdlib_Hashtbl, "Stdlib__Hashtbl");
  function weak_create(l) {
    var _nh_ = 0 <= l ? 1 : 0, _ni_ = _nh_ ? l <= _o_[15] ? 1 : 0 : _nh_;
    if (1 - _ni_) invalid_arg(cst_Weak_create);
    return runtime.caml_weak_create(l)
  }
  function length$6(x) { return x.length - 1 - 2 | 0 }
  function raise_if_invalid_offset$0(e, o, msg) {
    var _ne_ = 0 <= o ? 1 : 0, _nf_ = _ne_ ? o < length$6(e) ? 1 : 0 : _ne_, _ng_ = 1 - _nf_;
    return _ng_ ? invalid_arg(msg) : _ng_
  }
  function set$1(e, o, x) {
    raise_if_invalid_offset$0(e, o, cst_Weak_set);
    if (!x) return caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return caml_ephe_set_key(e, o, x$0)
  }
  function get$2(e, o) {
    raise_if_invalid_offset$0(e, o, cst_Weak_get);
    return caml_ephe_get_key(e, o)
  }
  function get_copy(e, o) {
    raise_if_invalid_offset$0(e, o, cst_Weak_get_copy);
    return caml_ephe_get_key_copy(e, o)
  }
  function check$0(e, o) {
    raise_if_invalid_offset$0(e, o, cst_Weak_check);
    return caml_ephe_check_key(e, o)
  }
  function blit$4(e1, o1, e2, o2, l) {
    if
      (0
      <=
      l
      &&
      0
      <=
      o1
      &&
      (length$6(e1) - l | 0)
      >=
      o1
      &&
      0
      <=
      o2
      &&
      (length$6(e2) - l | 0)
      >=
      o2) {
      var _nc_ = 0 !== l ? 1 : 0, _nd_ = _nc_ ? caml_ephe_blit_key(e1, o1, e2, o2, l) : _nc_;
      return _nd_
    }
    return invalid_arg(cst_Weak_blit)
  }
  function fill$2(ar, ofs, len, x) {
    if (0 <= ofs && 0 <= len && (length$6(ar) - len | 0) >= ofs) {
      var _na_ = (ofs + len | 0) - 1 | 0;
      if (_na_ >= ofs) {
        var i = ofs;
        for (; ;) {
          set$1(ar, i, x);
          var _nb_ = i + 1 | 0;
          if (_na_ !== i) { var i = _nb_; continue }
          break
        }
      }
      return 0
    }
    throw [0, Invalid_argument, cst_Weak_fill]
  }
  function Make$1(H) {
    var emptybucket = weak_create(0);
    function get_index(t, h) { return caml_mod(h & 2147483647, t[1].length - 1) }
    var limit = 7;
    function create(sz) {
      var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = max_array_length < sz$0 ? max_array_length : sz$0;
      return [0,
        caml_make_vect(sz$1, emptybucket),
        caml_make_vect(sz$1, [0]),
        limit,
        0,
        0]
    }
    function clear(t) {
      var _m__ = t[1].length - 1 - 1 | 0, _m9_ = 0;
      if (_m__ >= 0) {
        var i = _m9_;
        for (; ;) {
          caml_check_bound(t[1], i)[1 + i] = emptybucket;
          caml_check_bound(t[2], i)[1 + i] = [0];
          var _m$_ = i + 1 | 0;
          if (_m__ !== i) { var i = _m$_; continue }
          break
        }
      }
      t[3] = limit;
      t[4] = 0;
      return 0
    }
    function fold(f, t, init) {
      var _m8_ = t[1], i = 0;
      return fold_right$2
        (function (b, accu$1) {
          var i$0 = i, accu = accu$1;
          for (; ;) {
            if (length$6(b) <= i$0) return accu;
            var match = get$2(b, i$0);
            if (match) {
              var
              v = match[1],
              accu$0 = caml_call2(f, v, accu),
              i$1 = i$0 + 1 | 0,
              i$0 = i$1,
              accu = accu$0;
              continue
            }
            var i$2 = i$0 + 1 | 0, i$0 = i$2
          }
        },
          _m8_,
          init)
    }
    function iter(f, t) {
      var _m7_ = t[1], i = 0;
      return iter$5
        (function (b) {
          var i$0 = i;
          for (; ;) {
            if (length$6(b) <= i$0) return 0;
            var match = get$2(b, i$0);
            if (match) {
              var v = match[1];
              caml_call1(f, v);
              var i$1 = i$0 + 1 | 0, i$0 = i$1;
              continue
            }
            var i$2 = i$0 + 1 | 0, i$0 = i$2
          }
        },
          _m7_)
    }
    function count_bucket(i, b, accu) {
      var i$0 = i, accu$0 = accu;
      for (; ;) {
        if (length$6(b) <= i$0) return accu$0;
        var
          _m6_ = check$0(b, i$0) ? 1 : 0,
          accu$1 = accu$0 + _m6_ | 0,
          i$1 = i$0 + 1 | 0,
          i$0 = i$1,
          accu$0 = accu$1
      }
    }
    function count(t) {
      var _m1_ = 0, _m2_ = t[1], _m3_ = 0;
      return fold_right$2
        (function (_m4_, _m5_) { return count_bucket(_m3_, _m4_, _m5_) },
          _m2_,
          _m1_)
    }
    function add_aux(t, setter, d, h, index) {
      var
      bucket$0 = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length$6(bucket$0),
      i$3 = 0;
      for (; ;) {
        if (sz > i$3) {
          if (check$0(bucket$0, i$3)) { var i$5 = i$3 + 1 | 0, i$3 = i$5; continue }
          caml_call3(setter, bucket$0, i$3, d);
          caml_check_bound(hashes, i$3)[1 + i$3] = h;
          return 0
        }
        var
          newsz =
            min$1(((3 * sz | 0) / 2 | 0) + 3 | 0, max_array_length - 2 | 0);
        if (newsz <= sz) failwith(cst_Weak_Make_hash_bucket_cann);
        var
          newbucket$0 = weak_create(newsz),
          newhashes = caml_make_vect(newsz, 0);
        blit$4(bucket$0, 0, newbucket$0, 0, sz);
        blit$1(hashes, 0, newhashes, 0, sz);
        caml_call3(setter, newbucket$0, sz, d);
        caml_check_bound(newhashes, sz)[1 + sz] = h;
        caml_check_bound(t[1], index)[1 + index] = newbucket$0;
        caml_check_bound(t[2], index)[1 + index] = newhashes;
        var _mX_ = sz <= t[3] ? 1 : 0, _mY_ = _mX_ ? t[3] < newsz ? 1 : 0 : _mX_;
        if (_mY_) {
          t[4] = t[4] + 1 | 0;
          var i$4 = 0;
          for (; ;) {
            var
            _mN_ = t[5],
            bucket = caml_check_bound(t[1], _mN_)[1 + _mN_],
            _mO_ = t[5],
            hbucket = caml_check_bound(t[2], _mO_)[1 + _mO_],
            n = length$6(bucket),
            prev_len = (((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
            live = count_bucket(0, bucket, 0);
            if (live <= prev_len) {
              var j$2 = length$6(bucket) - 1 | 0, i$0 = 0, j = j$2;
              for (; ;) {
                if (prev_len <= j) {
                  if (check$0(bucket, i$0)) { var i$1 = i$0 + 1 | 0, i$0 = i$1; continue }
                  if (check$0(bucket, j)) {
                    blit$4(bucket, j, bucket, i$0, 1);
                    var _mP_ = caml_check_bound(hbucket, j)[1 + j];
                    caml_check_bound(hbucket, i$0)[1 + i$0] = _mP_;
                    var j$0 = j - 1 | 0, i$2 = i$0 + 1 | 0, i$0 = i$2, j = j$0;
                    continue
                  }
                  var j$1 = j - 1 | 0, j = j$1;
                  continue
                }
                if (0 === prev_len) {
                  var _mQ_ = t[5];
                  caml_check_bound(t[1], _mQ_)[1 + _mQ_] = emptybucket;
                  var _mR_ = t[5];
                  caml_check_bound(t[2], _mR_)[1 + _mR_] = [0]
                }
                else {
                  var newbucket = weak_create(prev_len);
                  blit$4(bucket, 0, newbucket, 0, prev_len);
                  var _mU_ = t[5];
                  caml_check_bound(t[1], _mU_)[1 + _mU_] = newbucket;
                  var _mV_ = sub$1(hbucket, 0, prev_len), _mW_ = t[5];
                  caml_check_bound(t[2], _mW_)[1 + _mW_] = _mV_
                }
                var _mS_ = t[3] < n ? 1 : 0, _mT_ = _mS_ ? prev_len <= t[3] ? 1 : 0 : _mS_;
                if (_mT_) t[4] = t[4] - 1 | 0;
                break
              }
            }
            t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
            var _m0_ = i$4 + 1 | 0;
            if (2 !== i$4) { var i$4 = _m0_; continue }
            break
          }
        }
        var _mZ_ = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
        if (!_mZ_) return _mZ_;
        var
          n$0 = t[1].length - 1,
          newlen = min$1(((3 * n$0 | 0) / 2 | 0) + 3 | 0, max_array_length);
        if (n$0 < newlen) {
          var newt = create(newlen), _mM_ = t[1], i = 0;
          iteri$3
            (function (j, ob) {
              var i$0 = i;
              for (; ;) {
                if (length$6(ob) <= i$0) return 0;
                var match = check$0(ob, i$0);
                if (match) {
                  var
                  oh = caml_check_bound(t[2], j)[1 + j],
                  setter$0 =
                    function (i) {
                      function setter(nb, ni, param) { return blit$4(ob, i, nb, ni, 1) }
                      return setter
                    },
                  setter = setter$0(i$0),
                  h = caml_check_bound(oh, i$0)[1 + i$0];
                  add_aux(newt, setter, 0, h, get_index(newt, h));
                  var i$1 = i$0 + 1 | 0, i$0 = i$1;
                  continue
                }
                var i$2 = i$0 + 1 | 0, i$0 = i$2
              }
            },
              _mM_);
          t[1] = newt[1];
          t[2] = newt[2];
          t[3] = newt[3];
          t[4] = newt[4];
          t[5] = caml_mod(t[5], newt[1].length - 1);
          return 0
        }
        t[3] = max_int;
        t[4] = 0;
        return 0
      }
    }
    function add(t, d) {
      var h = caml_call1(H[2], d);
      return add_aux(t, set$1, [0, d], h, get_index(t, h))
    }
    function find_or(t, d, ifnotfound) {
      var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length$6(bucket),
      i = 0;
      for (; ;) {
        if (sz <= i) return caml_call2(ifnotfound, h, index);
        if (h !== caml_check_bound(hashes, i)[1 + i]) { var i$2 = i + 1 | 0, i = i$2; continue }
        var match = get_copy(bucket, i);
        if (match) {
          var v = match[1];
          if (caml_call2(H[1], v, d)) {
            var match$0 = get$2(bucket, i);
            if (match$0) { var v$0 = match$0[1]; return v$0 }
            var i$0 = i + 1 | 0, i = i$0;
            continue
          }
        }
        var i$1 = i + 1 | 0, i = i$1
      }
    }
    function merge(t, d) {
      return find_or
        (t,
          d,
          function (h, index) { add_aux(t, set$1, [0, d], h, index); return d })
    }
    function find(t, d) { return find_or(t, d, function (h, index) { throw Not_found }) }
    function find_opt(t, d) {
      var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length$6(bucket),
      i = 0;
      for (; ;) {
        if (sz <= i) return 0;
        if (h !== caml_check_bound(hashes, i)[1 + i]) { var i$2 = i + 1 | 0, i = i$2; continue }
        var match = get_copy(bucket, i);
        if (match) {
          var v = match[1];
          if (caml_call2(H[1], v, d)) {
            var v$0 = get$2(bucket, i);
            if (v$0) return v$0;
            var i$0 = i + 1 | 0, i = i$0;
            continue
          }
        }
        var i$1 = i + 1 | 0, i = i$1
      }
    }
    function find_shadow(t, d, iffound, ifnotfound) {
      var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length$6(bucket),
      i = 0;
      for (; ;) {
        if (sz <= i) return ifnotfound;
        if (h !== caml_check_bound(hashes, i)[1 + i]) { var i$1 = i + 1 | 0, i = i$1; continue }
        var match = get_copy(bucket, i);
        if (match) {
          var v = match[1];
          if (caml_call2(H[1], v, d)) return caml_call2(iffound, bucket, i)
        }
        var i$0 = i + 1 | 0, i = i$0
      }
    }
    function remove(t, d) {
      var _mL_ = 0;
      return find_shadow(t, d, function (w, i) { return set$1(w, i, 0) }, _mL_)
    }
    function mem(t, d) { var _mK_ = 0; return find_shadow(t, d, function (w, i) { return 1 }, _mK_) }
    function find_all(t, d) {
      var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length$6(bucket),
      i = 0,
      accu = 0;
      for (; ;) {
        if (sz <= i) return accu;
        if (h !== caml_check_bound(hashes, i)[1 + i]) { var i$3 = i + 1 | 0, i = i$3; continue }
        var match = get_copy(bucket, i);
        if (match) {
          var v = match[1];
          if (caml_call2(H[1], v, d)) {
            var match$0 = get$2(bucket, i);
            if (match$0) {
              var
              v$0 = match$0[1],
              accu$0 = [0, v$0, accu],
              i$0 = i + 1 | 0,
              i = i$0,
              accu = accu$0;
              continue
            }
            var i$1 = i + 1 | 0, i = i$1;
            continue
          }
        }
        var i$2 = i + 1 | 0, i = i$2
      }
    }
    function stats(t) {
      var len = t[1].length - 1, lens = map$7(length$6, t[1]);
      sort(caml_int_compare, lens);
      var
        _mC_ = 0,
        totlen =
          fold_left$3(function (_mJ_, _mI_) { return _mJ_ + _mI_ | 0 }, _mC_, lens),
        _mD_ = len - 1 | 0,
        _mF_ = len / 2 | 0,
        _mE_ = caml_check_bound(lens, _mD_)[1 + _mD_],
        _mG_ = caml_check_bound(lens, _mF_)[1 + _mF_],
        _mH_ = caml_check_bound(lens, 0)[1];
      return [0, len, count(t), totlen, _mH_, _mG_, _mE_]
    }
    return [0,
      create,
      clear,
      merge,
      add,
      remove,
      find,
      find_opt,
      find_all,
      mem,
      iter,
      fold,
      count,
      stats]
  }
  var
    Stdlib_Weak =
      [0,
        weak_create,
        length$6,
        set$1,
        get$2,
        get_copy,
        check$0,
        fill$2,
        blit$4,
        Make$1];
  caml_register_global(817, Stdlib_Weak, "Stdlib__Weak");
  function id$0(x) { return x }
  var
    String_tag = [248, cst_Stdlib_Format_String_tag, caml_fresh_oo_id(0)],
    size = 0,
    unknown = -1;
  function pp_enqueue(state, token) { state[13] = state[13] + token[3] | 0; return add(token, state[28]) }
  var pp_infinity = 1000000010;
  function pp_output_string(state, s) { return caml_call3(state[17], s, 0, caml_ml_string_length(s)) }
  function pp_output_newline(state) { return caml_call1(state[19], 0) }
  function format_pp_text(state, size, text) {
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
    return 0
  }
  function format_string(state, s) {
    var _mB_ = caml_string_notequal(s, cst$67);
    return _mB_ ? format_pp_text(state, caml_ml_string_length(s), s) : _mB_
  }
  function break_new_line(state, param, width) {
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
      indent = (state[6] - width | 0) + offset | 0,
      real_indent = min$1(state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    caml_call1(state[21], state[10]);
    return format_string(state, after)
  }
  function break_line(state, width) { return break_new_line(state, _cj_, width) }
  function break_same_line(state, param) {
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after)
  }
  function format_pp_token(state, size$0, param) {
    if (typeof param === "number")
      switch (param) {
        case 0:
          var match$3 = top_opt(state[3]);
          if (!match$3) return 0;
          var
            match$4 = match$3[1],
            tabs = match$4[1],
            add_tab =
              function (n, ls) {
                if (!ls) return [0, n, 0];
                var l = ls[2], x = ls[1];
                return caml_lessthan(n, x) ? [0, n, ls] : [0, x, add_tab(n, l)]
              };
          tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
          return 0;
        case 1: pop_opt(state[2]); return 0;
        case 2: pop_opt(state[3]); return 0;
        case 3:
          var match$5 = top_opt(state[2]);
          if (!match$5) return pp_output_newline(state);
          var match$6 = match$5[1], width$0 = match$6[2];
          return break_line(state, width$0);
        case 4:
          var _my_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
          if (!_my_) return _my_;
          var match$1 = take_opt(state[28]);
          if (!match$1) return 0;
          var match$2 = match$1[1], size = match$2[1], length = match$2[3];
          state[12] = state[12] - length | 0;
          state[9] = state[9] + size | 0;
          return 0;
        default:
          var match$7 = pop_opt(state[5]);
          if (!match$7) return 0;
          var tag_name = match$7[1], marker = caml_call1(state[25], tag_name);
          return pp_output_string(state, marker)
      }
    switch (param[0]) {
      case 0: var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
        var
          breaks = param[2],
          fits = param[1],
          off = breaks[2],
          before = breaks[1],
          match$8 = top_opt(state[2]);
        if (!match$8) return 0;
        var match$9 = match$8[1], width$1 = match$9[2], box_type$0 = match$9[1];
        switch (box_type$0) {
          case 0: return break_same_line(state, fits);
          case 1: return break_new_line(state, breaks, width$1);
          case 2: return break_new_line(state, breaks, width$1);
          case 3:
            return state[9] < (size$0 + caml_ml_string_length(before) | 0)
              ? break_new_line(state, breaks, width$1)
              : break_same_line(state, fits);
          case 4:
            return state[11]
              ? break_same_line(state, fits)
              : state[9] < (size$0 + caml_ml_string_length(before) | 0)
                ? break_new_line(state, breaks, width$1)
                : ((state[6] - width$1 | 0) + off | 0) < state[10]
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
          default: return break_same_line(state, fits)
        }
      case 2:
        var
          off$0 = param[2],
          n = param[1],
          insertion_point = state[6] - state[9] | 0,
          match$10 = top_opt(state[3]);
        if (!match$10) return 0;
        var match$11 = match$10[1], tabs$0 = match$11[1], _mz_ = tabs$0[1];
        if (_mz_) {
          var first = _mz_[1], param$0 = tabs$0[1];
          for (; ;) {
            if (param$0) {
              var tail = param$0[2], head = param$0[1];
              if (insertion_point > head) { var param$0 = tail; continue }
              var _mA_ = head
            }
            else
              var _mA_ = first;
            var tab = _mA_;
            break
          }
        }
        else
          var tab = insertion_point;
        var offset = tab - insertion_point | 0;
        return 0 <= offset
          ? break_same_line(state, [0, cst$69, offset + n | 0, cst$68])
          : break_new_line
            (state, [0, cst$71, tab + off$0 | 0, cst$70], state[6]);
      case 3:
        var
          ty = param[2],
          off$1 = param[1],
          insertion_point$0 = state[6] - state[9] | 0;
        if (state[8] < insertion_point$0) {
          var match = top_opt(state[2]);
          if (match) {
            var match$0 = match[1], width = match$0[2], box_type = match$0[1];
            if (state[9] < width && 3 >= box_type - 1 >>> 0)
              break_line(state, width)
          }
          else
            pp_output_newline(state)
        }
        var
          width$2 = state[9] - off$1 | 0,
          box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
        return push([0, box_type$1, width$2], state[2]);
      case 4: var tbox = param[1]; return push(tbox, state[3]);
      default:
        var tag_name$0 = param[1], marker$0 = caml_call1(state[24], tag_name$0);
        pp_output_string(state, marker$0);
        return push(tag_name$0, state[5])
    }
  }
  function advance_left(state) {
    for (; ;) {
      var match = peek_opt(state[28]);
      if (!match) return 0;
      var
        match$0 = match[1],
        size = match$0[1],
        length = match$0[3],
        token = match$0[2],
        pending_count = state[13] - state[12] | 0,
        _mw_ = 0 <= size ? 1 : 0,
        _mx_ = _mw_ || (state[9] <= pending_count ? 1 : 0);
      if (!_mx_) return _mx_;
      take$0(state[28]);
      var size$0 = 0 <= size ? size : pp_infinity;
      format_pp_token(state, size$0, token);
      state[12] = length + state[12] | 0
    }
  }
  function enqueue_advance(state, tok) { pp_enqueue(state, tok); return advance_left(state) }
  function enqueue_string_as(state, size, s) { return enqueue_advance(state, [0, size, [0, s], size]) }
  function initialize_scan_stack(stack) {
    clear(stack);
    var queue_elem = [0, unknown, _ck_, 0];
    return push([0, -1, queue_elem], stack)
  }
  function set_size(state, ty) {
    var match = top_opt(state[1]);
    if (!match) return 0;
    var
      match$0 = match[1],
      queue_elem = match$0[2],
      left_total = match$0[1],
      _mr_ = queue_elem[1];
    if (left_total < state[12]) return initialize_scan_stack(state[1]);
    var _ms_ = queue_elem[2];
    if (typeof _ms_ !== "number")
      switch (_ms_[0]) {
        case 3:
          var
            _mu_ = 1 - ty,
            _mv_ =
              _mu_
                ? (queue_elem[1] = state[13] + _mr_ | 0, pop_opt(state[1]), 0)
                : _mu_;
          return _mv_;
        case 1:
        case 2:
          var
            _mt_ =
              ty ? (queue_elem[1] = state[13] + _mr_ | 0, pop_opt(state[1]), 0) : ty;
          return _mt_
      }
    return 0
  }
  function scan_push(state, b, token) {
    pp_enqueue(state, token);
    if (b) set_size(state, 1);
    var elem = [0, state[13], token];
    return push(elem, state[1])
  }
  function pp_open_box_gen(state, indent, br_ty) {
    state[14] = state[14] + 1 | 0;
    if (state[14] < state[15]) {
      var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
      return scan_push(state, 0, elem)
    }
    var _mp_ = state[14] === state[15] ? 1 : 0;
    if (!_mp_) return _mp_;
    var _mq_ = state[16];
    return enqueue_string_as(state, caml_ml_string_length(_mq_), _mq_)
  }
  function pp_close_box(state, param) {
    var _mn_ = 1 < state[14] ? 1 : 0;
    if (_mn_) {
      if (state[14] < state[15]) { pp_enqueue(state, [0, size, 1, 0]); set_size(state, 1); set_size(state, 0) }
      state[14] = state[14] - 1 | 0;
      var _mo_ = 0
    }
    else
      var _mo_ = _mn_;
    return _mo_
  }
  function pp_open_stag(state, tag_name) {
    if (state[22]) { push(tag_name, state[4]); caml_call1(state[26], tag_name) }
    var _mm_ = state[23];
    if (!_mm_) return _mm_;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, size, token, 0])
  }
  function pp_close_stag(state, param) {
    if (state[23]) pp_enqueue(state, [0, size, 5, 0]);
    var _mk_ = state[22];
    if (_mk_) {
      var match = pop_opt(state[4]);
      if (match) { var tag_name = match[1]; return caml_call1(state[27], tag_name) }
      var _ml_ = 0
    }
    else
      var _ml_ = _mk_;
    return _ml_
  }
  function pp_open_tag(state, s) { return pp_open_stag(state, [0, String_tag, s]) }
  function pp_close_tag(state, param) { return pp_close_stag(state, 0) }
  function pp_set_print_tags(state, b) { state[22] = b; return 0 }
  function pp_set_mark_tags(state, b) { state[23] = b; return 0 }
  function pp_get_print_tags(state, param) { return state[22] }
  function pp_get_mark_tags(state, param) { return state[23] }
  function pp_set_tags(state, b) { pp_set_print_tags(state, b); return pp_set_mark_tags(state, b) }
  function pp_get_formatter_stag_function(state, param) { return [0, state[24], state[25], state[26], state[27]] }
  function pp_set_formatter_stag_function(state, param) {
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0
  }
  function pp_rinit(state) {
    state[12] = 1;
    state[13] = 1;
    clear$0(state[28]);
    initialize_scan_stack(state[1]);
    clear(state[2]);
    clear(state[3]);
    clear(state[4]);
    clear(state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3)
  }
  function pp_flush_queue(state, b) {
    var _mj_ = state[4];
    iter$7(function (param) { return pp_close_tag(state, 0) }, _mj_);
    for (; ;) {
      if (1 < state[14]) { pp_close_box(state, 0); continue }
      state[13] = pp_infinity;
      advance_left(state);
      if (b) pp_output_newline(state);
      return pp_rinit(state)
    }
  }
  function pp_print_as_size(state, size, s) {
    var _mi_ = state[14] < state[15] ? 1 : 0;
    return _mi_ ? enqueue_string_as(state, size, s) : _mi_
  }
  function pp_print_as(state, isize, s) { return pp_print_as_size(state, isize, s) }
  function pp_print_string(state, s) { return pp_print_as(state, caml_ml_string_length(s), s) }
  function pp_print_bytes(state, s) { return pp_print_as(state, caml_ml_bytes_length(s), of_bytes(s)) }
  function pp_print_int(state, i) { return pp_print_string(state, caml_string_of_jsbytes("" + i)) }
  function pp_print_float(state, f) { return pp_print_string(state, to_string(f)) }
  function pp_print_bool(state, b) { return pp_print_string(state, string_of_bool(b)) }
  function pp_print_char(state, c) { return pp_print_as(state, 1, make$1(1, c)) }
  function pp_open_hbox(state, param) { return pp_open_box_gen(state, 0, 0) }
  function pp_open_vbox(state, indent) { return pp_open_box_gen(state, indent, 1) }
  function pp_open_hvbox(state, indent) { return pp_open_box_gen(state, indent, 2) }
  function pp_open_hovbox(state, indent) { return pp_open_box_gen(state, indent, 3) }
  function pp_open_box(state, indent) { return pp_open_box_gen(state, indent, 4) }
  function pp_print_newline(state, param) { pp_flush_queue(state, 1); return caml_call1(state[18], 0) }
  function pp_print_flush(state, param) { pp_flush_queue(state, 0); return caml_call1(state[18], 0) }
  function pp_force_newline(state, param) {
    var _mh_ = state[14] < state[15] ? 1 : 0;
    return _mh_ ? enqueue_advance(state, [0, size, 3, 0]) : _mh_
  }
  function pp_print_if_newline(state, param) {
    var _mg_ = state[14] < state[15] ? 1 : 0;
    return _mg_ ? enqueue_advance(state, [0, size, 4, 0]) : _mg_
  }
  function pp_print_custom_break(state, fits, breaks) {
    var
    after = fits[3],
    width = fits[2],
    before = fits[1],
    _mf_ = state[14] < state[15] ? 1 : 0;
    if (!_mf_) return _mf_;
    var
      size = - state[13] | 0,
      token = [1, fits, breaks],
      length =
        (caml_ml_string_length(before) + width | 0)
        +
        caml_ml_string_length(after)
        |
        0,
      elem = [0, size, token, length];
    return scan_push(state, 1, elem)
  }
  function pp_print_break(state, width, offset) {
    return pp_print_custom_break
      (state, [0, cst$75, width, cst$74], [0, cst$73, offset, cst$72])
  }
  function pp_print_space(state, param) { return pp_print_break(state, 1, 0) }
  function pp_print_cut(state, param) { return pp_print_break(state, 0, 0) }
  function pp_open_tbox(state, param) {
    state[14] = state[14] + 1 | 0;
    var _me_ = state[14] < state[15] ? 1 : 0;
    if (!_me_) return _me_;
    var elem = [0, size, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem)
  }
  function pp_close_tbox(state, param) {
    var _mb_ = 1 < state[14] ? 1 : 0;
    if (_mb_) {
      var _mc_ = state[14] < state[15] ? 1 : 0;
      if (_mc_) {
        var elem = [0, size, 2, 0];
        enqueue_advance(state, elem);
        state[14] = state[14] - 1 | 0;
        var _md_ = 0
      }
      else
        var _md_ = _mc_
    }
    else
      var _md_ = _mb_;
    return _md_
  }
  function pp_print_tbreak(state, width, offset) {
    var _ma_ = state[14] < state[15] ? 1 : 0;
    if (!_ma_) return _ma_;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem)
  }
  function pp_print_tab(state, param) { return pp_print_tbreak(state, 0, 0) }
  function pp_set_tab(state, param) {
    var _l$_ = state[14] < state[15] ? 1 : 0;
    if (!_l$_) return _l$_;
    var elem = [0, size, 0, 0];
    return enqueue_advance(state, elem)
  }
  function pp_set_max_boxes(state, n) { var _l9_ = 1 < n ? 1 : 0, _l__ = _l9_ ? (state[15] = n, 0) : _l9_; return _l__ }
  function pp_get_max_boxes(state, param) { return state[15] }
  function pp_over_max_boxes(state, param) { return state[14] === state[15] ? 1 : 0 }
  function pp_set_ellipsis_text(state, s) { state[16] = s; return 0 }
  function pp_get_ellipsis_text(state, param) { return state[16] }
  function pp_limit(n) { return n < 1000000010 ? n : 1000000009 }
  function pp_set_max_indent(state, n$0) {
    var _l8_ = 1 < n$0 ? 1 : 0;
    if (!_l8_) return _l8_;
    var n$1 = state[6] - n$0 | 0, _l7_ = 1 <= n$1 ? 1 : 0;
    if (!_l7_) return _l7_;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state)
  }
  function pp_get_max_indent(state, param) { return state[8] }
  function pp_set_margin(state, n) {
    var _l6_ = 1 <= n ? 1 : 0;
    if (!_l6_) return _l6_;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    var
      new_max_indent =
        state[8] <= state[6]
          ? state[8]
          : max$1(max$1(state[6] - state[7] | 0, state[6] / 2 | 0), 1);
    return pp_set_max_indent(state, new_max_indent)
  }
  function validate_geometry(param) {
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent ? margin <= max_indent ? _cl_ : _cm_ : _cn_
  }
  function check_geometry(geometry) { var match = validate_geometry(geometry); return 0 === match[0] ? 1 : 0 }
  function pp_get_margin(state, param) { return state[6] }
  function pp_set_full_geometry(state, param) {
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0
  }
  function pp_set_geometry(state, max_indent, margin) {
    var geometry = [0, max_indent, margin], match = validate_geometry(geometry);
    if (0 === match[0]) return pp_set_full_geometry(state, geometry);
    var msg = match[1];
    throw [0, Invalid_argument, cat(cst_Format_pp_set_geometry, msg)]
  }
  function pp_safe_set_geometry(state, max_indent, margin) {
    var geometry = [0, max_indent, margin], match = validate_geometry(geometry);
    return 0 === match[0] ? pp_set_full_geometry(state, geometry) : 0
  }
  function pp_get_geometry(state, param) { return [0, state[8], state[6]] }
  function pp_update_geometry(state, update) {
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry))
  }
  function pp_set_formatter_out_functions(state, param) {
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0
  }
  function pp_get_formatter_out_functions(state, param) { return [0, state[17], state[18], state[19], state[20], state[21]] }
  function pp_set_formatter_output_functi(state, f, g) { state[17] = f; state[18] = g; return 0 }
  function pp_get_formatter_output_functi(state, param) { return [0, state[17], state[18]] }
  function display_newline(state, param) { return caml_call3(state[17], cst$76, 0, 1) }
  var blank_line = make$1(80, 32);
  function display_indent(state, n) {
    var n$0 = n;
    for (; ;) {
      var _l5_ = 0 < n$0 ? 1 : 0;
      if (!_l5_) return _l5_;
      if (80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
      caml_call3(state[17], blank_line, 0, 80);
      var n$1 = n$0 - 80 | 0, n$0 = n$1
    }
  }
  function pp_set_formatter_out_channel(state, oc) {
    state[17]
    =
    function (_l2_, _l3_, _l4_) { return output_substring(oc, _l2_, _l3_, _l4_) };
    state[18] = function (param) { return caml_ml_flush(oc) };
    state[19] = function (_l1_) { return display_newline(state, _l1_) };
    state[20] = function (_l0_) { return display_indent(state, _l0_) };
    state[21] = function (_lZ_) { return display_indent(state, _lZ_) };
    return 0
  }
  function default_pp_mark_open_tag(param) {
    if (param[1] !== String_tag) return cst$79;
    var s = param[2];
    return cat(cst$78, cat(s, cst$77))
  }
  function default_pp_mark_close_tag(param) {
    if (param[1] !== String_tag) return cst$82;
    var s = param[2];
    return cat(cst$81, cat(s, cst$80))
  }
  function default_pp_print_open_tag(_lY_) { return 0 }
  function default_pp_print_close_tag(_lX_) { return 0 }
  function pp_make_formatter(f, g, h, i, j) {
    var pp_queue = create$1(0), sys_tok = [0, unknown, _co_, 0];
    add(sys_tok, pp_queue);
    var scan_stack = create$0(0);
    initialize_scan_stack(scan_stack);
    push([0, 1, sys_tok], scan_stack);
    var _lU_ = create$0(0), _lV_ = create$0(0), _lW_ = create$0(0);
    return [0,
      scan_stack,
      create$0(0),
      _lW_,
      _lV_,
      _lU_,
      78,
      10,
      68,
      78,
      0,
      1,
      1,
      1,
      1,
      max_int,
      cst$83,
      f,
      g,
      h,
      i,
      j,
      0,
      0,
      default_pp_mark_open_tag,
      default_pp_mark_close_tag,
      default_pp_print_open_tag,
      default_pp_print_close_tag,
      pp_queue]
  }
  function formatter_of_out_functions(out_funs) {
    return pp_make_formatter
      (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5])
  }
  function make_formatter(output, flush) {
    function _lM_(_lT_) { return 0 }
    function _lN_(_lS_) { return 0 }
    var
      ppf =
        pp_make_formatter(output, flush, function (_lR_) { return 0 }, _lN_, _lM_);
    ppf[19] = function (_lQ_) { return display_newline(ppf, _lQ_) };
    ppf[20] = function (_lP_) { return display_indent(ppf, _lP_) };
    ppf[21] = function (_lO_) { return display_indent(ppf, _lO_) };
    return ppf
  }
  function formatter_of_out_channel(oc) {
    function _lI_(param) { return caml_ml_flush(oc) }
    return make_formatter
      (function (_lJ_, _lK_, _lL_) { return output_substring(oc, _lJ_, _lK_, _lL_) },
        _lI_)
  }
  function formatter_of_buffer(b) {
    function _lD_(_lH_) { return 0 }
    return make_formatter
      (function (_lE_, _lF_, _lG_) { return add_substring(b, _lE_, _lF_, _lG_) },
        _lD_)
  }
  var pp_buffer_size = 512;
  function pp_make_buffer(param) { return create$2(pp_buffer_size) }
  var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(stdout),
    err_formatter = formatter_of_out_channel(stderr),
    str_formatter = formatter_of_buffer(stdbuf);
  function flush_buffer_formatter(buf, ppf) { pp_flush_queue(ppf, 0); var s = contents(buf); reset(buf); return s }
  function flush_str_formatter(param) { return flush_buffer_formatter(stdbuf, str_formatter) }
  function make_symbolic_output_buffer(param) { return [0, 0] }
  function clear_symbolic_output_buffer(sob) { sob[1] = 0; return 0 }
  function get_symbolic_output_buffer(sob) { return rev(sob[1]) }
  function flush_symbolic_output_buffer(sob) {
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items
  }
  function add_symbolic_output_item(sob, item) { sob[1] = [0, item, sob[1]]; return 0 }
  function formatter_of_symbolic_output_b(sob) {
    function f(s, i, n) { return add_symbolic_output_item(sob, [0, sub$0(s, i, n)]) }
    function g(_lC_) { return add_symbolic_output_item(sob, 0) }
    function h(_lB_) { return add_symbolic_output_item(sob, 1) }
    function i(n) { return add_symbolic_output_item(sob, [1, n]) }
    function j(n) { return add_symbolic_output_item(sob, [2, n]) }
    return pp_make_formatter(f, g, h, i, j)
  }
  function open_hbox(_lA_) { return pp_open_hbox(std_formatter, _lA_) }
  function open_vbox(_lz_) { return pp_open_vbox(std_formatter, _lz_) }
  function open_hvbox(_ly_) { return pp_open_hvbox(std_formatter, _ly_) }
  function open_hovbox(_lx_) { return pp_open_hovbox(std_formatter, _lx_) }
  function open_box(_lw_) { return pp_open_box(std_formatter, _lw_) }
  function close_box(_lv_) { return pp_close_box(std_formatter, _lv_) }
  function open_tag(_lu_) { return pp_open_tag(std_formatter, _lu_) }
  function close_tag(_lt_) { return pp_close_tag(std_formatter, _lt_) }
  function open_stag(_ls_) { return pp_open_stag(std_formatter, _ls_) }
  function close_stag(_lr_) { return pp_close_stag(std_formatter, _lr_) }
  function print_as(_lp_, _lq_) { return pp_print_as(std_formatter, _lp_, _lq_) }
  function print_string$0(_lo_) { return pp_print_string(std_formatter, _lo_) }
  function print_bytes$0(_ln_) { return pp_print_bytes(std_formatter, _ln_) }
  function print_int$0(_lm_) { return pp_print_int(std_formatter, _lm_) }
  function print_float$0(_ll_) { return pp_print_float(std_formatter, _ll_) }
  function print_char$0(_lk_) { return pp_print_char(std_formatter, _lk_) }
  function print_bool(_lj_) { return pp_print_bool(std_formatter, _lj_) }
  function print_break(_lh_, _li_) { return pp_print_break(std_formatter, _lh_, _li_) }
  function print_cut(_lg_) { return pp_print_cut(std_formatter, _lg_) }
  function print_space(_lf_) { return pp_print_space(std_formatter, _lf_) }
  function force_newline(_le_) { return pp_force_newline(std_formatter, _le_) }
  function print_flush(_ld_) { return pp_print_flush(std_formatter, _ld_) }
  function print_newline$0(_lc_) { return pp_print_newline(std_formatter, _lc_) }
  function print_if_newline(_lb_) { return pp_print_if_newline(std_formatter, _lb_) }
  function open_tbox(_la_) { return pp_open_tbox(std_formatter, _la_) }
  function close_tbox(_k$_) { return pp_close_tbox(std_formatter, _k$_) }
  function print_tbreak(_k9_, _k__) { return pp_print_tbreak(std_formatter, _k9_, _k__) }
  function set_tab(_k8_) { return pp_set_tab(std_formatter, _k8_) }
  function print_tab(_k7_) { return pp_print_tab(std_formatter, _k7_) }
  function set_margin(_k6_) { return pp_set_margin(std_formatter, _k6_) }
  function get_margin(_k5_) { return std_formatter[6] }
  function set_max_indent(_k4_) { return pp_set_max_indent(std_formatter, _k4_) }
  function get_max_indent(_k3_) { return std_formatter[8] }
  function set_geometry(_k1_, _k2_) { return pp_set_geometry(std_formatter, _k1_, _k2_) }
  function safe_set_geometry(_kZ_, _k0_) { return pp_safe_set_geometry(std_formatter, _kZ_, _k0_) }
  function get_geometry(_kY_) { return pp_get_geometry(std_formatter, _kY_) }
  function update_geometry(_kX_) { return pp_update_geometry(std_formatter, _kX_) }
  function set_max_boxes(_kW_) { return pp_set_max_boxes(std_formatter, _kW_) }
  function get_max_boxes(_kV_) { return std_formatter[15] }
  function over_max_boxes(_kU_) { return pp_over_max_boxes(std_formatter, _kU_) }
  function set_ellipsis_text(_kT_) { return pp_set_ellipsis_text(std_formatter, _kT_) }
  function get_ellipsis_text(_kS_) { return std_formatter[16] }
  function set_formatter_out_channel(_kR_) { return pp_set_formatter_out_channel(std_formatter, _kR_) }
  function set_formatter_out_functions(_kQ_) { return pp_set_formatter_out_functions(std_formatter, _kQ_) }
  function get_formatter_out_functions(_kP_) { return pp_get_formatter_out_functions(std_formatter, _kP_) }
  function set_formatter_output_functions(_kN_, _kO_) { return pp_set_formatter_output_functi(std_formatter, _kN_, _kO_) }
  function get_formatter_output_functions(_kM_) { return pp_get_formatter_output_functi(std_formatter, _kM_) }
  function set_formatter_stag_functions(_kL_) { return pp_set_formatter_stag_function(std_formatter, _kL_) }
  function get_formatter_stag_functions(_kK_) { return pp_get_formatter_stag_function(std_formatter, _kK_) }
  function set_print_tags(_kJ_) { return pp_set_print_tags(std_formatter, _kJ_) }
  function get_print_tags(_kI_) { return std_formatter[22] }
  function set_mark_tags(_kH_) { return pp_set_mark_tags(std_formatter, _kH_) }
  function get_mark_tags(_kG_) { return std_formatter[23] }
  function set_tags(_kF_) { return pp_set_tags(std_formatter, _kF_) }
  function pp_print_list(opt, pp_v, ppf, param) {
    var opt$0 = opt, param$0 = param;
    for (; ;) {
      if (opt$0) var sth = opt$0[1], pp_sep = sth; else var pp_sep = pp_print_cut;
      if (!param$0) return 0;
      var _kE_ = param$0[1];
      if (!param$0[2]) return caml_call2(pp_v, ppf, _kE_);
      var vs = param$0[2];
      caml_call2(pp_v, ppf, _kE_);
      caml_call2(pp_sep, ppf, 0);
      var opt$1 = [0, pp_sep], opt$0 = opt$1, param$0 = vs
    }
  }
  function pp_print_seq(opt, pp_v, ppf, seq$1) {
    if (opt) var sth = opt[1], pp_sep = sth; else var pp_sep = pp_print_cut;
    var match$0 = caml_call1(seq$1, 0);
    if (!match$0) return 0;
    var seq$2 = match$0[2], v$0 = match$0[1];
    caml_call2(pp_v, ppf, v$0);
    var seq = seq$2;
    for (; ;) {
      var match = caml_call1(seq, 0);
      if (!match) return 0;
      var seq$0 = match[2], v = match[1];
      caml_call2(pp_sep, ppf, 0);
      caml_call2(pp_v, ppf, v);
      var seq = seq$0
    }
  }
  function pp_print_text(ppf, s) {
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param) {
      pp_print_string(ppf, sub$0(s, left[1], right[1] - left[1] | 0));
      right[1]++;
      left[1] = right[1];
      return 0
    }
    for (; ;) {
      if (right[1] === len) { var _kD_ = left[1] !== len ? 1 : 0; return _kD_ ? flush(0) : _kD_ }
      var match = caml_string_get(s, right[1]);
      if (10 === match) { flush(0); pp_force_newline(ppf, 0) }
      else
        if (32 === match) { flush(0); pp_print_space(ppf, 0) } else right[1]++
    }
  }
  function pp_print_option(opt, pp_v, ppf, param) {
    if (opt)
      var sth = opt[1], none = sth;
    else
      var none = function (param, _kC_) { return 0 };
    if (!param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v)
  }
  function pp_print_result(ok, error, ppf, param) {
    if (0 === param[0]) { var v = param[1]; return caml_call2(ok, ppf, v) }
    var e = param[1];
    return caml_call2(error, ppf, e)
  }
  function pp_print_either(left, right, ppf, param) {
    if (0 === param[0]) { var l = param[1]; return caml_call2(left, ppf, l) }
    var r = param[1];
    return caml_call2(right, ppf, r)
  }
  function compute_tag(output, tag_acc) {
    var buf = create$2(16), ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = buf[2];
    return 2 <= len ? sub$3(buf, 1, len - 2 | 0) : contents(buf)
  }
  function output_formatting_lit(ppf, fmting_lit) {
    if (typeof fmting_lit === "number")
      switch (fmting_lit) {
        case 0: return pp_close_box(ppf, 0);
        case 1: return pp_close_tag(ppf, 0);
        case 2: return pp_print_flush(ppf, 0);
        case 3: return pp_force_newline(ppf, 0);
        case 4: return pp_print_newline(ppf, 0);
        case 5: return pp_print_char(ppf, 64);
        default: return pp_print_char(ppf, 37)
      }
    switch (fmting_lit[0]) {
      case 0:
        var offset = fmting_lit[3], width = fmting_lit[2];
        return pp_print_break(ppf, width, offset);
      case 1: return 0;
      default:
        var c = fmting_lit[1]; pp_print_char(ppf, 64); return pp_print_char(ppf, c)
    }
  }
  function output_acc$0(ppf, acc) {
    var switch$0 = 0;
    if (typeof acc === "number") return 0;
    switch (acc[0]) {
      case 0:
        var f = acc[2], p = acc[1];
        output_acc$0(ppf, p);
        return output_formatting_lit(ppf, f);
      case 1:
        var _ks_ = acc[2], _kt_ = acc[1];
        if (0 === _ks_[0]) {
          var acc$0 = _ks_[1];
          output_acc$0(ppf, _kt_);
          return pp_open_stag
            (ppf, [0, String_tag, compute_tag(output_acc$0, acc$0)])
        }
        var acc$1 = _ks_[1];
        output_acc$0(ppf, _kt_);
        var
          match = open_box_of_string(compute_tag(output_acc$0, acc$1)),
          bty = match[2],
          indent = match[1];
        return pp_open_box_gen(ppf, indent, bty);
      case 2:
        var _ku_ = acc[1], switch$1 = 0;
        if (typeof _ku_ !== "number" && 0 === _ku_[0]) {
          var _kv_ = _ku_[2], switch$2 = 0;
          if (typeof _kv_ !== "number" && 1 === _kv_[0]) {
            var s$0 = acc[2], size = _kv_[2], p$1 = _ku_[1];
            switch$1 = 1;
            switch$2 = 1
          }
        }
        if (!switch$1) { var s = acc[2], p$0 = _ku_; switch$0 = 2 }
        break;
      case 3:
        var _kw_ = acc[1], switch$3 = 0;
        if (typeof _kw_ !== "number" && 0 === _kw_[0]) {
          var _kx_ = _kw_[2], switch$4 = 0;
          if (typeof _kx_ !== "number" && 1 === _kx_[0]) {
            var c$0 = acc[2], size$0 = _kx_[2], p$3 = _kw_[1];
            switch$0 = 1;
            switch$3 = 1;
            switch$4 = 1
          }
        }
        if (!switch$3) { var c = acc[2], p$2 = _kw_; switch$0 = 3 }
        break;
      case 4:
        var _ky_ = acc[1], switch$5 = 0;
        if (typeof _ky_ !== "number" && 0 === _ky_[0]) {
          var _kz_ = _ky_[2], switch$6 = 0;
          if (typeof _kz_ !== "number" && 1 === _kz_[0]) {
            var s$0 = acc[2], size = _kz_[2], p$1 = _ky_[1];
            switch$5 = 1;
            switch$6 = 1
          }
        }
        if (!switch$5) { var s = acc[2], p$0 = _ky_; switch$0 = 2 }
        break;
      case 5:
        var _kA_ = acc[1], switch$7 = 0;
        if (typeof _kA_ === "number" || !(0 === _kA_[0]))
          switch$7 = 1;
        else {
          var _kB_ = _kA_[2], switch$8 = 0;
          if (typeof _kB_ !== "number" && 1 === _kB_[0]) {
            var c$0 = acc[2], size$0 = _kB_[2], p$3 = _kA_[1];
            switch$0 = 1;
            switch$8 = 1
          }
          if (!switch$8) switch$7 = 1
        }
        if (switch$7) { var c = acc[2], p$2 = _kA_; switch$0 = 3 }
        break;
      case 6:
        var f$0 = acc[2], p$4 = acc[1];
        output_acc$0(ppf, p$4);
        return caml_call1(f$0, ppf);
      case 7:
        var p$5 = acc[1]; output_acc$0(ppf, p$5); return pp_print_flush(ppf, 0);
      default:
        var msg = acc[2], p$6 = acc[1];
        output_acc$0(ppf, p$6);
        return invalid_arg(msg)
    }
    switch (switch$0) {
      case 0: output_acc$0(ppf, p$1); return pp_print_as_size(ppf, size, s$0);
      case 1:
        output_acc$0(ppf, p$3);
        return pp_print_as_size(ppf, size$0, make$1(1, c$0));
      case 2: output_acc$0(ppf, p$0); return pp_print_string(ppf, s);
      default: output_acc$0(ppf, p$2); return pp_print_char(ppf, c)
    }
  }
  function strput_acc$0(ppf, acc) {
    var switch$0 = 0;
    if (typeof acc === "number") return 0;
    switch (acc[0]) {
      case 0:
        var f = acc[2], p = acc[1];
        strput_acc$0(ppf, p);
        return output_formatting_lit(ppf, f);
      case 1:
        var _kg_ = acc[2], _kh_ = acc[1];
        if (0 === _kg_[0]) {
          var acc$0 = _kg_[1];
          strput_acc$0(ppf, _kh_);
          return pp_open_stag
            (ppf, [0, String_tag, compute_tag(strput_acc$0, acc$0)])
        }
        var acc$1 = _kg_[1];
        strput_acc$0(ppf, _kh_);
        var
          match = open_box_of_string(compute_tag(strput_acc$0, acc$1)),
          bty = match[2],
          indent = match[1];
        return pp_open_box_gen(ppf, indent, bty);
      case 2:
        var _ki_ = acc[1], switch$1 = 0;
        if (typeof _ki_ !== "number" && 0 === _ki_[0]) {
          var _kj_ = _ki_[2], switch$2 = 0;
          if (typeof _kj_ !== "number" && 1 === _kj_[0]) {
            var s$0 = acc[2], size = _kj_[2], p$1 = _ki_[1];
            switch$1 = 1;
            switch$2 = 1
          }
        }
        if (!switch$1) { var s = acc[2], p$0 = _ki_; switch$0 = 2 }
        break;
      case 3:
        var _kk_ = acc[1], switch$3 = 0;
        if (typeof _kk_ !== "number" && 0 === _kk_[0]) {
          var _kl_ = _kk_[2], switch$4 = 0;
          if (typeof _kl_ !== "number" && 1 === _kl_[0]) {
            var c$0 = acc[2], size$0 = _kl_[2], p$3 = _kk_[1];
            switch$0 = 1;
            switch$3 = 1;
            switch$4 = 1
          }
        }
        if (!switch$3) { var c = acc[2], p$2 = _kk_; switch$0 = 3 }
        break;
      case 4:
        var _km_ = acc[1], switch$5 = 0;
        if (typeof _km_ !== "number" && 0 === _km_[0]) {
          var _kn_ = _km_[2], switch$6 = 0;
          if (typeof _kn_ !== "number" && 1 === _kn_[0]) {
            var s$0 = acc[2], size = _kn_[2], p$1 = _km_[1];
            switch$5 = 1;
            switch$6 = 1
          }
        }
        if (!switch$5) { var s = acc[2], p$0 = _km_; switch$0 = 2 }
        break;
      case 5:
        var _ko_ = acc[1], switch$7 = 0;
        if (typeof _ko_ === "number" || !(0 === _ko_[0]))
          switch$7 = 1;
        else {
          var _kp_ = _ko_[2], switch$8 = 0;
          if (typeof _kp_ !== "number" && 1 === _kp_[0]) {
            var c$0 = acc[2], size$0 = _kp_[2], p$3 = _ko_[1];
            switch$0 = 1;
            switch$8 = 1
          }
          if (!switch$8) switch$7 = 1
        }
        if (switch$7) { var c = acc[2], p$2 = _ko_; switch$0 = 3 }
        break;
      case 6:
        var _kq_ = acc[1];
        if (typeof _kq_ !== "number" && 0 === _kq_[0]) {
          var _kr_ = _kq_[2];
          if (typeof _kr_ !== "number" && 1 === _kr_[0]) {
            var f$1 = acc[2], size$1 = _kr_[2], p$4 = _kq_[1];
            strput_acc$0(ppf, p$4);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0))
          }
        }
        var f$0 = acc[2];
        strput_acc$0(ppf, _kq_);
        return pp_print_string(ppf, caml_call1(f$0, 0));
      case 7:
        var p$5 = acc[1]; strput_acc$0(ppf, p$5); return pp_print_flush(ppf, 0);
      default:
        var msg = acc[2], p$6 = acc[1];
        strput_acc$0(ppf, p$6);
        return invalid_arg(msg)
    }
    switch (switch$0) {
      case 0: strput_acc$0(ppf, p$1); return pp_print_as_size(ppf, size, s$0);
      case 1:
        strput_acc$0(ppf, p$3);
        return pp_print_as_size(ppf, size$0, make$1(1, c$0));
      case 2: strput_acc$0(ppf, p$0); return pp_print_string(ppf, s);
      default: strput_acc$0(ppf, p$2); return pp_print_char(ppf, c)
    }
  }
  function kfprintf$0(k, ppf, param) {
    var fmt = param[1], _kf_ = 0;
    return make_printf
      (function (acc) { output_acc$0(ppf, acc); return caml_call1(k, ppf) },
        _kf_,
        fmt)
  }
  function ikfprintf$0(k, ppf, param) { var fmt = param[1]; return make_iprintf(k, ppf, fmt) }
  function ifprintf$0(ppf, param) {
    var fmt = param[1], _kd_ = 0;
    return make_iprintf(function (_ke_) { return 0 }, _kd_, fmt)
  }
  function fprintf$0(ppf) {
    function _ka_(_kc_) { return 0 }
    return function (_kb_) { return kfprintf$0(_ka_, ppf, _kb_) }
  }
  function printf$0(fmt) { return caml_call1(fprintf$0(std_formatter), fmt) }
  function eprintf$0(fmt) { return caml_call1(fprintf$0(err_formatter), fmt) }
  function kdprintf(k, param) {
    var fmt = param[1], _j$_ = 0;
    return make_printf
      (function (acc) {
        return caml_call1
          (k, function (ppf) { return output_acc$0(ppf, acc) })
      },
        _j$_,
        fmt)
  }
  function dprintf(fmt) { return kdprintf(function (i) { return i }, fmt) }
  function kprintf(k, param) {
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc) {
      strput_acc$0(ppf, acc);
      return caml_call1(k, flush_buffer_formatter(b, ppf))
    }
    return make_printf(k$0, 0, fmt)
  }
  function sprintf$0(fmt) { return kprintf(id$0, fmt) }
  function kasprintf(k, param) {
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc) {
      output_acc$0(ppf, acc);
      return caml_call1(k, flush_buffer_formatter(b, ppf))
    }
    return make_printf(k$0, 0, fmt)
  }
  function asprintf(fmt) { return kasprintf(id$0, fmt) }
  function flush_standard_formatters(param) { pp_print_flush(std_formatter, 0); return pp_print_flush(err_formatter, 0) }
  at_exit(flush_standard_formatters);
  function pp_set_all_formatter_output_fu(state, f, g, h, i) {
    pp_set_formatter_output_functi(state, f, g);
    state[19] = h;
    state[20] = i;
    return 0
  }
  function pp_get_all_formatter_output_fu(state, param) { return [0, state[17], state[18], state[19], state[20]] }
  function set_all_formatter_output_funct(_j7_, _j8_, _j9_, _j__) { return pp_set_all_formatter_output_fu(std_formatter, _j7_, _j8_, _j9_, _j__) }
  function get_all_formatter_output_funct(_j6_) { return pp_get_all_formatter_output_fu(std_formatter, _j6_) }
  function bprintf$0(b, param) {
    var fmt = param[1], ppf = formatter_of_buffer(b);
    function k(acc) { output_acc$0(ppf, acc); return pp_flush_queue(ppf, 0) }
    return make_printf(k, 0, fmt)
  }
  function pp_set_formatter_tag_functions(state, param) {
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    function stringify(f, e, param) {
      if (param[1] !== String_tag) return e;
      var s = param[2];
      return caml_call1(f, s)
    }
    state[24] = function (_j5_) { return stringify(mot, cst$84, _j5_) };
    state[25] = function (_j4_) { return stringify(mct, cst$85, _j4_) };
    var _j0_ = 0;
    state[26] = function (_j3_) { return stringify(pot, _j0_, _j3_) };
    var _j1_ = 0;
    state[27] = function (_j2_) { return stringify(pct, _j1_, _j2_) };
    return 0
  }
  function pp_get_formatter_tag_functions(fmt, param) {
    var funs = pp_get_formatter_stag_function(fmt, 0);
    function mark_open_tag(s) { return caml_call1(funs[1], [0, String_tag, s]) }
    function mark_close_tag(s) { return caml_call1(funs[2], [0, String_tag, s]) }
    function print_open_tag(s) { return caml_call1(funs[3], [0, String_tag, s]) }
    function print_close_tag(s) { return caml_call1(funs[4], [0, String_tag, s]) }
    return [0, mark_open_tag, mark_close_tag, print_open_tag, print_close_tag]
  }
  function set_formatter_tag_functions(_jZ_) { return pp_set_formatter_tag_functions(std_formatter, _jZ_) }
  function get_formatter_tag_functions(_jY_) { return pp_get_formatter_tag_functions(std_formatter, _jY_) }
  var
    Stdlib_Format =
      [0,
        pp_open_box,
        open_box,
        pp_close_box,
        close_box,
        pp_open_hbox,
        open_hbox,
        pp_open_vbox,
        open_vbox,
        pp_open_hvbox,
        open_hvbox,
        pp_open_hovbox,
        open_hovbox,
        pp_print_string,
        print_string$0,
        pp_print_bytes,
        print_bytes$0,
        pp_print_as,
        print_as,
        pp_print_int,
        print_int$0,
        pp_print_float,
        print_float$0,
        pp_print_char,
        print_char$0,
        pp_print_bool,
        print_bool,
        pp_print_space,
        print_space,
        pp_print_cut,
        print_cut,
        pp_print_break,
        print_break,
        pp_print_custom_break,
        pp_force_newline,
        force_newline,
        pp_print_if_newline,
        print_if_newline,
        pp_print_flush,
        print_flush,
        pp_print_newline,
        print_newline$0,
        pp_set_margin,
        set_margin,
        pp_get_margin,
        get_margin,
        pp_set_max_indent,
        set_max_indent,
        pp_get_max_indent,
        get_max_indent,
        check_geometry,
        pp_set_geometry,
        set_geometry,
        pp_safe_set_geometry,
        safe_set_geometry,
        pp_update_geometry,
        update_geometry,
        pp_get_geometry,
        get_geometry,
        pp_set_max_boxes,
        set_max_boxes,
        pp_get_max_boxes,
        get_max_boxes,
        pp_over_max_boxes,
        over_max_boxes,
        pp_open_tbox,
        open_tbox,
        pp_close_tbox,
        close_tbox,
        pp_set_tab,
        set_tab,
        pp_print_tab,
        print_tab,
        pp_print_tbreak,
        print_tbreak,
        pp_set_ellipsis_text,
        set_ellipsis_text,
        pp_get_ellipsis_text,
        get_ellipsis_text,
        String_tag,
        pp_open_stag,
        open_stag,
        pp_close_stag,
        close_stag,
        pp_set_tags,
        set_tags,
        pp_set_print_tags,
        set_print_tags,
        pp_set_mark_tags,
        set_mark_tags,
        pp_get_print_tags,
        get_print_tags,
        pp_get_mark_tags,
        get_mark_tags,
        pp_set_formatter_out_channel,
        set_formatter_out_channel,
        pp_set_formatter_output_functi,
        set_formatter_output_functions,
        pp_get_formatter_output_functi,
        get_formatter_output_functions,
        pp_set_formatter_out_functions,
        set_formatter_out_functions,
        pp_get_formatter_out_functions,
        get_formatter_out_functions,
        pp_set_formatter_stag_function,
        set_formatter_stag_functions,
        pp_get_formatter_stag_function,
        get_formatter_stag_functions,
        formatter_of_out_channel,
        std_formatter,
        err_formatter,
        formatter_of_buffer,
        stdbuf,
        str_formatter,
        flush_str_formatter,
        make_formatter,
        formatter_of_out_functions,
        make_symbolic_output_buffer,
        clear_symbolic_output_buffer,
        get_symbolic_output_buffer,
        flush_symbolic_output_buffer,
        add_symbolic_output_item,
        formatter_of_symbolic_output_b,
        pp_print_list,
        pp_print_seq,
        pp_print_text,
        pp_print_option,
        pp_print_result,
        pp_print_either,
        fprintf$0,
        printf$0,
        eprintf$0,
        sprintf$0,
        asprintf,
        dprintf,
        ifprintf$0,
        kfprintf$0,
        kdprintf,
        ikfprintf$0,
        kprintf,
        kasprintf,
        bprintf$0,
        kprintf,
        set_all_formatter_output_funct,
        get_all_formatter_output_funct,
        pp_set_all_formatter_output_fu,
        pp_get_all_formatter_output_fu,
        pp_open_tag,
        open_tag,
        pp_close_tag,
        close_tag,
        pp_set_formatter_tag_functions,
        set_formatter_tag_functions,
        pp_get_formatter_tag_functions,
        get_formatter_tag_functions];
  caml_register_global(818, Stdlib_Format, "Stdlib__Format");
  var null_char = 0;
  function next_char(ib) {
    try {
      var c = caml_call1(ib[7], 0);
      ib[2] = c;
      ib[3] = 1;
      ib[4] = ib[4] + 1 | 0;
      if (10 === c) ib[5] = ib[5] + 1 | 0;
      return c
    }
    catch (_jX_) {
      _jX_ = caml_wrap_exception(_jX_);
      if (_jX_ !== End_of_file) throw _jX_;
      ib[2] = null_char;
      ib[3] = 0;
      ib[1] = 1;
      return null_char
    }
  }
  function peek_char(ib) { return ib[3] ? ib[2] : next_char(ib) }
  function checked_peek_char(ib) { var c = peek_char(ib); if (ib[1]) throw End_of_file; return c }
  function end_of_input(ib) { peek_char(ib); return ib[1] }
  function beginning_of_input(ib) { return 0 === ib[4] ? 1 : 0 }
  function name_of_input(ib) {
    var _jW_ = ib[9];
    if (typeof _jW_ === "number")
      return 0 === _jW_ ? cst_unnamed_function : cst_unnamed_character_string;
    if (0 === _jW_[0]) return cst_unnamed_Stdlib_input_chann;
    var fname = _jW_[1];
    return fname
  }
  function char_count(ib) { return ib[3] ? ib[4] - 1 | 0 : ib[4] }
  function reset_token(ib) { return reset(ib[8]) }
  function invalidate_current_char(ib) { ib[3] = 0; return 0 }
  function token_string(ib) {
    var token_buffer = ib[8], tok = contents(token_buffer);
    clear$1(token_buffer);
    ib[6] = ib[6] + 1 | 0;
    return tok
  }
  function skip_char(width, ib) { invalidate_current_char(ib); return width }
  function ignore_char(width, ib) { return skip_char(width - 1 | 0, ib) }
  function store_char(width, ib, c) { add_char(ib[8], c); return ignore_char(width, ib) }
  var default_token_buffer_size = 1024;
  function create$4(iname, next) {
    return [0,
      0,
      null_char,
      0,
      0,
      0,
      0,
      next,
      create$2(default_token_buffer_size),
      iname]
  }
  function from_string$1(s) {
    var i = [0, 0], len = caml_ml_string_length(s);
    function next(param) {
      if (len <= i[1]) throw End_of_file;
      var c = caml_string_get(s, i[1]);
      i[1]++;
      return c
    }
    return create$4(1, next)
  }
  var _cp_ = 0;
  function from_function$0(_jV_) { return create$4(_cp_, _jV_) }
  var len = 1024;
  function scan_close_at_end(ic) { caml_ml_close_channel(ic); throw End_of_file }
  function scan_raise_at_end(ic) { throw End_of_file }
  function from_ic(scan_close_ic, iname, ic) {
    var buf = caml_create_bytes(1024), i = [0, 0], lim = [0, 0], eof = [0, 0];
    function next(param) {
      if (i[1] < lim[1]) { var c = caml_bytes_get(buf, i[1]); i[1]++; return c }
      if (eof[1]) throw End_of_file;
      lim[1] = input(ic, buf, 0, len);
      return 0 === lim[1]
        ? (eof[1] = 1, caml_call1(scan_close_ic, ic))
        : (i[1] = 1, caml_bytes_get(buf, 0))
    }
    return create$4(iname, next)
  }
  var stdib = from_ic(scan_raise_at_end, [1, cst$86, stdin], stdin);
  function open_in_file(open_in, fname) {
    if (!caml_string_notequal(fname, cst$87)) return stdib;
    var ic = caml_call1(open_in, fname);
    return from_ic(scan_close_at_end, [1, fname, ic], ic)
  }
  function from_file(_jU_) { return open_in_file(open_text$0, _jU_) }
  function from_file_bin(_jT_) { return open_in_file(open_bin$0, _jT_) }
  function from_channel$0(ic) { return from_ic(scan_raise_at_end, [0, ic], ic) }
  function close_in(ib) {
    var _jS_ = ib[9];
    if (typeof _jS_ === "number") return 0;
    if (0 === _jS_[0]) { var ic = _jS_[1]; return caml_ml_close_channel(ic) }
    var ic$0 = _jS_[2];
    return caml_ml_close_channel(ic$0)
  }
  var memo = [0, 0];
  function memo_from_ic(scan_close_ic, ic) {
    try { var _jQ_ = assq(ic, memo[1]); return _jQ_ }
    catch (_jR_) {
      _jR_ = caml_wrap_exception(_jR_);
      if (_jR_ !== Not_found) throw _jR_;
      var ib = from_ic(scan_close_ic, [0, ic], ic);
      memo[1] = [0, [0, ic, ib], memo[1]];
      return ib
    }
  }
  function memo_from_channel(_jP_) { return memo_from_ic(scan_raise_at_end, _jP_) }
  var Scan_failure = [248, cst_Stdlib_Scanf_Scan_failure, caml_fresh_oo_id(0)];
  function bad_input(s) { throw [0, Scan_failure, s] }
  function bad_input_escape(c) { return bad_input(caml_call1(sprintf(_cq_), c)) }
  function bad_token_length(message) { return bad_input(caml_call1(sprintf(_cr_), message)) }
  function bad_float(param) { return bad_input(cst_no_dot_or_exponent_part_fo) }
  function bad_hex_float(param) { return bad_input(cst_not_a_valid_float_in_hexad) }
  function character_mismatch(c, ci) { return bad_input(caml_call2(sprintf(_ct_), c, ci)) }
  function check_this_char(ib, c) {
    var ci = checked_peek_char(ib);
    return ci === c ? invalidate_current_char(ib) : character_mismatch(c, ci)
  }
  function check_char(ib, c$0) {
    if (10 === c$0) {
      var ci = checked_peek_char(ib);
      return 10 === ci
        ? invalidate_current_char(ib)
        : 13 === ci
          ? (invalidate_current_char(ib), check_this_char(ib, 10))
          : character_mismatch(10, ci)
    }
    if (32 !== c$0) return check_this_char(ib, c$0);
    for (; ;) {
      var c = peek_char(ib), _jN_ = 1 - ib[1];
      if (!_jN_) return _jN_;
      var _jO_ = c - 9 | 0, switch$0 = 0;
      if (4 < _jO_ >>> 0) { if (23 === _jO_) switch$0 = 1 }
      else
        if (1 < _jO_ - 2 >>> 0) switch$0 = 1;
      if (!switch$0) return 0;
      invalidate_current_char(ib)
    }
  }
  function token_char(ib) { return caml_string_get(token_string(ib), 0) }
  function token_bool(ib) {
    var s = token_string(ib);
    return caml_string_notequal(s, cst_false$3)
      ? caml_string_notequal(s, cst_true$3)
        ? bad_input(caml_call1(sprintf(_cu_), s))
        : 1
      : 0
  }
  function integer_conversion_of_char(param) {
    var switcher = param - 88 | 0;
    if (32 >= switcher >>> 0)
      switch (switcher) {
        case 10: return 0;
        case 12: return 1;
        case 17: return 2;
        case 23: return 3;
        case 29: return 4;
        case 0:
        case 32: return 5
      }
    throw [0, Assert_failure, _cv_]
  }
  function token_int_literal(conv, ib) {
    switch (conv) {
      case 0: var tok = cat(cst_0b, token_string(ib)); break;
      case 3: var tok = cat(cst_0o, token_string(ib)); break;
      case 4: var tok = cat(cst_0u, token_string(ib)); break;
      case 5: var tok = cat(cst_0x, token_string(ib)); break;
      default: var tok = token_string(ib)
    }
    var l = caml_ml_string_length(tok);
    if (0 !== l && 43 === caml_string_get(tok, 0))
      return sub$0(tok, 1, l - 1 | 0);
    return tok
  }
  function token_float(ib) { return caml_float_of_string(token_string(ib)) }
  function scan_decimal_digit_star(width, ib) {
    var width$0 = width;
    for (; ;) {
      if (0 === width$0) return width$0;
      var c = peek_char(ib);
      if (ib[1]) return width$0;
      if (58 <= c) {
        if (95 === c) { var width$1 = ignore_char(width$0, ib), width$0 = width$1; continue }
      }
      else
        if (48 <= c) { var width$2 = store_char(width$0, ib, c), width$0 = width$2; continue }
      return width$0
    }
  }
  function scan_unsigned_decimal_int(width, ib) {
    if (0 === width) return bad_token_length(cst_decimal_digits);
    var c = checked_peek_char(ib);
    if (9 < c - 48 >>> 0) return bad_input(caml_call1(sprintf(_cw_), c));
    var width$0 = store_char(width, ib, c);
    return scan_decimal_digit_star(width$0, ib)
  }
  function scan_digit_plus(basis, digitp, width$2, ib) {
    if (0 === width$2) return bad_token_length(cst_digits);
    var c$0 = checked_peek_char(ib);
    if (!caml_call1(digitp, c$0))
      return bad_input(caml_call2(sprintf(_cx_), c$0, basis));
    var width$3 = store_char(width$2, ib, c$0), width = width$3;
    for (; ;) {
      if (0 === width) return width;
      var c = peek_char(ib);
      if (ib[1]) return width;
      if (caml_call1(digitp, c)) { var width$0 = store_char(width, ib, c), width = width$0; continue }
      if (95 !== c) return width;
      var width$1 = ignore_char(width, ib), width = width$1
    }
  }
  function is_binary_digit(param) { return 1 < param - 48 >>> 0 ? 0 : 1 }
  function scan_binary_int(_jL_, _jM_) { return scan_digit_plus(cst_binary, is_binary_digit, _jL_, _jM_) }
  function is_octal_digit(param) { return 7 < param - 48 >>> 0 ? 0 : 1 }
  function scan_octal_int(_jJ_, _jK_) { return scan_digit_plus(cst_octal, is_octal_digit, _jJ_, _jK_) }
  function is_hexa_digit(param) {
    var _jI_ = param - 48 | 0, switch$0 = 0;
    if (22 < _jI_ >>> 0) { if (5 >= _jI_ - 49 >>> 0) switch$0 = 1 }
    else
      if (6 < _jI_ - 10 >>> 0) switch$0 = 1;
    return switch$0 ? 1 : 0
  }
  function scan_hexadecimal_int(_jG_, _jH_) { return scan_digit_plus(cst_hexadecimal, is_hexa_digit, _jG_, _jH_) }
  function scan_sign(width, ib) {
    var c = checked_peek_char(ib), switcher = c - 43 | 0;
    if (2 >= switcher >>> 0)
      switch (switcher) {
        case 0: return store_char(width, ib, c);
        case 1: break;
        default: return store_char(width, ib, c)
      }
    return width
  }
  function scan_optionally_signed_decimal(width, ib) {
    var width$0 = scan_sign(width, ib);
    return scan_unsigned_decimal_int(width$0, ib)
  }
  function scan_int_conversion(conv, width$1, ib) {
    switch (conv) {
      case 0: return scan_binary_int(width$1, ib);
      case 1: return scan_optionally_signed_decimal(width$1, ib);
      case 2:
        var width$0 = scan_sign(width$1, ib), c = checked_peek_char(ib);
        if (48 !== c) return scan_unsigned_decimal_int(width$0, ib);
        var width = store_char(width$0, ib, c);
        if (0 === width) return width;
        var c$0 = peek_char(ib);
        if (ib[1]) return width;
        var switch$0 = 0;
        if (99 <= c$0) {
          if (111 === c$0) return scan_octal_int(store_char(width, ib, c$0), ib);
          if (120 === c$0) switch$0 = 1
        }
        else
          if (88 === c$0)
            switch$0 = 1;
          else
            if (98 <= c$0) return scan_binary_int(store_char(width, ib, c$0), ib);
        return switch$0
          ? scan_hexadecimal_int(store_char(width, ib, c$0), ib)
          : scan_decimal_digit_star(width, ib);
      case 3: return scan_octal_int(width$1, ib);
      case 4: return scan_unsigned_decimal_int(width$1, ib);
      default: return scan_hexadecimal_int(width$1, ib)
    }
  }
  function scan_fractional_part(width, ib) {
    if (0 === width) return width;
    var c = peek_char(ib);
    return ib[1]
      ? width
      : 9 < c - 48 >>> 0
        ? width
        : scan_decimal_digit_star(store_char(width, ib, c), ib)
  }
  function scan_exponent_part(width, ib) {
    if (0 === width) return width;
    var c = peek_char(ib);
    if (ib[1]) return width;
    if (69 !== c && 101 !== c) return width;
    return scan_optionally_signed_decimal(store_char(width, ib, c), ib)
  }
  function scan_float(width$1, precision, ib) {
    var
    width = scan_sign(width$1, ib),
    width$0 = scan_decimal_digit_star(width, ib);
    if (0 === width$0) return [0, width$0, precision];
    var c = peek_char(ib);
    if (ib[1]) return [0, width$0, precision];
    if (46 !== c) return [0, scan_exponent_part(width$0, ib), precision];
    var
      width$2 = store_char(width$0, ib, c),
      precision$0 = min$1(width$2, precision),
      width$3 =
        width$2
        -
        (precision$0 - scan_fractional_part(precision$0, ib) | 0)
        |
        0;
    return [0, scan_exponent_part(width$3, ib), precision$0]
  }
  function check_case_insensitive_string(width, ib, error, str) {
    function lowercase(c) { return 25 < c - 65 >>> 0 ? c : char_of_int((c - 65 | 0) + 97 | 0) }
    var
      len = caml_ml_string_length(str),
      width$0 = [0, width],
      _jD_ = len - 1 | 0,
      _jC_ = 0;
    if (_jD_ >= 0) {
      var i = _jC_;
      for (; ;) {
        var c = peek_char(ib), _jE_ = lowercase(caml_string_get(str, i));
        if (lowercase(c) !== _jE_) caml_call1(error, 0);
        if (0 === width$0[1]) caml_call1(error, 0);
        width$0[1] = store_char(width$0[1], ib, c);
        var _jF_ = i + 1 | 0;
        if (_jD_ !== i) { var i = _jF_; continue }
        break
      }
    }
    return width$0[1]
  }
  function scan_hex_float(width, precision, ib) {
    var _jp_ = 0 === width ? 1 : 0, _jq_ = _jp_ || end_of_input(ib);
    if (_jq_) bad_hex_float(0);
    var
      width$0 = scan_sign(width, ib),
      _jr_ = 0 === width$0 ? 1 : 0,
      _js_ = _jr_ || end_of_input(ib);
    if (_js_) bad_hex_float(0);
    var c = peek_char(ib), switch$0 = 0;
    if (78 <= c) {
      var switcher = c - 79 | 0;
      if (30 < switcher >>> 0) {
        if (32 > switcher) {
          var
          width$1 = store_char(width$0, ib, c),
          _jt_ = 0 === width$1 ? 1 : 0,
          _ju_ = _jt_ || end_of_input(ib);
          if (_ju_) bad_hex_float(0);
          return check_case_insensitive_string
            (width$1, ib, bad_hex_float, cst_an)
        }
      }
      else
        if (26 === switcher) switch$0 = 1
    }
    else {
      if (48 === c) {
        var
        width$3 = store_char(width$0, ib, c),
        _jx_ = 0 === width$3 ? 1 : 0,
        _jy_ = _jx_ || end_of_input(ib);
        if (_jy_) bad_hex_float(0);
        var
          width$4 =
            check_case_insensitive_string(width$3, ib, bad_hex_float, cst_x$2);
        if (0 !== width$4 && !end_of_input(ib)) {
          var match = peek_char(ib), _jz_ = match - 46 | 0, switch$1 = 0;
          if (34 < _jz_ >>> 0) { if (66 === _jz_) switch$1 = 1 }
          else
            if (32 < _jz_ - 1 >>> 0) switch$1 = 1;
          var width$5 = switch$1 ? width$4 : scan_hexadecimal_int(width$4, ib);
          if (0 !== width$5 && !end_of_input(ib)) {
            var c$0 = peek_char(ib);
            if (46 === c$0) {
              var width$6 = store_char(width$5, ib, c$0), switch$2 = 0;
              if (0 !== width$6 && !end_of_input(ib)) {
                var match$0 = peek_char(ib), switch$3 = 0;
                if (80 !== match$0 && 112 !== match$0) {
                  var
                  precision$0 = min$1(width$6, precision),
                  width$10 =
                    width$6
                    -
                    (precision$0 - scan_hexadecimal_int(precision$0, ib) | 0)
                    |
                    0;
                  switch$3 = 1
                }
                if (!switch$3) var width$10 = width$6;
                var width$7 = width$10;
                switch$2 = 1
              }
              if (!switch$2) var width$7 = width$6;
              var width$8 = width$7
            }
            else
              var width$8 = width$5;
            if (0 !== width$8 && !end_of_input(ib)) {
              var c$1 = peek_char(ib);
              if (80 !== c$1 && 112 !== c$1) return width$8;
              var
                width$9 = store_char(width$8, ib, c$1),
                _jA_ = 0 === width$9 ? 1 : 0,
                _jB_ = _jA_ || end_of_input(ib);
              if (_jB_) bad_hex_float(0);
              return scan_optionally_signed_decimal(width$9, ib)
            }
            return width$8
          }
          return width$5
        }
        return width$4
      }
      if (73 === c) switch$0 = 1
    }
    if (!switch$0) return bad_hex_float(0);
    var
      width$2 = store_char(width$0, ib, c),
      _jv_ = 0 === width$2 ? 1 : 0,
      _jw_ = _jv_ || end_of_input(ib);
    if (_jw_) bad_hex_float(0);
    return check_case_insensitive_string
      (width$2, ib, bad_hex_float, cst_nfinity)
  }
  function scan_caml_float_rest(width, precision, ib) {
    var _jl_ = 0 === width ? 1 : 0, _jm_ = _jl_ || end_of_input(ib);
    if (_jm_) bad_float(0);
    var
      width$0 = scan_decimal_digit_star(width, ib),
      _jn_ = 0 === width$0 ? 1 : 0,
      _jo_ = _jn_ || end_of_input(ib);
    if (_jo_) bad_float(0);
    var c = peek_char(ib), switcher = c - 69 | 0;
    if (32 < switcher >>> 0) {
      if (-23 === switcher) {
        var
        width$1 = store_char(width$0, ib, c),
        precision$0 = min$1(width$1, precision),
        width_precision = scan_fractional_part(precision$0, ib),
        frac_width = precision$0 - width_precision | 0,
        width$2 = width$1 - frac_width | 0;
        return scan_exponent_part(width$2, ib)
      }
    }
    else
      if (30 < switcher - 1 >>> 0) return scan_exponent_part(width$0, ib);
    return bad_float(0)
  }
  function scan_caml_float(width, precision, ib) {
    var _i9_ = 0 === width ? 1 : 0, _i__ = _i9_ || end_of_input(ib);
    if (_i__) bad_float(0);
    var
      width$0 = scan_sign(width, ib),
      _i$_ = 0 === width$0 ? 1 : 0,
      _ja_ = _i$_ || end_of_input(ib);
    if (_ja_) bad_float(0);
    var c = peek_char(ib);
    if (49 <= c) {
      if (58 > c) {
        var
        width$1 = store_char(width$0, ib, c),
        _jb_ = 0 === width$1 ? 1 : 0,
        _jc_ = _jb_ || end_of_input(ib);
        if (_jc_) bad_float(0);
        return scan_caml_float_rest(width$1, precision, ib)
      }
    }
    else
      if (48 <= c) {
        var
        width$2 = store_char(width$0, ib, c),
        _jd_ = 0 === width$2 ? 1 : 0,
        _je_ = _jd_ || end_of_input(ib);
        if (_je_) bad_float(0);
        var c$0 = peek_char(ib);
        if (88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2, precision, ib);
        var
          width$3 = store_char(width$2, ib, c$0),
          _jf_ = 0 === width$3 ? 1 : 0,
          _jg_ = _jf_ || end_of_input(ib);
        if (_jg_) bad_float(0);
        var
          width$4 = scan_hexadecimal_int(width$3, ib),
          _jh_ = 0 === width$4 ? 1 : 0,
          _ji_ = _jh_ || end_of_input(ib);
        if (_ji_) bad_float(0);
        var c$1 = peek_char(ib), switcher = c$1 - 80 | 0, switch$0 = 0;
        if (32 < switcher >>> 0)
          if (-34 === switcher) {
            var width$5 = store_char(width$4, ib, c$1), switch$1 = 0;
            if (0 !== width$5 && !end_of_input(ib)) {
              var match = peek_char(ib), switch$2 = 0;
              if (80 !== match && 112 !== match) {
                var
                precision$0 = min$1(width$5, precision),
                width$10 =
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0, ib) | 0)
                  |
                  0;
                switch$2 = 1
              }
              if (!switch$2) var width$10 = width$5;
              var width$6 = width$10;
              switch$1 = 1
            }
            if (!switch$1) var width$6 = width$5;
            var width$7 = width$6
          }
          else
            switch$0 = 1;
        else
          if (30 < switcher - 1 >>> 0) var width$7 = width$4; else switch$0 = 1;
        var width$8 = switch$0 ? bad_float(0) : width$7;
        if (0 !== width$8 && !end_of_input(ib)) {
          var c$2 = peek_char(ib);
          if (80 !== c$2 && 112 !== c$2) return width$8;
          var
            width$9 = store_char(width$8, ib, c$2),
            _jj_ = 0 === width$9 ? 1 : 0,
            _jk_ = _jj_ || end_of_input(ib);
          if (_jk_) bad_hex_float(0);
          return scan_optionally_signed_decimal(width$9, ib)
        }
        return width$8
      }
    return bad_float(0)
  }
  function scan_string(stp, width, ib) {
    var width$0 = width;
    for (; ;) {
      if (0 === width$0) return width$0;
      var c = peek_char(ib);
      if (ib[1]) return width$0;
      if (stp) {
        var c$0 = stp[1];
        if (c === c$0) return skip_char(width$0, ib);
        var width$1 = store_char(width$0, ib, c), width$0 = width$1;
        continue
      }
      var _i8_ = c - 9 | 0, switch$0 = 0;
      if (4 < _i8_ >>> 0) { if (23 === _i8_) switch$0 = 1 }
      else
        if (1 < _i8_ - 2 >>> 0) switch$0 = 1;
      if (switch$0) return width$0;
      var width$2 = store_char(width$0, ib, c), width$0 = width$2
    }
  }
  function scan_char(width, ib) { return store_char(width, ib, checked_peek_char(ib)) }
  function hexadecimal_value_of_char(d) { return 97 <= d ? d - 87 | 0 : 65 <= d ? d - 55 | 0 : d - 48 | 0 }
  function check_next_char(message, width, ib) {
    if (0 === width) return bad_token_length(message);
    var c = peek_char(ib);
    return ib[1] ? bad_input(caml_call1(sprintf(_cs_), message)) : c
  }
  function check_next_char_for_char(_i6_, _i7_) { return check_next_char(cst_a_Char, _i6_, _i7_) }
  function check_next_char_for_string(_i4_, _i5_) { return check_next_char(cst_a_String, _i4_, _i5_) }
  function scan_backslash_char(width, ib) {
    var c0 = check_next_char_for_char(width, ib), switch$0 = 0;
    if (40 <= c0) {
      if (58 <= c0) {
        var switcher = c0 - 92 | 0;
        if (28 >= switcher >>> 0)
          switch (switcher) {
            case 28:
              var
                get_digit =
                  function (param) {
                    var c = next_char(ib), _i3_ = c - 48 | 0, switch$0 = 0;
                    if (22 < _i3_ >>> 0) { if (5 >= _i3_ - 49 >>> 0) switch$0 = 1 }
                    else
                      if (6 < _i3_ - 10 >>> 0) switch$0 = 1;
                    return switch$0 ? c : bad_input_escape(c)
                  },
                c1 = get_digit(0),
                c2 = get_digit(0),
                _iZ_ = hexadecimal_value_of_char(c2),
                c$0 = (16 * hexadecimal_value_of_char(c1) | 0) + _iZ_ | 0,
                switch$1 = 0;
              if (0 <= c$0 && 255 >= c$0) { var _i1_ = char_of_int(c$0); switch$1 = 1 }
              if (!switch$1)
                var _i1_ = bad_input(caml_call2(sprintf(_cz_), c1, c2));
              return store_char(width - 2 | 0, ib, _i1_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24: switch$0 = 1; break
          }
      }
      else
        if (48 <= c0) {
          var
          get_digit$0 =
            function (param) {
              var c = next_char(ib);
              return 9 < c - 48 >>> 0 ? bad_input_escape(c) : c
            },
          c1$0 = get_digit$0(0),
          c2$0 = get_digit$0(0),
          c =
            ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
            +
            (c2$0 - 48 | 0)
            |
            0,
          switch$2 = 0;
          if (0 <= c && 255 >= c) { var _i2_ = char_of_int(c); switch$2 = 1 }
          if (!switch$2)
            var _i2_ = bad_input(caml_call3(sprintf(_cy_), c0, c1$0, c2$0));
          return store_char(width - 2 | 0, ib, _i2_)
        }
    }
    else
      if (34 === c0 || 39 <= c0) switch$0 = 1;
    if (!switch$0) return bad_input_escape(c0);
    var switch$3 = 0;
    if (110 <= c0)
      if (117 <= c0)
        switch$3 = 1;
      else
        switch (c0 - 110 | 0) {
          case 0: var _i0_ = 10; break;
          case 4: var _i0_ = 13; break;
          case 6: var _i0_ = 9; break;
          default: switch$3 = 1
        }
    else
      if (98 === c0) var _i0_ = 8; else switch$3 = 1;
    if (switch$3) var _i0_ = c0;
    return store_char(width, ib, _i0_)
  }
  function scan_caml_char(width, ib) {
    function find_stop(width) {
      var c = check_next_char_for_char(width, ib);
      return 39 === c ? ignore_char(width, ib) : character_mismatch(39, c)
    }
    var c = checked_peek_char(ib);
    if (39 !== c) return character_mismatch(39, c);
    var
      width$0 = ignore_char(width, ib),
      c$0 = check_next_char_for_char(width$0, ib);
    return 92 === c$0
      ? find_stop(scan_backslash_char(ignore_char(width$0, ib), ib))
      : find_stop(store_char(width$0, ib, c$0))
  }
  function scan_caml_string(width, ib) {
    function find_stop$0(counter, width) {
      var width$0 = width;
      for (; ;) {
        var c = check_next_char_for_string(width$0, ib);
        if (34 === c) return ignore_char(width$0, ib);
        if (92 !== c) { var width$2 = store_char(width$0, ib, c), width$0 = width$2; continue }
        var
          width$1 = ignore_char(width$0, ib),
          match = check_next_char_for_string(width$1, ib);
        if (10 === match) {
          var _iX_ = ignore_char(width$1, ib);
          if (counter >= 50)
            return caml_trampoline_return(skip_spaces, [0, _iX_]);
          var counter$0 = counter + 1 | 0;
          return skip_spaces(counter$0, _iX_)
        }
        if (13 !== match) {
          var width$4 = scan_backslash_char(width$1, ib), width$0 = width$4;
          continue
        }
        var
          width$3 = ignore_char(width$1, ib),
          match$0 = check_next_char_for_string(width$3, ib);
        if (10 !== match$0) { var width$5 = store_char(width$3, ib, 13), width$0 = width$5; continue }
        var _iY_ = ignore_char(width$3, ib);
        if (counter >= 50)
          return caml_trampoline_return(skip_spaces, [0, _iY_]);
        var counter$1 = counter + 1 | 0;
        return skip_spaces(counter$1, _iY_)
      }
    }
    function skip_spaces(counter, width) {
      var width$0 = width;
      for (; ;) {
        var match = check_next_char_for_string(width$0, ib);
        if (32 === match) { var width$1 = ignore_char(width$0, ib), width$0 = width$1; continue }
        if (counter >= 50)
          return caml_trampoline_return(find_stop$0, [0, width$0]);
        var counter$0 = counter + 1 | 0;
        return find_stop$0(counter$0, width$0)
      }
    }
    function find_stop(width) { return caml_trampoline(find_stop$0(0, width)) }
    var c = checked_peek_char(ib);
    return 34 === c
      ? find_stop(ignore_char(width, ib))
      : character_mismatch(34, c)
  }
  function scan_chars_in_char_set(char_set, scan_indic, width, ib) {
    function scan_chars(i, stp) {
      var i$0 = i;
      for (; ;) {
        var c = peek_char(ib), _iT_ = 0 < i$0 ? 1 : 0;
        if (_iT_) {
          var _iU_ = 1 - ib[1];
          if (_iU_)
            var _iV_ = is_in_char_set(char_set, c), _iW_ = _iV_ ? c !== stp ? 1 : 0 : _iV_;
          else
            var _iW_ = _iU_
        }
        else
          var _iW_ = _iT_;
        if (!_iW_) return _iW_;
        store_char(max_int, ib, c);
        var i$1 = i$0 - 1 | 0, i$0 = i$1
      }
    }
    if (!scan_indic) return scan_chars(width, -1);
    var c = scan_indic[1];
    scan_chars(width, c);
    var _iS_ = 1 - ib[1];
    if (!_iS_) return _iS_;
    var ci = peek_char(ib);
    return c === ci ? invalidate_current_char(ib) : character_mismatch(c, ci)
  }
  function scanf_bad_input(ib, x) {
    if (x[1] === Scan_failure)
      var s = x[2];
    else { if (x[1] !== Failure) throw x; var s = x[2] }
    var i = char_count(ib);
    return bad_input(caml_call2(sprintf(_cB_), i, s))
  }
  function get_counter(ib, counter) {
    switch (counter) { case 0: return ib[5]; case 1: return char_count(ib); default: return ib[6] }
  }
  function width_of_pad_opt(pad_opt) { if (!pad_opt) return max_int; var width = pad_opt[1]; return width }
  function stopper_of_formatting_lit(fmting) {
    if (6 === fmting) return _cC_;
    var
      str = string_of_formatting_lit(fmting),
      stp = caml_string_get(str, 1),
      sub_str = sub$0(str, 2, caml_ml_string_length(str) - 2 | 0);
    return [0, stp, sub_str]
  }
  function take_format_readers$0(counter, k, fmt) {
    var fmt$0 = fmt;
    for (; ;) {
      if (typeof fmt$0 === "number") return caml_call1(k, 0);
      switch (fmt$0[0]) {
        case 0: var fmt$1 = fmt$0[1], fmt$0 = fmt$1; continue;
        case 1: var fmt$2 = fmt$0[1], fmt$0 = fmt$2; continue;
        case 2: var fmt$3 = fmt$0[2], fmt$0 = fmt$3; continue;
        case 3: var fmt$4 = fmt$0[2], fmt$0 = fmt$4; continue;
        case 4: var fmt$5 = fmt$0[4], fmt$0 = fmt$5; continue;
        case 5: var fmt$6 = fmt$0[4], fmt$0 = fmt$6; continue;
        case 6: var fmt$7 = fmt$0[4], fmt$0 = fmt$7; continue;
        case 7: var fmt$8 = fmt$0[4], fmt$0 = fmt$8; continue;
        case 8: var fmt$9 = fmt$0[4], fmt$0 = fmt$9; continue;
        case 9: var fmt$10 = fmt$0[2], fmt$0 = fmt$10; continue;
        case 10: var fmt$11 = fmt$0[1], fmt$0 = fmt$11; continue;
        case 11: var fmt$12 = fmt$0[2], fmt$0 = fmt$12; continue;
        case 12: var fmt$13 = fmt$0[2], fmt$0 = fmt$13; continue;
        case 13: var fmt$14 = fmt$0[3], fmt$0 = fmt$14; continue;
        case 14:
          var rest = fmt$0[3], fmtty = fmt$0[2], _iQ_ = erase_rel(symm(fmtty));
          if (counter >= 50)
            return caml_trampoline_return
              (take_fmtty_format_readers$0, [0, k, _iQ_, rest]);
          var counter$0 = counter + 1 | 0;
          return take_fmtty_format_readers$0(counter$0, k, _iQ_, rest);
        case 15: var fmt$15 = fmt$0[1], fmt$0 = fmt$15; continue;
        case 16: var fmt$16 = fmt$0[1], fmt$0 = fmt$16; continue;
        case 17: var fmt$17 = fmt$0[2], fmt$0 = fmt$17; continue;
        case 18:
          var _iR_ = fmt$0[1];
          if (0 === _iR_[0]) {
            var
            rest$0 = fmt$0[2],
            match = _iR_[1],
            fmt$18 = match[1],
            fmt$19 = concat_fmt(fmt$18, rest$0),
            fmt$0 = fmt$19;
            continue
          }
          var
            rest$1 = fmt$0[2],
            match$0 = _iR_[1],
            fmt$20 = match$0[1],
            fmt$21 = concat_fmt(fmt$20, rest$1),
            fmt$0 = fmt$21;
          continue;
        case 19:
          var fmt_rest = fmt$0[1];
          return function (reader) {
            function new_k(readers_rest) { return caml_call1(k, [0, reader, readers_rest]) }
            return take_format_readers(new_k, fmt_rest)
          };
        case 20: var fmt$22 = fmt$0[3], fmt$0 = fmt$22; continue;
        case 21: var fmt$23 = fmt$0[2], fmt$0 = fmt$23; continue;
        case 22: var fmt$24 = fmt$0[1], fmt$0 = fmt$24; continue;
        case 23:
          var rest$2 = fmt$0[2], ign = fmt$0[1];
          if (typeof ign === "number")
            switch (ign) {
              case 0: var fmt$0 = rest$2; continue;
              case 1: var fmt$0 = rest$2; continue;
              case 2:
                return function (reader) {
                  function new_k(readers_rest) { return caml_call1(k, [0, reader, readers_rest]) }
                  return take_format_readers(new_k, rest$2)
                };
              default: var fmt$0 = rest$2; continue
            }
          switch (ign[0]) {
            case 0: var fmt$0 = rest$2; continue;
            case 1: var fmt$0 = rest$2; continue;
            case 2: var fmt$0 = rest$2; continue;
            case 3: var fmt$0 = rest$2; continue;
            case 4: var fmt$0 = rest$2; continue;
            case 5: var fmt$0 = rest$2; continue;
            case 6: var fmt$0 = rest$2; continue;
            case 7: var fmt$0 = rest$2; continue;
            case 8: var fmt$0 = rest$2; continue;
            case 9:
              var fmtty$0 = ign[2];
              if (counter >= 50)
                return caml_trampoline_return
                  (take_fmtty_format_readers$0, [0, k, fmtty$0, rest$2]);
              var counter$1 = counter + 1 | 0;
              return take_fmtty_format_readers$0(counter$1, k, fmtty$0, rest$2);
            case 10: var fmt$0 = rest$2; continue;
            default: var fmt$0 = rest$2; continue
          }
        default: var fmt$25 = fmt$0[3], fmt$0 = fmt$25; continue
      }
    }
  }
  function take_fmtty_format_readers$0(counter, k, fmtty, fmt) {
    var fmtty$0 = fmtty;
    for (; ;) {
      if (typeof fmtty$0 !== "number")
        switch (fmtty$0[0]) {
          case 0: var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1; continue;
          case 1: var fmtty$2 = fmtty$0[1], fmtty$0 = fmtty$2; continue;
          case 2: var fmtty$3 = fmtty$0[1], fmtty$0 = fmtty$3; continue;
          case 3: var fmtty$4 = fmtty$0[1], fmtty$0 = fmtty$4; continue;
          case 4: var fmtty$5 = fmtty$0[1], fmtty$0 = fmtty$5; continue;
          case 5: var fmtty$6 = fmtty$0[1], fmtty$0 = fmtty$6; continue;
          case 6: var fmtty$7 = fmtty$0[1], fmtty$0 = fmtty$7; continue;
          case 7: var fmtty$8 = fmtty$0[1], fmtty$0 = fmtty$8; continue;
          case 8: var fmtty$9 = fmtty$0[2], fmtty$0 = fmtty$9; continue;
          case 9:
            var
              rest = fmtty$0[3],
              ty2 = fmtty$0[2],
              ty1 = fmtty$0[1],
              ty = trans(symm(ty1), ty2),
              fmtty$10 = concat_fmtty(ty, rest),
              fmtty$0 = fmtty$10;
            continue;
          case 10: var fmtty$11 = fmtty$0[1], fmtty$0 = fmtty$11; continue;
          case 11: var fmtty$12 = fmtty$0[1], fmtty$0 = fmtty$12; continue;
          case 12: var fmtty$13 = fmtty$0[1], fmtty$0 = fmtty$13; continue;
          case 13:
            var fmt_rest = fmtty$0[1];
            return function (reader) {
              function new_k(readers_rest) { return caml_call1(k, [0, reader, readers_rest]) }
              return take_fmtty_format_readers(new_k, fmt_rest, fmt)
            };
          default:
            var fmt_rest$0 = fmtty$0[1];
            return function (reader) {
              function new_k(readers_rest) { return caml_call1(k, [0, reader, readers_rest]) }
              return take_fmtty_format_readers(new_k, fmt_rest$0, fmt)
            }
        }
      if (counter >= 50)
        return caml_trampoline_return(take_format_readers$0, [0, k, fmt]);
      var counter$0 = counter + 1 | 0;
      return take_format_readers$0(counter$0, k, fmt)
    }
  }
  function take_format_readers(k, fmt) { return caml_trampoline(take_format_readers$0(0, k, fmt)) }
  function take_fmtty_format_readers(k, fmtty, fmt) { return caml_trampoline(take_fmtty_format_readers$0(0, k, fmtty, fmt)) }
  function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token) {
    if (typeof pad === "number") {
      if (typeof prec !== "number") {
        var p = prec[1];
        caml_call3(scan, max_int, p, ib);
        var x$0 = caml_call1(token, ib);
        return [0, x$0, make_scanf(ib, fmt, readers)]
      }
      if (prec) return invalid_arg(cst_scanf_bad_conversion);
      caml_call3(scan, max_int, max_int, ib);
      var x = caml_call1(token, ib);
      return [0, x, make_scanf(ib, fmt, readers)]
    }
    if (0 !== pad[0]) return invalid_arg(cst_scanf_bad_conversion$2);
    if (!pad[1]) return invalid_arg(cst_scanf_bad_conversion$1);
    var _iP_ = pad[2];
    if (typeof prec !== "number") {
      var p$0 = prec[1];
      caml_call3(scan, _iP_, p$0, ib);
      var x$2 = caml_call1(token, ib);
      return [0, x$2, make_scanf(ib, fmt, readers)]
    }
    if (prec) return invalid_arg(cst_scanf_bad_conversion$0);
    caml_call3(scan, _iP_, max_int, ib);
    var x$1 = caml_call1(token, ib);
    return [0, x$1, make_scanf(ib, fmt, readers)]
  }
  function make_scanf(ib, fmt, readers) {
    var fmt$0 = fmt;
    for (; ;) {
      if (typeof fmt$0 === "number") return 0;
      switch (fmt$0[0]) {
        case 0:
          var rest = fmt$0[1];
          scan_char(0, ib);
          var c = token_char(ib);
          return [0, c, make_scanf(ib, rest, readers)];
        case 1:
          var rest$0 = fmt$0[1];
          scan_caml_char(0, ib);
          var c$0 = token_char(ib);
          return [0, c$0, make_scanf(ib, rest$0, readers)];
        case 2:
          var _iC_ = fmt$0[1], _iD_ = fmt$0[2];
          if (typeof _iD_ !== "number")
            switch (_iD_[0]) {
              case 17:
                var
                  rest$2 = _iD_[2],
                  fmting_lit = _iD_[1],
                  match = stopper_of_formatting_lit(fmting_lit),
                  str = match[2],
                  stp = match[1],
                  scan$0 =
                    function (width, param, ib) { return scan_string([0, stp], width, ib) },
                  str_rest = [11, str, rest$2];
                return pad_prec_scanf
                  (ib, str_rest, readers, _iC_, 0, scan$0, token_string);
              case 18:
                var _iE_ = _iD_[1];
                if (0 === _iE_[0]) {
                  var
                  rest$3 = _iD_[2],
                  match$0 = _iE_[1],
                  fmt$1 = match$0[1],
                  scan$1 =
                    function (width, param, ib) { return scan_string(_cD_, width, ib) };
                  return pad_prec_scanf
                    (ib,
                      concat_fmt(fmt$1, rest$3),
                      readers,
                      _iC_,
                      0,
                      scan$1,
                      token_string)
                }
                var
                  rest$4 = _iD_[2],
                  match$1 = _iE_[1],
                  fmt$2 = match$1[1],
                  scan$2 =
                    function (width, param, ib) { return scan_string(_cE_, width, ib) };
                return pad_prec_scanf
                  (ib,
                    concat_fmt(fmt$2, rest$4),
                    readers,
                    _iC_,
                    0,
                    scan$2,
                    token_string)
            }
          var
            rest$1 = fmt$0[2],
            scan = function (width, param, ib) { return scan_string(0, width, ib) };
          return pad_prec_scanf(ib, rest$1, readers, _iC_, 0, scan, token_string);
        case 3:
          var
            rest$5 = fmt$0[2],
            pad = fmt$0[1],
            scan$3 = function (width, param, ib) { return scan_caml_string(width, ib) };
          return pad_prec_scanf(ib, rest$5, readers, pad, 0, scan$3, token_string);
        case 4:
          var
            rest$6 = fmt$0[4],
            prec = fmt$0[3],
            pad$0 = fmt$0[2],
            iconv = fmt$0[1],
            conv = integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4 =
              function (width, param, ib) { return scan_int_conversion(conv, width, ib) };
          return pad_prec_scanf
            (ib,
              rest$6,
              readers,
              pad$0,
              prec,
              scan$4,
              function (ib) { return caml_int_of_string(token_int_literal(conv, ib)) });
        case 5:
          var
            rest$7 = fmt$0[4],
            prec$0 = fmt$0[3],
            pad$1 = fmt$0[2],
            iconv$0 = fmt$0[1],
            conv$0 = integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5 =
              function (width, param, ib) { return scan_int_conversion(conv$0, width, ib) };
          return pad_prec_scanf
            (ib,
              rest$7,
              readers,
              pad$1,
              prec$0,
              scan$5,
              function (ib) { return caml_int_of_string(token_int_literal(conv$0, ib)) });
        case 6:
          var
            rest$8 = fmt$0[4],
            prec$1 = fmt$0[3],
            pad$2 = fmt$0[2],
            iconv$1 = fmt$0[1],
            conv$1 = integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6 =
              function (width, param, ib) { return scan_int_conversion(conv$1, width, ib) };
          return pad_prec_scanf
            (ib,
              rest$8,
              readers,
              pad$2,
              prec$1,
              scan$6,
              function (ib) { return caml_int_of_string(token_int_literal(conv$1, ib)) });
        case 7:
          var
            rest$9 = fmt$0[4],
            prec$2 = fmt$0[3],
            pad$3 = fmt$0[2],
            iconv$2 = fmt$0[1],
            conv$2 = integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7 =
              function (width, param, ib) { return scan_int_conversion(conv$2, width, ib) };
          return pad_prec_scanf
            (ib,
              rest$9,
              readers,
              pad$3,
              prec$2,
              scan$7,
              function (ib) { return caml_int64_of_string(token_int_literal(conv$2, ib)) });
        case 8:
          switch (fmt$0[1][2]) {
            case 5:
            case 8:
              var rest$11 = fmt$0[4], prec$4 = fmt$0[3], pad$5 = fmt$0[2];
              return pad_prec_scanf
                (ib,
                  rest$11,
                  readers,
                  pad$5,
                  prec$4,
                  scan_caml_float,
                  token_float);
            case 6:
            case 7:
              var rest$12 = fmt$0[4], prec$5 = fmt$0[3], pad$6 = fmt$0[2];
              return pad_prec_scanf
                (ib, rest$12, readers, pad$6, prec$5, scan_hex_float, token_float);
            default:
              var rest$10 = fmt$0[4], prec$3 = fmt$0[3], pad$4 = fmt$0[2];
              return pad_prec_scanf
                (ib, rest$10, readers, pad$4, prec$3, scan_float, token_float)
          }
        case 9:
          var
            rest$13 = fmt$0[2],
            pad$7 = fmt$0[1],
            scan$8 =
              function (param, _iO_, ib) {
                var
                c = checked_peek_char(ib),
                m =
                  102 === c
                    ? 5
                    : 116 === c ? 4 : bad_input(caml_call1(sprintf(_cA_), c));
                return scan_string(0, m, ib)
              };
          return pad_prec_scanf(ib, rest$13, readers, pad$7, 0, scan$8, token_bool);
        case 10:
          var rest$14 = fmt$0[1];
          if (!end_of_input(ib)) return bad_input(cst_end_of_input_not_found);
          var fmt$0 = rest$14;
          continue;
        case 11:
          var rest$15 = fmt$0[2], str$0 = fmt$0[1];
          iter$4(function (_iN_) { return check_char(ib, _iN_) }, str$0);
          var fmt$0 = rest$15;
          continue;
        case 12:
          var rest$16 = fmt$0[2], chr = fmt$0[1];
          check_char(ib, chr);
          var fmt$0 = rest$16;
          continue;
        case 13:
          var rest$17 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
          scan_caml_string(width_of_pad_opt(pad_opt), ib);
          var s = token_string(ib);
          try { var _iF_ = format_of_string_fmtty(s, fmtty), fmt$3 = _iF_ }
          catch (exn) {
            exn = caml_wrap_exception(exn);
            if (exn[1] !== Failure) throw exn;
            var msg = exn[2], fmt$3 = bad_input(msg)
          }
          return [0, fmt$3, make_scanf(ib, rest$17, readers)];
        case 14:
          var rest$18 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
          scan_caml_string(width_of_pad_opt(pad_opt$0), ib);
          var s$0 = token_string(ib);
          try {
            var
            match$2 = fmt_ebb_of_string(0, s$0),
            fmt$6 = match$2[1],
            match$3 = fmt_ebb_of_string(0, s$0),
            fmt$7 = match$3[1],
            fmt$8 = type_format(fmt$7, erase_rel(symm(fmtty$0))),
            _iH_ = type_format(fmt$6, erase_rel(fmtty$0)),
            fmt$5 = fmt$8,
            fmt$4 = _iH_
          }
          catch (exn) {
            exn = caml_wrap_exception(exn);
            if (exn[1] !== Failure) throw exn;
            var
              msg$0 = exn[2],
              _iG_ = bad_input(msg$0),
              fmt$5 = _iG_[2],
              fmt$4 = _iG_[1]
          }
          return [0,
            [0, fmt$4, s$0],
            make_scanf(ib, concat_fmt(fmt$5, rest$18), readers)];
        case 15: return invalid_arg(cst_scanf_bad_conversion_a);
        case 16: return invalid_arg(cst_scanf_bad_conversion_t);
        case 17:
          var
            rest$19 = fmt$0[2],
            formatting_lit = fmt$0[1],
            _iI_ = string_of_formatting_lit(formatting_lit);
          iter$4(function (_iM_) { return check_char(ib, _iM_) }, _iI_);
          var fmt$0 = rest$19;
          continue;
        case 18:
          var _iJ_ = fmt$0[1];
          if (0 === _iJ_[0]) {
            var rest$20 = fmt$0[2], match$4 = _iJ_[1], fmt$9 = match$4[1];
            check_char(ib, 64);
            check_char(ib, 123);
            var fmt$10 = concat_fmt(fmt$9, rest$20), fmt$0 = fmt$10;
            continue
          }
          var rest$21 = fmt$0[2], match$5 = _iJ_[1], fmt$11 = match$5[1];
          check_char(ib, 64);
          check_char(ib, 91);
          var fmt$12 = concat_fmt(fmt$11, rest$21), fmt$0 = fmt$12;
          continue;
        case 19:
          var fmt_rest = fmt$0[1];
          if (!readers) return invalid_arg(cst_scanf_missing_reader);
          var
            readers_rest = readers[2],
            reader = readers[1],
            x = caml_call1(reader, ib);
          return [0, x, make_scanf(ib, fmt_rest, readers_rest)];
        case 20:
          var _iK_ = fmt$0[1], _iL_ = fmt$0[3];
          if (typeof _iL_ !== "number" && 17 === _iL_[0]) {
            var
            rest$23 = _iL_[2],
            fmting_lit$0 = _iL_[1],
            char_set$0 = fmt$0[2],
            match$6 = stopper_of_formatting_lit(fmting_lit$0),
            str$1 = match$6[2],
            stp$0 = match$6[1],
            width$0 = width_of_pad_opt(_iK_);
            scan_chars_in_char_set(char_set$0, [0, stp$0], width$0, ib);
            var s$2 = token_string(ib), str_rest$0 = [11, str$1, rest$23];
            return [0, s$2, make_scanf(ib, str_rest$0, readers)]
          }
          var
            rest$22 = fmt$0[3],
            char_set = fmt$0[2],
            width = width_of_pad_opt(_iK_);
          scan_chars_in_char_set(char_set, 0, width, ib);
          var s$1 = token_string(ib);
          return [0, s$1, make_scanf(ib, rest$22, readers)];
        case 21:
          var
            rest$24 = fmt$0[2],
            counter = fmt$0[1],
            count = get_counter(ib, counter);
          return [0, count, make_scanf(ib, rest$24, readers)];
        case 22:
          var rest$25 = fmt$0[1], c$1 = checked_peek_char(ib);
          return [0, c$1, make_scanf(ib, rest$25, readers)];
        case 23:
          var
            rest$26 = fmt$0[2],
            ign = fmt$0[1],
            match$7 = param_format_of_ignored_format(ign, rest$26),
            fmt$13 = match$7[1],
            match$8 = make_scanf(ib, fmt$13, readers);
          if (!match$8) throw [0, Assert_failure, _cF_];
          var arg_rest = match$8[2];
          return arg_rest;
        default: return invalid_arg(cst_scanf_bad_conversion_custo)
      }
    }
  }
  function kscanf(ib, ef, param) {
    var str = param[2], fmt = param[1];
    function apply(f, args) {
      var f$0 = f, args$0 = args;
      for (; ;) {
        if (!args$0) return f$0;
        var r = args$0[2], x = args$0[1], f$1 = caml_call1(f$0, x), f$0 = f$1, args$0 = r
      }
    }
    function k(readers, f) {
      reset_token(ib);
      try { var _iB_ = [0, make_scanf(ib, fmt, readers)], _iA_ = _iB_ }
      catch (exc) {
        exc = caml_wrap_exception(exc);
        var switch$0 = 0;
        if
          (exc[1]
          !==
          Scan_failure
          &&
          exc[1]
          !==
          Failure
          &&
          exc
          !==
          End_of_file) {
          if (exc[1] !== Invalid_argument) throw exc;
          var
            msg = exc[2],
            _iz_ =
              invalid_arg
                (cat(msg, cat(cst_in_format, cat(escaped$1(str), cst$88))));
          switch$0 = 1
        }
        if (!switch$0) var _iz_ = [1, exc];
        var _iA_ = _iz_
      }
      if (0 === _iA_[0]) { var args = _iA_[1]; return apply(f, args) }
      var exc = _iA_[1];
      return caml_call2(ef, ib, exc)
    }
    return take_format_readers(k, fmt)
  }
  function bscanf(ib, fmt) { return kscanf(ib, scanf_bad_input, fmt) }
  function ksscanf(s, ef, fmt) { return kscanf(from_string$1(s), ef, fmt) }
  function sscanf(s, fmt) { return kscanf(from_string$1(s), scanf_bad_input, fmt) }
  function scanf(fmt) { return kscanf(stdib, scanf_bad_input, fmt) }
  function bscanf_format(ib, format, f) {
    scan_caml_string(max_int, ib);
    var str = token_string(ib);
    try { var _iy_ = format_of_string_format(str, format), fmt = _iy_ }
    catch (exn) {
      exn = caml_wrap_exception(exn);
      if (exn[1] !== Failure) throw exn;
      var msg = exn[2], fmt = bad_input(msg)
    }
    return caml_call1(f, fmt)
  }
  function sscanf_format(s, format, f) { return bscanf_format(from_string$1(s), format, f) }
  function format_from_string(s, fmt) {
    function _ix_(x) { return x }
    return sscanf_format(cat(cst$90, cat(escaped$1(s), cst$89)), fmt, _ix_)
  }
  function unescaped(s) {
    function _iw_(x) { return x }
    return caml_call1(sscanf(cat(cst$92, cat(s, cst$91)), _cG_), _iw_)
  }
  function kfscanf(ic, ef, fmt) { return kscanf(memo_from_channel(ic), ef, fmt) }
  function fscanf(ic, fmt) { return kscanf(memo_from_channel(ic), scanf_bad_input, fmt) }
  var
    Stdlib_Scanf =
      [0,
        [0,
          stdib,
          from_file,
          from_file_bin,
          close_in,
          from_file,
          from_file_bin,
          from_string$1,
          from_function$0,
          from_channel$0,
          end_of_input,
          beginning_of_input,
          name_of_input,
          stdib],
        Scan_failure,
        bscanf,
        sscanf,
        scanf,
        kscanf,
        ksscanf,
        bscanf_format,
        sscanf_format,
        format_from_string,
        unescaped,
        fscanf,
        kfscanf];
  caml_register_global(819, Stdlib_Scanf, "Stdlib__Scanf");
  function register(name, v) { return caml_register_named_value(name, v) }
  function register_exception(name, exn) {
    var slot = caml_obj_tag(exn) === 248 ? exn : exn[1];
    return caml_register_named_value(name, slot)
  }
  var Stdlib_Callback = [0, register, register_exception];
  caml_register_global(820, Stdlib_Callback, "Stdlib__Callback");
  function copy$7(o) { var o$0 = o.slice(); return caml_set_oo_id(o$0) }
  var params$0 = [0, 1, 1, 1, 3, 16], initial_object_size = 2, dummy_item = 0;
  function public_method_label(s) {
    var accu = [0, 0], _it_ = caml_ml_string_length(s) - 1 | 0, _is_ = 0;
    if (_it_ >= 0) {
      var i = _is_;
      for (; ;) {
        var _iu_ = caml_string_get(s, i);
        accu[1] = (223 * accu[1] | 0) + _iu_ | 0;
        var _iv_ = i + 1 | 0;
        if (_it_ !== i) { var i = _iv_; continue }
        break
      }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag
  }
  function compare$14(x, y) { return caml_string_compare(x, y) }
  var Vars = caml_call1(Stdlib_Map[1], [0, compare$14]);
  function compare$15(x, y) { return caml_string_compare(x, y) }
  var
    Meths = caml_call1(Stdlib_Map[1], [0, compare$15]),
    compare$16 = caml_int_compare,
    Labs = caml_call1(Stdlib_Map[1], [0, compare$16]),
    dummy_table = [0, 0, [0, dummy_item], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0);
  function fit_size(n) { return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n }
  function new_table(pub_labels) {
    table_count[1]++;
    var
      len = pub_labels.length - 1,
      methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var _im_ = ((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = _im_;
    var _io_ = len - 1 | 0, _in_ = 0;
    if (_io_ >= 0) {
      var i = _in_;
      for (; ;) {
        var
        _iq_ = (i * 2 | 0) + 3 | 0,
        _ip_ = caml_check_bound(pub_labels, i)[1 + i];
        caml_check_bound(methods, _iq_)[1 + _iq_] = _ip_;
        var _ir_ = i + 1 | 0;
        if (_io_ !== i) { var i = _ir_; continue }
        break
      }
    }
    return [0, initial_object_size, methods, Meths[1], Labs[1], 0, 0, Vars[1], 0]
  }
  function resize$1(array, new_size) {
    var old_size = array[2].length - 1, _ik_ = old_size < new_size ? 1 : 0;
    if (_ik_) {
      var new_buck = caml_make_vect(new_size, dummy_met);
      blit$1(array[2], 0, new_buck, 0, old_size);
      array[2] = new_buck;
      var _il_ = 0
    }
    else
      var _il_ = _ik_;
    return _il_
  }
  var method_count = [0, 0], inst_var_count = [0, 0];
  function new_method(table) {
    var index = table[2].length - 1;
    resize$1(table, index + 1 | 0);
    return index
  }
  function get_method_label(table, name) {
    try { var _ii_ = caml_call2(Meths[28], name, table[3]); return _ii_ }
    catch (_ij_) {
      _ij_ = caml_wrap_exception(_ij_);
      if (_ij_ !== Not_found) throw _ij_;
      var label = new_method(table);
      table[3] = caml_call3(Meths[4], name, label, table[3]);
      table[4] = caml_call3(Labs[4], label, 1, table[4]);
      return label
    }
  }
  function get_method_labels(table, names) { return map$7(function (_ih_) { return get_method_label(table, _ih_) }, names) }
  function set_method(table, label, element) {
    method_count[1]++;
    return caml_call2(Labs[28], label, table[4])
      ? (resize$1(table, label + 1 | 0),
        caml_check_bound(table[2], label)[1 + label]
        =
        element,
        0)
      : (table[6] = [0, [0, label, element], table[6]], 0)
  }
  function get_method(table, label) {
    try { var _if_ = assoc(label, table[6]); return _if_ }
    catch (_ig_) {
      _ig_ = caml_wrap_exception(_ig_);
      if (_ig_ === Not_found)
        return caml_check_bound(table[2], label)[1 + label];
      throw _ig_
    }
  }
  function to_list$3(arr) { return 0 === arr ? 0 : to_list$1(arr) }
  function narrow(table, vars, virt_meths, concr_meths) {
    var
    vars$0 = to_list$3(vars),
    virt_meths$0 = to_list$3(virt_meths),
    concr_meths$0 = to_list$3(concr_meths),
    virt_meth_labs =
      map$4
        (function (_ie_) { return get_method_label(table, _ie_) }, virt_meths$0),
    concr_meth_labs =
      map$4
        (function (_id_) { return get_method_label(table, _id_) }, concr_meths$0);
    table[5]
      =
      [0,
        [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
        table[5]];
    var _h6_ = Vars[1], _h7_ = table[7];
    function _h8_(lab, info, tvars) { return mem(lab, vars$0) ? caml_call3(Vars[4], lab, info, tvars) : tvars }
    table[7] = caml_call3(Vars[13], _h8_, _h7_, _h6_);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    iter2$0
      (function (met, label) {
        by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
        var _h$_ = by_label[1];
        try { var _ib_ = caml_call2(Labs[28], label, table[4]), _ia_ = _ib_ }
        catch (_ic_) {
          _ic_ = caml_wrap_exception(_ic_);
          if (_ic_ !== Not_found) throw _ic_;
          var _ia_ = 1
        }
        by_label[1] = caml_call3(Labs[4], label, _ia_, _h$_);
        return 0
      },
        concr_meths$0,
        concr_meth_labs);
    iter2$0
      (function (met, label) {
        by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
        by_label[1] = caml_call3(Labs[4], label, 0, by_label[1]);
        return 0
      },
        virt_meths$0,
        virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    var _h9_ = 0, _h__ = table[6];
    table[6]
      =
      fold_right
        (function (met, hm) { var lab = met[1]; return mem(lab, virt_meth_labs) ? hm : [0, met, hm] },
          _h__,
          _h9_);
    return 0
  }
  function widen(table) {
    var
    match = hd(table[5]),
    vars = match[6],
    virt_meths = match[5],
    saved_vars = match[4],
    saved_hidden_meths = match[3],
    by_label = match[2],
    by_name = match[1];
    table[5] = tl(table[5]);
    table[7]
      =
      fold_left$0
        (function (s, v) {
          var _h5_ = caml_call2(Vars[28], v, table[7]);
          return caml_call3(Vars[4], v, _h5_, s)
        },
          saved_vars,
          vars);
    table[3] = by_name;
    table[4] = by_label;
    var _h4_ = table[6];
    table[6]
      =
      fold_right
        (function (met, hm) { var lab = met[1]; return mem(lab, virt_meths) ? hm : [0, met, hm] },
          _h4_,
          saved_hidden_meths);
    return 0
  }
  function new_slot(table) { var index = table[1]; table[1] = index + 1 | 0; return index }
  function new_variable(table, name) {
    try { var _h2_ = caml_call2(Vars[28], name, table[7]); return _h2_ }
    catch (_h3_) {
      _h3_ = caml_wrap_exception(_h3_);
      if (_h3_ !== Not_found) throw _h3_;
      var index = new_slot(table);
      if (caml_string_notequal(name, cst$93))
        table[7] = caml_call3(Vars[4], name, index, table[7]);
      return index
    }
  }
  function to_array(arr) { return caml_equal(arr, 0) ? [0] : arr }
  function new_methods_variables(table, meths, vals) {
    var
    meths$0 = to_array(meths),
    nmeths = meths$0.length - 1,
    nvals = vals.length - 1,
    res = caml_make_vect(nmeths + nvals | 0, 0),
    _hU_ = nmeths - 1 | 0,
    _hT_ = 0;
    if (_hU_ >= 0) {
      var i$0 = _hT_;
      for (; ;) {
        var
        _h0_ =
          get_method_label(table, caml_check_bound(meths$0, i$0)[1 + i$0]);
        caml_check_bound(res, i$0)[1 + i$0] = _h0_;
        var _h1_ = i$0 + 1 | 0;
        if (_hU_ !== i$0) { var i$0 = _h1_; continue }
        break
      }
    }
    var _hW_ = nvals - 1 | 0, _hV_ = 0;
    if (_hW_ >= 0) {
      var i = _hV_;
      for (; ;) {
        var
        _hY_ = i + nmeths | 0,
        _hX_ = new_variable(table, caml_check_bound(vals, i)[1 + i]);
        caml_check_bound(res, _hY_)[1 + _hY_] = _hX_;
        var _hZ_ = i + 1 | 0;
        if (_hW_ !== i) { var i = _hZ_; continue }
        break
      }
    }
    return res
  }
  function get_variable(table, name) {
    try { var _hR_ = caml_call2(Vars[28], name, table[7]); return _hR_ }
    catch (_hS_) {
      _hS_ = caml_wrap_exception(_hS_);
      if (_hS_ === Not_found) throw [0, Assert_failure, _cH_];
      throw _hS_
    }
  }
  function get_variables(table, names) { return map$7(function (_hQ_) { return get_variable(table, _hQ_) }, names) }
  function add_initializer(table, f) { table[8] = [0, f, table[8]]; return 0 }
  function create_table(public_methods) {
    if (0 === public_methods) return new_table([0]);
    var
      tags = map$7(public_method_label, public_methods),
      table = new_table(tags);
    iteri$3
      (function (i, met) {
        var lab = (i * 2 | 0) + 2 | 0;
        table[3] = caml_call3(Meths[4], met, lab, table[3]);
        table[4] = caml_call3(Labs[4], lab, 1, table[4]);
        return 0
      },
        public_methods);
    return table
  }
  function init_class(table) {
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = rev(table[8]);
    return resize$1
      (table,
        3 + ((caml_check_bound(table[2], 1)[2] * 16 | 0) / 32 | 0) | 0)
  }
  function inherits(cla, vals, virt_meths, concr_meths, param, top) {
    var env = param[4], super$0 = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
    widen(cla);
    var
      _hL_ = 0,
      _hM_ = to_array(concr_meths),
      _hN_ =
        [0,
          map$7
            (function (nm) { return get_method(cla, get_method_label(cla, nm)) }, _hM_),
          _hL_],
      _hO_ = to_array(vals);
    return caml_array_concat
      ([0,
        [0, init],
        [0,
          map$7(function (_hP_) { return get_variable(cla, _hP_) }, _hO_),
          _hN_]])
  }
  function make_class(pub_meths, class_init) {
    var table = create_table(pub_meths), env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0]
  }
  function make_class_store(pub_meths, class_init, init_table) {
    var table = create_table(pub_meths), env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0
  }
  function dummy_class(loc) {
    function undef(param) { throw [0, Undefined_recursive_module, loc] }
    return [0, undef, undef, undef, 0]
  }
  function create_object(table) {
    var obj = caml_obj_block(248, table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj)
  }
  function create_object_opt(obj_0, table) {
    if (obj_0) return obj_0;
    var obj = caml_obj_block(248, table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj)
  }
  function iter_f(obj, param) {
    var param$0 = param;
    for (; ;) {
      if (!param$0) return 0;
      var l = param$0[2], f = param$0[1];
      caml_call1(f, obj);
      var param$0 = l
    }
  }
  function run_initializers(obj, table) {
    var inits = table[8], _hK_ = 0 !== inits ? 1 : 0;
    return _hK_ ? iter_f(obj, inits) : _hK_
  }
  function run_initializers_opt(obj_0, obj, table) {
    if (obj_0) return obj;
    var inits = table[8];
    if (0 !== inits) iter_f(obj, inits);
    return obj
  }
  function create_object_and_run_initiali(obj_0, table) {
    if (obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj
  }
  function get_data$0(param) { if (param) return param[2]; throw [0, Assert_failure, _cL_] }
  function build_path(n, keys, tables) {
    var res = [0, 0, 0, 0], r = [0, res], _hG_ = 0;
    if (n >= 0) {
      var i = _hG_;
      for (; ;) {
        var _hI_ = r[1];
        r[1] = [0, caml_check_bound(keys, i)[1 + i], _hI_, 0];
        var _hJ_ = i + 1 | 0;
        if (n !== i) { var i = _hJ_; continue }
        break
      }
    }
    var _hH_ = r[1];
    if (!tables) throw [0, Assert_failure, _cI_];
    tables[2] = _hH_;
    return res
  }
  function lookup_tables(root, keys) {
    var tables$2 = get_data$0(root);
    if (!tables$2) return build_path(keys.length - 1 - 1 | 0, keys, root);
    var i$1 = keys.length - 1 - 1 | 0, i = i$1, tables = tables$2;
    a:
    for (; ;) {
      if (0 > i) return tables;
      var key = caml_check_bound(keys, i)[1 + i], tables$0 = tables;
      for (; ;) {
        if (!tables$0) throw [0, Assert_failure, _cK_];
        if (tables$0[1] === key) {
          var tables$1 = get_data$0(tables$0);
          if (!tables$1) throw [0, Assert_failure, _cN_];
          var i$0 = i - 1 | 0, i = i$0, tables = tables$1;
          continue a
        }
        if (!tables$0) throw [0, Assert_failure, _cM_];
        var _hF_ = tables$0[3];
        if (_hF_) { var tables$0 = _hF_; continue }
        var v = [0, key, 0, 0];
        if (!tables$0) throw [0, Assert_failure, _cJ_];
        tables$0[3] = v;
        return build_path(i - 1 | 0, keys, v)
      }
    }
  }
  function new_cache(table) {
    var n = new_method(table), switch$0 = 0;
    if
      (0
      !==
      (n % 2 | 0)
      &&
      (2 + ((caml_check_bound(table[2], 1)[2] * 16 | 0) / 32 | 0) | 0)
      >=
      n) { var n$0 = new_method(table); switch$0 = 1 }
    if (!switch$0) var n$0 = n;
    caml_check_bound(table[2], n$0)[1 + n$0] = 0;
    return n$0
  }
  function set_methods(table, methods) {
    var len = methods.length - 1, i = [0, 0];
    for (; ;) {
      if (i[1] >= len) return 0;
      var
        _hz_ = i[1],
        label = caml_check_bound(methods, _hz_)[1 + _hz_],
        next =
          function (param) {
            i[1]++;
            var _hE_ = i[1];
            return caml_check_bound(methods, _hE_)[1 + _hE_]
          },
        clo = next(0);
      if (typeof clo === "number")
        switch (clo) {
          case 0:
            var
              x = next(0),
              clo$0 = function (x) { return function (obj) { return x } }(x);
            break;
          case 1:
            var
              n = next(0),
              clo$0 = function (n) { return function (obj) { return obj[1 + n] } }(n);
            break;
          case 2:
            var
              e = next(0),
              n$0 = next(0),
              clo$0 =
                function (e, n) { return function (obj) { return obj[1 + e][1 + n] } }
                  (e, n$0);
            break;
          case 3:
            var
              n$1 = next(0),
              clo$0 =
                function (n) { return function (obj) { return caml_call1(obj[1][1 + n], obj) } }
                  (n$1);
            break;
          case 4:
            var
              n$2 = next(0),
              clo$0 =
                function (n) { return function (obj, x) { obj[1 + n] = x; return 0 } }
                  (n$2);
            break;
          case 5:
            var
              f = next(0),
              x$0 = next(0),
              clo$0 =
                function (f, x) { return function (obj) { return caml_call1(f, x) } }
                  (f, x$0);
            break;
          case 6:
            var
              f$0 = next(0),
              n$3 = next(0),
              clo$0 =
                function (f, n) { return function (obj) { return caml_call1(f, obj[1 + n]) } }
                  (f$0, n$3);
            break;
          case 7:
            var
              f$1 = next(0),
              e$0 = next(0),
              n$4 = next(0),
              clo$0 =
                function (f, e, n) { return function (obj) { return caml_call1(f, obj[1 + e][1 + n]) } }
                  (f$1, e$0, n$4);
            break;
          case 8:
            var
              f$2 = next(0),
              n$5 = next(0),
              clo$0 =
                function (f, n) {
                  return function (obj) { return caml_call1(f, caml_call1(obj[1][1 + n], obj)) }
                }
                  (f$2, n$5);
            break;
          case 9:
            var
              f$3 = next(0),
              x$1 = next(0),
              y = next(0),
              clo$0 =
                function (f, x, y) { return function (obj) { return caml_call2(f, x, y) } }
                  (f$3, x$1, y);
            break;
          case 10:
            var
              f$4 = next(0),
              x$2 = next(0),
              n$6 = next(0),
              clo$0 =
                function (f, x, n) { return function (obj) { return caml_call2(f, x, obj[1 + n]) } }
                  (f$4, x$2, n$6);
            break;
          case 11:
            var
              f$5 = next(0),
              x$3 = next(0),
              e$1 = next(0),
              n$7 = next(0),
              clo$0 =
                function (f, x, e, n) {
                  return function (obj) { return caml_call2(f, x, obj[1 + e][1 + n]) }
                }
                  (f$5, x$3, e$1, n$7);
            break;
          case 12:
            var
              f$6 = next(0),
              x$4 = next(0),
              n$8 = next(0),
              clo$0 =
                function (f, x, n) {
                  return function (obj) { return caml_call2(f, x, caml_call1(obj[1][1 + n], obj)) }
                }
                  (f$6, x$4, n$8);
            break;
          case 13:
            var
              f$7 = next(0),
              n$9 = next(0),
              x$5 = next(0),
              clo$0 =
                function (f, n, x) { return function (obj) { return caml_call2(f, obj[1 + n], x) } }
                  (f$7, n$9, x$5);
            break;
          case 14:
            var
              f$8 = next(0),
              e$2 = next(0),
              n$10 = next(0),
              x$6 = next(0),
              clo$0 =
                function (f, e, n, x) {
                  return function (obj) { return caml_call2(f, obj[1 + e][1 + n], x) }
                }
                  (f$8, e$2, n$10, x$6);
            break;
          case 15:
            var
              f$9 = next(0),
              n$11 = next(0),
              x$7 = next(0),
              clo$0 =
                function (f, n, x) {
                  return function (obj) { return caml_call2(f, caml_call1(obj[1][1 + n], obj), x) }
                }
                  (f$9, n$11, x$7);
            break;
          case 16:
            var
              n$12 = next(0),
              x$8 = next(0),
              clo$0 =
                function (n, x) { return function (obj) { return caml_call2(obj[1][1 + n], obj, x) } }
                  (n$12, x$8);
            break;
          case 17:
            var
              n$13 = next(0),
              m = next(0),
              clo$0 =
                function (n, m) {
                  return function (obj) { return caml_call2(obj[1][1 + n], obj, obj[1 + m]) }
                }
                  (n$13, m);
            break;
          case 18:
            var
              n$14 = next(0),
              e$3 = next(0),
              m$0 = next(0),
              clo$0 =
                function (n, e, m) {
                  return function (obj) { return caml_call2(obj[1][1 + n], obj, obj[1 + e][1 + m]) }
                }
                  (n$14, e$3, m$0);
            break;
          case 19:
            var
              n$15 = next(0),
              m$1 = next(0),
              clo$0 =
                function (n, m) {
                  return function (obj) {
                    var _hC_ = caml_call1(obj[1][1 + m], obj);
                    return caml_call2(obj[1][1 + n], obj, _hC_)
                  }
                }
                  (n$15, m$1);
            break;
          case 20:
            var m$2 = next(0), x$9 = next(0);
            new_cache(table);
            var
              clo$0 =
                function (m, x) {
                  return function (obj) { return caml_call1(caml_get_public_method(x, m, 0), x) }
                }
                  (m$2, x$9);
            break;
          case 21:
            var m$3 = next(0), n$16 = next(0);
            new_cache(table);
            var
              clo$0 =
                function (m, n) {
                  return function (obj) {
                    var _hB_ = obj[1 + n];
                    return caml_call1(caml_get_public_method(_hB_, m, 0), _hB_)
                  }
                }
                  (m$3, n$16);
            break;
          case 22:
            var m$4 = next(0), e$4 = next(0), n$17 = next(0);
            new_cache(table);
            var
              clo$0 =
                function (m, e, n) {
                  return function (obj) {
                    var _hA_ = obj[1 + e][1 + n];
                    return caml_call1(caml_get_public_method(_hA_, m, 0), _hA_)
                  }
                }
                  (m$4, e$4, n$17);
            break;
          default:
            var m$5 = next(0), n$18 = next(0);
            new_cache(table);
            var
              clo$0 =
                function (m, n) {
                  return function (obj) {
                    var _hD_ = caml_call1(obj[1][1 + n], obj);
                    return caml_call1(caml_get_public_method(_hD_, m, 0), _hD_)
                  }
                }
                  (m$5, n$18)
        }
      else
        var clo$0 = clo;
      set_method(table, label, clo$0);
      i[1]++
    }
  }
  function stats$0(param) { return [0, table_count[1], method_count[1], inst_var_count[1]] }
  var
    CamlinternalOO =
      [0,
        public_method_label,
        new_method,
        new_variable,
        new_methods_variables,
        get_variable,
        get_variables,
        get_method_label,
        get_method_labels,
        get_method,
        set_method,
        set_methods,
        narrow,
        widen,
        add_initializer,
        dummy_table,
        create_table,
        init_class,
        inherits,
        make_class,
        make_class_store,
        dummy_class,
        copy$7,
        create_object,
        create_object_opt,
        run_initializers,
        run_initializers_opt,
        create_object_and_run_initiali,
        lookup_tables,
        params$0,
        stats$0];
  caml_register_global(821, CamlinternalOO, "CamlinternalOO");
  var Stdlib_Oo = [0, copy$7, public_method_label, public_method_label];
  caml_register_global(822, Stdlib_Oo, "Stdlib__Oo");
  function init_mod_block(loc, comps$0) {
    var
    length = comps$0.length - 1,
    modu = caml_obj_block(0, length),
    _hv_ = length - 1 | 0,
    _hu_ = 0;
    if (_hv_ >= 0) {
      var i = _hu_;
      for (; ;) {
        var shape = caml_check_bound(comps$0, i)[1 + i];
        if (typeof shape === "number")
          switch (shape) {
            case 0:
              var
                fn$0 =
                  function (i) {
                    function fn(x) {
                      var fn$0 = modu[1 + i];
                      if (fn === fn$0) throw [0, Undefined_recursive_module, loc];
                      return caml_call1(fn$0, x)
                    }
                    return fn
                  },
                fn = fn$0(i),
                init = fn;
              break;
            case 1:
              var l = [];
              runtime.caml_update_dummy
                (l,
                  [246,
                    function (l, i) {
                      return function (_hx_) {
                        var l$0 = modu[1 + i];
                        if (l === l$0) throw [0, Undefined_recursive_module, loc];
                        var _hy_ = caml_obj_tag(l$0);
                        return 250 === _hy_
                          ? l$0[1]
                          : 246 === _hy_ ? force_lazy_block(l$0) : l$0
                      }
                    }
                      (l, i)]);
              var init = l;
              break;
            default: var init = dummy_class(loc)
          }
        else
          if (0 === shape[0])
            var comps = shape[1], init = init_mod_block(loc, comps);
          else
            var v = shape[1], init = v;
        modu[1 + i] = init;
        var _hw_ = i + 1 | 0;
        if (_hv_ !== i) { var i = _hw_; continue }
        break
      }
    }
    return modu
  }
  function init_mod(loc, shape) {
    if (typeof shape !== "number" && 0 === shape[0]) { var comps = shape[1]; return init_mod_block(loc, comps) }
    return failwith(cst_CamlinternalMod_init_mod_n)
  }
  function update_mod_block(comps$0, o, n) {
    if (0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1) {
      var _hs_ = comps$0.length - 1 - 1 | 0, _hr_ = 0;
      if (_hs_ >= 0) {
        var i = _hr_;
        for (; ;) {
          var n$0 = n[1 + i], shape = caml_check_bound(comps$0, i)[1 + i];
          if (typeof shape === "number")
            if (2 === shape) {
              var switch$0 = 0;
              if (0 === caml_obj_tag(n$0) && 4 === n$0.length - 1) {
                var cl = o[1 + i], j = 0;
                for (; ;) {
                  cl[1 + j] = n$0[1 + j];
                  var _hq_ = j + 1 | 0;
                  if (3 !== j) { var j = _hq_; continue }
                  break
                }
              }
              else
                switch$0 = 1;
              if (switch$0) throw [0, Assert_failure, _cO_]
            }
            else
              o[1 + i] = n$0;
          else
            if (0 === shape[0]) { var comps = shape[1]; update_mod_block(comps, o[1 + i], n$0) }
          var _ht_ = i + 1 | 0;
          if (_hs_ !== i) { var i = _ht_; continue }
          break
        }
      }
      return 0
    }
    throw [0, Assert_failure, _cP_]
  }
  function update_mod(shape, o, n) {
    if (typeof shape !== "number" && 0 === shape[0]) { var comps = shape[1]; return update_mod_block(comps, o, n) }
    return failwith(cst_CamlinternalMod_update_mod)
  }
  var CamlinternalMod = [0, init_mod, update_mod];
  caml_register_global(823, CamlinternalMod, "CamlinternalMod");
  var
    initial_buffer = caml_create_bytes(32),
    buffer = [0, initial_buffer],
    bufpos = [0, 0];
  function reset_buffer(param) { buffer[1] = initial_buffer; bufpos[1] = 0; return 0 }
  function store(c) {
    if (caml_ml_bytes_length(buffer[1]) <= bufpos[1]) {
      var newbuffer = caml_create_bytes(2 * bufpos[1] | 0);
      blit(buffer[1], 0, newbuffer, 0, bufpos[1]);
      buffer[1] = newbuffer
    }
    caml_bytes_set(buffer[1], bufpos[1], c);
    bufpos[1]++;
    return 0
  }
  function get_string(param) {
    var s = sub_string(buffer[1], 0, bufpos[1]);
    buffer[1] = initial_buffer;
    return s
  }
  function make_lexer(keywords) {
    var kwd_table = caml_call2(Stdlib_Hashtbl[1], 0, 17);
    iter$2
      (function (s) { return caml_call3(Stdlib_Hashtbl[5], kwd_table, s, [0, s]) },
        keywords);
    function ident_or_keyword(id) {
      try { var _ho_ = caml_call2(Stdlib_Hashtbl[6], kwd_table, id); return _ho_ }
      catch (_hp_) {
        _hp_ = caml_wrap_exception(_hp_);
        if (_hp_ === Not_found) return [1, id];
        throw _hp_
      }
    }
    function keyword_or_error(c) {
      var s = make$1(1, c);
      try { var _hm_ = caml_call2(Stdlib_Hashtbl[6], kwd_table, s); return _hm_ }
      catch (_hn_) {
        _hn_ = caml_wrap_exception(_hn_);
        if (_hn_ === Not_found) throw [0, Error, cat(cst_Illegal_character, s)];
        throw _hn_
      }
    }
    function end_exponent_part(strm) {
      for (; ;) {
        var match = peek$0(strm);
        if (match) {
          var _hl_ = match[1];
          if (9 >= _hl_ - 48 >>> 0) { junk(strm); store(_hl_); continue }
        }
        return [0, [3, caml_float_of_string(get_string(0))]]
      }
    }
    function exponent_part(strm) {
      var match = peek$0(strm);
      if (match) {
        var _hk_ = match[1], switch$0 = 0;
        if (43 !== _hk_ && 45 !== _hk_) switch$0 = 1;
        if (!switch$0) { junk(strm); store(_hk_); return end_exponent_part(strm) }
      }
      return end_exponent_part(strm)
    }
    function number(s) {
      for (; ;) {
        var match = peek$0(s);
        if (match) {
          var _hh_ = match[1];
          if (58 <= _hh_) {
            var switch$0 = 0;
            if (69 === _hh_ || 101 === _hh_) switch$0 = 1;
            if (switch$0) { junk(s); store(69); return exponent_part(s) }
          }
          else {
            if (46 === _hh_) {
              junk(s);
              store(46);
              for (; ;) {
                var match$0 = peek$0(s);
                if (match$0) {
                  var _hi_ = match$0[1], _hj_ = _hi_ - 69 | 0;
                  if (32 < _hj_ >>> 0) { if (9 >= _hj_ + 21 >>> 0) { junk(s); store(_hi_); continue } }
                  else
                    if (30 < _hj_ - 1 >>> 0) { junk(s); store(69); return exponent_part(s) }
                }
                return [0, [3, caml_float_of_string(get_string(0))]]
              }
            }
            if (48 <= _hh_) { junk(s); store(_hh_); continue }
          }
        }
        return [0, [2, caml_int_of_string(get_string(0))]]
      }
    }
    function ident2(strm) {
      for (; ;) {
        var match = peek$0(strm);
        if (match) {
          var _hf_ = match[1], switch$0 = 0;
          if (94 <= _hf_) {
            var _hg_ = _hf_ - 95 | 0;
            if (30 < _hg_ >>> 0) { if (32 > _hg_) switch$0 = 1 }
            else
              if (29 === _hg_) switch$0 = 1
          }
          else
            if (65 <= _hf_) { if (92 === _hf_) switch$0 = 1 }
            else
              if (33 <= _hf_)
                switch (_hf_ - 33 | 0) {
                  case 0:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 9:
                  case 10:
                  case 12:
                  case 14:
                  case 25:
                  case 27:
                  case 28:
                  case 29:
                  case 30:
                  case 31: switch$0 = 1; break
                }
          if (switch$0) { junk(strm); store(_hf_); continue }
        }
        return [0, ident_or_keyword(get_string(0))]
      }
    }
    function neg_number(s) {
      var match = peek$0(s);
      if (match) {
        var _he_ = match[1];
        if (9 >= _he_ - 48 >>> 0) { junk(s); reset_buffer(0); store(45); store(_he_); return number(s) }
      }
      reset_buffer(0);
      store(45);
      return ident2(s)
    }
    function ident(strm) {
      for (; ;) {
        var match = peek$0(strm);
        if (match) {
          var _hc_ = match[1], switch$0 = 0;
          if (91 <= _hc_) {
            var _hd_ = _hc_ - 95 | 0;
            if (27 < _hd_ >>> 0) { if (97 <= _hd_) switch$0 = 1 }
            else
              if (1 !== _hd_) switch$0 = 1
          }
          else
            if (48 <= _hc_) { if (6 < _hc_ - 58 >>> 0) switch$0 = 1 }
            else
              if (39 === _hc_) switch$0 = 1;
          if (switch$0) { junk(strm); store(_hc_); continue }
        }
        return [0, ident_or_keyword(get_string(0))]
      }
    }
    function next_token$0(counter, strm) {
      for (; ;) {
        var match = peek$0(strm);
        if (!match) return 0;
        var _g5_ = match[1], switch$0 = 0;
        if (124 <= _g5_) {
          if (127 <= _g5_) { if (192 <= _g5_) switch$0 = 1 }
          else
            if (125 !== _g5_) switch$0 = 2
        }
        else {
          var _g6_ = _g5_ - 65 | 0;
          if (57 < _g6_ >>> 0) {
            if (58 > _g6_)
              switch (_g6_ + 65 | 0) {
                case 34:
                  junk(strm);
                  reset_buffer(0);
                  for (; ;) {
                    var match$1 = peek$0(strm);
                    if (!match$1) throw Failure$0;
                    var _g8_ = match$1[1];
                    if (34 === _g8_) { junk(strm); return [0, [4, get_string(0)]] }
                    if (92 !== _g8_) { junk(strm); store(_g8_); continue }
                    junk(strm);
                    try { var c$0 = escape(strm) }
                    catch (_hb_) {
                      _hb_ = caml_wrap_exception(_hb_);
                      if (_hb_ === Failure$0) throw [0, Error, cst$96];
                      throw _hb_
                    }
                    store(c$0)
                  }
                case 39:
                  junk(strm);
                  try {
                    var match$2 = peek$0(strm);
                    if (!match$2) throw Failure$0;
                    var _g9_ = match$2[1];
                    if (92 === _g9_) {
                      junk(strm);
                      try { var _g__ = escape(strm) }
                      catch (_ha_) {
                        _ha_ = caml_wrap_exception(_ha_);
                        if (_ha_ === Failure$0) throw [0, Error, cst$97];
                        throw _ha_
                      }
                      var c = _g__
                    }
                    else { junk(strm); var c = _g9_ }
                  }
                  catch (_g$_) {
                    _g$_ = caml_wrap_exception(_g$_);
                    if (_g$_ === Failure$0) throw [0, Error, cst$94];
                    throw _g$_
                  }
                  var match$0 = peek$0(strm);
                  if (match$0 && 39 === match$0[1]) { junk(strm); return [0, [5, c]] }
                  throw [0, Error, cst$95];
                case 40:
                  junk(strm);
                  if (counter >= 50)
                    return caml_trampoline_return(maybe_comment, [0, strm]);
                  var counter$0 = counter + 1 | 0;
                  return maybe_comment(counter$0, strm);
                case 45: junk(strm); return neg_number(strm);
                case 9:
                case 10:
                case 12:
                case 13:
                case 26:
                case 32: junk(strm); continue;
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  junk(strm); reset_buffer(0); store(_g5_); return number(strm);
                case 33:
                case 35:
                case 36:
                case 37:
                case 38:
                case 42:
                case 43:
                case 47:
                case 58:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64: switch$0 = 2; break
              }
          }
          else {
            var _g7_ = _g6_ - 26 | 0;
            if (5 < _g7_ >>> 0)
              switch$0 = 1;
            else
              switch (_g7_) { case 4: switch$0 = 1; break; case 1: case 3: switch$0 = 2; break }
          }
        }
        switch (switch$0) {
          case 0: junk(strm); return [0, keyword_or_error(_g5_)];
          case 1: junk(strm); reset_buffer(0); store(_g5_); return ident(strm);
          default: junk(strm); reset_buffer(0); store(_g5_); return ident2(strm)
        }
      }
    }
    function maybe_comment(counter, strm) {
      var match = peek$0(strm);
      if (match && 42 === match[1]) {
        junk(strm);
        comment(strm);
        if (counter >= 50)
          return caml_trampoline_return(next_token$0, [0, strm]);
        var counter$0 = counter + 1 | 0;
        return next_token$0(counter$0, strm)
      }
      return [0, keyword_or_error(40)]
    }
    function next_token(strm) { return caml_trampoline(next_token$0(0, strm)) }
    function escape(strm) {
      var match = peek$0(strm);
      if (!match) throw Failure$0;
      var _g2_ = match[1];
      if (58 <= _g2_) {
        var switcher = _g2_ - 110 | 0;
        if (6 >= switcher >>> 0)
          switch (switcher) {
            case 0: junk(strm); return 10;
            case 4: junk(strm); return 13;
            case 6: junk(strm); return 9
          }
      }
      else
        if (48 <= _g2_) {
          junk(strm);
          var match$0 = peek$0(strm);
          if (match$0) {
            var _g3_ = match$0[1];
            if (9 >= _g3_ - 48 >>> 0) {
              junk(strm);
              var match$1 = peek$0(strm);
              if (match$1) {
                var _g4_ = match$1[1];
                if (9 >= _g4_ - 48 >>> 0) {
                  junk(strm);
                  return chr
                    ((((_g2_ - 48 | 0) * 100 | 0)
                      +
                      ((_g3_ - 48 | 0) * 10 | 0)
                      |
                      0)
                      +
                      (_g4_ - 48 | 0)
                      |
                      0)
                }
              }
              throw [0, Error, cst$99]
            }
          }
          throw [0, Error, cst$98]
        }
      junk(strm);
      return _g2_
    }
    function comment(strm) {
      a:
      for (; ;) {
        var match = peek$0(strm);
        if (!match) throw Failure$0;
        var switcher = match[1] - 40 | 0;
        if (2 >= switcher >>> 0)
          switch (switcher) {
            case 0:
              junk(strm);
              var match$0 = peek$0(strm);
              if (!match$0) throw Failure$0;
              if (42 === match$0[1]) { junk(strm); comment(strm); continue }
              junk(strm);
              continue;
            case 1: break;
            default:
              junk(strm);
              for (; ;) {
                var match$1 = peek$0(strm);
                if (!match$1) throw Failure$0;
                var _g1_ = match$1[1];
                if (41 === _g1_) { junk(strm); return 0 }
                if (42 === _g1_) { junk(strm); continue }
                junk(strm);
                continue a
              }
          }
        junk(strm)
      }
    }
    return function (input) { return from(function (count) { return next_token(input) }) }
  }
  var Stdlib_Genlex = [0, make_lexer];
  caml_register_global(824, Stdlib_Genlex, "Stdlib__Genlex");
  function MakeSeeded$0(H) {
    var prng = [246, function (_g0_) { return caml_call1(_cg_[2], 0) }];
    function create(opt, initial_size) {
      if (opt)
        var sth = opt[1], random = sth;
      else
        var random = caml_call1(Stdlib_Hashtbl[17], 0);
      var x = 16;
      for (; ;) {
        if (initial_size > x && max_array_length >= (x * 2 | 0)) { var x$0 = x * 2 | 0, x = x$0; continue }
        if (random)
          var
            _gY_ = caml_obj_tag(prng),
            _gZ_ = 250 === _gY_ ? prng[1] : 246 === _gY_ ? force_lazy_block(prng) : prng,
            seed = caml_call1(_cg_[4], _gZ_);
        else
          var seed = 0;
        return [0, 0, caml_make_vect(x, 0), seed, x]
      }
    }
    function clear(h) {
      h[1] = 0;
      var len = h[2].length - 1, _gW_ = len - 1 | 0, _gV_ = 0;
      if (_gW_ >= 0) {
        var i = _gV_;
        for (; ;) {
          caml_check_bound(h[2], i)[1 + i] = 0;
          var _gX_ = i + 1 | 0;
          if (_gW_ !== i) { var i = _gX_; continue }
          break
        }
      }
      return 0
    }
    function reset(h) {
      var len = h[2].length - 1;
      return len === h[4]
        ? clear(h)
        : (h[1] = 0, h[2] = caml_make_vect(h[4], 0), 0)
    }
    function copy(init) {
      var _gS_ = init[4], _gT_ = init[3], _gU_ = copy$1(init[2]);
      return [0, init[1], _gU_, _gT_, _gS_]
    }
    function key_index(h, hkey) { return hkey & (h[2].length - 1 - 1 | 0) }
    function clean(h) {
      function do_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) return 0;
          var hkey = param$0[1], rest = param$0[3], c = param$0[2];
          if (caml_call1(H[7], c)) {
            var rest$0 = param$0[3], c$0 = param$0[2];
            return [0, hkey, c$0, do_bucket(rest$0)]
          }
          h[1] = h[1] - 1 | 0;
          var param$0 = rest
        }
      }
      var d = h[2], _gP_ = d.length - 1 - 1 | 0, _gO_ = 0;
      if (_gP_ >= 0) {
        var i = _gO_;
        for (; ;) {
          var _gQ_ = do_bucket(caml_check_bound(d, i)[1 + i]);
          caml_check_bound(d, i)[1 + i] = _gQ_;
          var _gR_ = i + 1 | 0;
          if (_gP_ !== i) { var i = _gR_; continue }
          break
        }
      }
      return 0
    }
    function resize(h) {
      var odata = h[2], osize = odata.length - 1, nsize = osize * 2 | 0;
      clean(h);
      var
        _gH_ = nsize < max_array_length ? 1 : 0,
        _gI_ = _gH_ ? (osize >>> 1 | 0) <= h[1] ? 1 : 0 : _gH_;
      if (_gI_) {
        var ndata = caml_make_vect(nsize, 0);
        h[2] = ndata;
        var
          insert_bucket =
            function (param) {
              if (!param) return 0;
              var rest = param[3], data = param[2], hkey = param[1];
              insert_bucket(rest);
              var
                nidx = key_index(h, hkey),
                _gN_ = [0, hkey, data, caml_check_bound(ndata, nidx)[1 + nidx]];
              caml_check_bound(ndata, nidx)[1 + nidx] = _gN_;
              return 0
            },
          _gK_ = osize - 1 | 0,
          _gJ_ = 0;
        if (_gK_ >= 0) {
          var i = _gJ_;
          for (; ;) {
            insert_bucket(caml_check_bound(odata, i)[1 + i]);
            var _gM_ = i + 1 | 0;
            if (_gK_ !== i) { var i = _gM_; continue }
            break
          }
        }
        var _gL_ = 0
      }
      else
        var _gL_ = _gI_;
      return _gL_
    }
    function add(h, key, info) {
      var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      container = caml_call2(H[1], key, info),
      bucket = [0, hkey, container, caml_check_bound(h[2], i)[1 + i]];
      caml_check_bound(h[2], i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _gG_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      return _gG_ ? resize(h) : _gG_
    }
    function remove(h, key) {
      var hkey = caml_call2(H[2], h[3], key);
      function remove_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) return 0;
          var hk = param$0[1], next = param$0[3], c = param$0[2];
          if (hkey === hk) {
            var match = caml_call2(H[3], c, key);
            switch (match) {
              case 0: h[1] = h[1] - 1 | 0; return next;
              case 1: return [0, hk, c, remove_bucket(next)];
              default: h[1] = h[1] - 1 | 0; var param$0 = next; continue
            }
          }
          var next$0 = param$0[3], c$0 = param$0[2];
          return [0, hk, c$0, remove_bucket(next$0)]
        }
      }
      var
        i = key_index(h, hkey),
        _gF_ = remove_bucket(caml_check_bound(h[2], i)[1 + i]);
      caml_check_bound(h[2], i)[1 + i] = _gF_;
      return 0
    }
    function find(h, key) {
      var
      hkey = caml_call2(H[2], h[3], key),
      _gE_ = key_index(h, hkey),
      param$1 = caml_check_bound(h[2], _gE_)[1 + _gE_],
      param = param$1;
      for (; ;) {
        if (!param) throw Not_found;
        var hk = param[1], rest = param[3], c = param[2];
        if (hkey !== hk) { var param$0 = param[3], param = param$0; continue }
        var match = caml_call2(H[3], c, key);
        switch (match) {
          case 0:
            var match$0 = caml_call1(H[4], c);
            if (match$0) { var d = match$0[1]; return d }
            var param = rest;
            continue;
          case 1: var param = rest; continue;
          default: var param = rest; continue
        }
      }
    }
    function find_opt(h, key) {
      var
      hkey = caml_call2(H[2], h[3], key),
      _gD_ = key_index(h, hkey),
      param$1 = caml_check_bound(h[2], _gD_)[1 + _gD_],
      param = param$1;
      for (; ;) {
        if (!param) return 0;
        var hk = param[1], rest = param[3], c = param[2];
        if (hkey !== hk) { var param$0 = param[3], param = param$0; continue }
        var match = caml_call2(H[3], c, key);
        switch (match) {
          case 0:
            var d = caml_call1(H[4], c); if (d) return d; var param = rest; continue;
          case 1: var param = rest; continue;
          default: var param = rest; continue
        }
      }
    }
    function find_all(h, key) {
      var hkey = caml_call2(H[2], h[3], key);
      function find_in_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) return 0;
          var hk = param$0[1], rest = param$0[3], c = param$0[2];
          if (hkey !== hk) { var param$1 = param$0[3], param$0 = param$1; continue }
          var match = caml_call2(H[3], c, key);
          switch (match) {
            case 0:
              var match$0 = caml_call1(H[4], c);
              if (match$0) { var d = match$0[1]; return [0, d, find_in_bucket(rest)] }
              var param$0 = rest;
              continue;
            case 1: var param$0 = rest; continue;
            default: var param$0 = rest; continue
          }
        }
      }
      var _gC_ = key_index(h, hkey);
      return find_in_bucket(caml_check_bound(h[2], _gC_)[1 + _gC_])
    }
    function replace(h, key, info) {
      var hkey = caml_call2(H[2], h[3], key);
      function replace_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) throw Not_found;
          var hk = param$0[1], next = param$0[3], c = param$0[2];
          if (hkey !== hk) { var param$1 = param$0[3], param$0 = param$1; continue }
          var match = caml_call2(H[3], c, key);
          if (!match) return caml_call3(H[6], c, key, info);
          var param$0 = next
        }
      }
      var i = key_index(h, hkey), l = caml_check_bound(h[2], i)[1 + i];
      try { var _gA_ = replace_bucket(l); return _gA_ }
      catch (_gB_) {
        _gB_ = caml_wrap_exception(_gB_);
        if (_gB_ !== Not_found) throw _gB_;
        var container = caml_call2(H[1], key, info);
        caml_check_bound(h[2], i)[1 + i] = [0, hkey, container, l];
        h[1] = h[1] + 1 | 0;
        var _gz_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
        return _gz_ ? resize(h) : _gz_
      }
    }
    function mem(h, key) {
      var
      hkey = caml_call2(H[2], h[3], key),
      _gy_ = key_index(h, hkey),
      param$1 = caml_check_bound(h[2], _gy_)[1 + _gy_],
      param = param$1;
      for (; ;) {
        if (!param) return 0;
        var hk = param[1], rest = param[3], c = param[2];
        if (hk !== hkey) { var param$0 = param[3], param = param$0; continue }
        var match = caml_call2(H[3], c, key);
        if (!match) return 1;
        var param = rest
      }
    }
    function iter$0(f, h) {
      var d$0 = h[2], _gw_ = d$0.length - 1 - 1 | 0, _gv_ = 0;
      if (_gw_ >= 0) {
        var i = _gv_;
        a:
        for (; ;) {
          var param$0 = caml_check_bound(d$0, i)[1 + i], param = param$0;
          for (; ;) {
            if (param) {
              var
              rest = param[3],
              c = param[2],
              match = caml_call1(H[5], c),
              match$0 = caml_call1(H[4], c),
              switch$0 = 0;
              if (match && match$0) { var d = match$0[1], k = match[1]; caml_call2(f, k, d); switch$0 = 1 }
              var param = rest;
              continue
            }
            var _gx_ = i + 1 | 0;
            if (_gw_ !== i) { var i = _gx_; continue a }
            break
          }
          break
        }
      }
      return 0
    }
    function fold(f, h, init) {
      var d$0 = h[2], accu$1 = [0, init], _gs_ = d$0.length - 1 - 1 | 0, _gr_ = 0;
      if (_gs_ >= 0) {
        var i = _gr_;
        a:
        for (; ;) {
          var
          _gt_ = accu$1[1],
          b$0 = caml_check_bound(d$0, i)[1 + i],
          b = b$0,
          accu = _gt_;
          for (; ;) {
            if (b) {
              var
              rest = b[3],
              c = b[2],
              match = caml_call1(H[5], c),
              match$0 = caml_call1(H[4], c),
              switch$0 = 0;
              if (match && match$0) {
                var d = match$0[1], k = match[1], accu$0 = caml_call3(f, k, d, accu);
                switch$0 = 1
              }
              if (!switch$0) var accu$0 = accu;
              var b = rest, accu = accu$0;
              continue
            }
            accu$1[1] = accu;
            var _gu_ = i + 1 | 0;
            if (_gs_ !== i) { var i = _gu_; continue a }
            break
          }
          break
        }
      }
      return accu$1[1]
    }
    function filter_map_inplace(f, h) {
      function do_bucket(param) {
        var param$0 = param;
        for (; ;) {
          if (!param$0) return 0;
          var
            rest = param$0[3],
            c = param$0[2],
            hk = param$0[1],
            match = caml_call1(H[5], c),
            match$0 = caml_call1(H[4], c);
          if (match && match$0) {
            var d = match$0[1], k = match[1], match$1 = caml_call2(f, k, d);
            if (match$1) {
              var new_d = match$1[1];
              caml_call3(H[6], c, k, new_d);
              return [0, hk, c, do_bucket(rest)]
            }
            var param$0 = rest;
            continue
          }
          var param$0 = rest
        }
      }
      var d = h[2], _go_ = d.length - 1 - 1 | 0, _gn_ = 0;
      if (_go_ >= 0) {
        var i = _gn_;
        for (; ;) {
          var _gp_ = do_bucket(caml_check_bound(d, i)[1 + i]);
          caml_check_bound(d, i)[1 + i] = _gp_;
          var _gq_ = i + 1 | 0;
          if (_go_ !== i) { var i = _gq_; continue }
          break
        }
      }
      return 0
    }
    function length(h) { return h[1] }
    function bucket_length(accu, param) {
      var accu$0 = accu, param$0 = param;
      for (; ;) {
        if (!param$0) return accu$0;
        var
          param$1 = param$0[3],
          accu$1 = accu$0 + 1 | 0,
          accu$0 = accu$1,
          param$0 = param$1
      }
    }
    function stats(h) {
      var
      _gj_ = h[2],
      _gk_ = 0,
      mbl =
        fold_left$3
          (function (m, b) { return max$1(m, bucket_length(0, b)) }, _gk_, _gj_),
      histo = caml_make_vect(mbl + 1 | 0, 0),
      _gl_ = h[2];
      iter$5
        (function (b) {
          var
          l = bucket_length(0, b),
          _gm_ = caml_check_bound(histo, l)[1 + l] + 1 | 0;
          caml_check_bound(histo, l)[1 + l] = _gm_;
          return 0
        },
          _gl_);
      return [0, h[1], h[2].length - 1, mbl, histo]
    }
    function bucket_length_alive(accu, param) {
      var accu$0 = accu, param$0 = param;
      for (; ;) {
        if (!param$0) return accu$0;
        var rest = param$0[3], c = param$0[2];
        if (caml_call1(H[7], c)) { var accu$1 = accu$0 + 1 | 0, accu$0 = accu$1, param$0 = rest; continue }
        var param$1 = param$0[3], param$0 = param$1
      }
    }
    function stats_alive(h) {
      var
      size = [0, 0],
      _gf_ = h[2],
      _gg_ = 0,
      mbl =
        fold_left$3
          (function (m, b) { return max$1(m, bucket_length_alive(0, b)) }, _gg_, _gf_),
      histo = caml_make_vect(mbl + 1 | 0, 0),
      _gh_ = h[2];
      iter$5
        (function (b) {
          var l = bucket_length_alive(0, b);
          size[1] = size[1] + l | 0;
          var _gi_ = caml_check_bound(histo, l)[1 + l] + 1 | 0;
          caml_check_bound(histo, l)[1 + l] = _gi_;
          return 0
        },
          _gh_);
      return [0, size[1], h[2].length - 1, mbl, histo]
    }
    function to_seq(tbl) {
      var tbl_data = tbl[2];
      function aux(i, buck, param) {
        var i$0 = i, buck$0 = buck;
        for (; ;) {
          if (!buck$0) {
            if (i$0 === tbl_data.length - 1) return 0;
            var
              buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
              i$1 = i$0 + 1 | 0,
              i$0 = i$1,
              buck$0 = buck$1;
            continue
          }
          var
            next = buck$0[3],
            c = buck$0[2],
            match = caml_call1(H[5], c),
            match$0 = caml_call1(H[4], c);
          if (match && match$0) {
            var data = match$0[1], key = match[1];
            return [0,
              [0, key, data],
              function (_ge_) { return aux(i$0, next, _ge_) }]
          }
          var buck$0 = next
        }
      }
      var _gb_ = 0, _gc_ = 0;
      return function (_gd_) { return aux(_gc_, _gb_, _gd_) }
    }
    function to_seq_keys(m) {
      var _f9_ = to_seq(m);
      function _f__(_ga_) { return _ga_[1] }
      return function (_f$_) { return map$1(_f__, _f9_, _f$_) }
    }
    function to_seq_values(m) {
      var _f5_ = to_seq(m);
      function _f6_(_f8_) { return _f8_[2] }
      return function (_f7_) { return map$1(_f6_, _f5_, _f7_) }
    }
    function add_seq(tbl, i) {
      return iter
        (function (param) { var v = param[2], k = param[1]; return add(tbl, k, v) },
          i)
    }
    function replace_seq(tbl, i) {
      return iter
        (function (param) { var v = param[2], k = param[1]; return replace(tbl, k, v) },
          i)
    }
    function of_seq(i) { var tbl = create(0, 16); replace_seq(tbl, i); return tbl }
    return [0,
      create,
      clear,
      reset,
      copy,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter$0,
      filter_map_inplace,
      fold,
      length,
      stats,
      to_seq,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq,
      clean,
      stats_alive]
  }
  function create$5(param) { return caml_call1(_o_[1], 1) }
  function get_key$0(t) { return caml_call2(_o_[3], t, 0) }
  function get_key_copy$0(t) { return caml_call2(_o_[4], t, 0) }
  function set_key$0(t, k) { return caml_call3(_o_[5], t, 0, k) }
  function unset_key$0(t) { return caml_call2(_o_[6], t, 0) }
  function check_key$0(t) { return caml_call2(_o_[7], t, 0) }
  function blit_key$0(t1, t2) { return caml_call5(_o_[8], t1, 0, t2, 0, 1) }
  function get_data$1(t) { return caml_call1(_o_[9], t) }
  function get_data_copy(t) { return caml_call1(_o_[10], t) }
  function set_data(t, d) { return caml_call2(_o_[11], t, d) }
  function unset_data(t) { return caml_call1(_o_[12], t) }
  function check_data(t) { return caml_call1(_o_[13], t) }
  function blit_data(t1, t2) { return caml_call2(_o_[14], t1, t2) }
  function make$4(key, data) { var eph = create$5(0); set_data(eph, data); set_key$0(eph, key); return eph }
  function query(eph, key) {
    var match = get_key$0(eph);
    if (!match) return 0;
    var k = match[1];
    return k === key ? get_data$1(eph) : 0
  }
  function MakeSeeded$1(H) {
    function create(k, d) { var c = create$5(0); set_data(c, d); set_key$0(c, k); return c }
    var hash = H[2];
    function equal(c, k) {
      var match = get_key$0(c);
      if (!match) return 2;
      var k$0 = match[1];
      return caml_call2(H[1], k, k$0) ? 0 : 1
    }
    function set_key_data(c, k, d) { unset_data(c); set_key$0(c, k); return set_data(c, d) }
    return MakeSeeded$0
      ([0,
        create,
        hash,
        equal,
        get_data$1,
        get_key$0,
        set_key_data,
        check_key$0])
  }
  function Make$2(H) {
    var equal = H[1];
    function hash(seed, x) { return caml_call1(H[2], x) }
    var
      include = MakeSeeded$1([0, equal, hash]),
      clear = include[2],
      reset = include[3],
      copy = include[4],
      add = include[5],
      remove = include[6],
      find = include[7],
      find_opt = include[8],
      find_all = include[9],
      replace = include[10],
      mem = include[11],
      iter = include[12],
      filter_map_inplace = include[13],
      fold = include[14],
      length = include[15],
      stats = include[16],
      to_seq = include[17],
      to_seq_keys = include[18],
      to_seq_values = include[19],
      add_seq = include[20],
      replace_seq = include[21],
      clean = include[23],
      stats_alive = include[24],
      _f4_ = include[1];
    function create(sz) { return caml_call2(_f4_, _cQ_, sz) }
    function of_seq(i) { var tbl = create(16); caml_call2(replace_seq, tbl, i); return tbl }
    return [0,
      create,
      clear,
      reset,
      copy,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter,
      filter_map_inplace,
      fold,
      length,
      stats,
      to_seq,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq,
      clean,
      stats_alive]
  }
  function make$5(param) { return [0, 0] }
  function add$1(b, k, d) { var _f3_ = b[1]; b[1] = [0, make$4(k, d), _f3_]; return 0 }
  function test_key(k, e) {
    var match = get_key$0(e);
    if (match) { var x = match[1]; if (x === k) return 1 }
    return 0
  }
  function remove$0(b, k) {
    var l = b[1], acc = 0;
    for (; ;) {
      if (!l) return 0;
      var h = l[1], t = l[2];
      if (test_key(k, h)) { b[1] = rev_append(acc, t); return 0 }
      var l$0 = l[2], acc$0 = [0, h, acc], l = l$0, acc = acc$0
    }
  }
  function find$2(b, k) {
    var
    _f1_ = b[1],
    match = find_opt(function (_f2_) { return test_key(k, _f2_) }, _f1_);
    if (!match) return 0;
    var e = match[1];
    return get_data$1(e)
  }
  function length$7(b) { return length$1(b[1]) }
  function clear$3(b) { b[1] = 0; return 0 }
  function create$6(param) { return caml_call1(_o_[1], 2) }
  function get_key1(t) { return caml_call2(_o_[3], t, 0) }
  function get_key1_copy(t) { return caml_call2(_o_[4], t, 0) }
  function set_key1(t, k) { return caml_call3(_o_[5], t, 0, k) }
  function unset_key1(t) { return caml_call2(_o_[6], t, 0) }
  function check_key1(t) { return caml_call2(_o_[7], t, 0) }
  function get_key2(t) { return caml_call2(_o_[3], t, 1) }
  function get_key2_copy(t) { return caml_call2(_o_[4], t, 1) }
  function set_key2(t, k) { return caml_call3(_o_[5], t, 1, k) }
  function unset_key2(t) { return caml_call2(_o_[6], t, 1) }
  function check_key2(t) { return caml_call2(_o_[7], t, 1) }
  function blit_key1(t1, t2) { return caml_call5(_o_[8], t1, 0, t2, 0, 1) }
  function blit_key2(t1, t2) { return caml_call5(_o_[8], t1, 1, t2, 1, 1) }
  function blit_key12(t1, t2) { return caml_call5(_o_[8], t1, 0, t2, 0, 2) }
  function get_data$2(t) { return caml_call1(_o_[9], t) }
  function get_data_copy$0(t) { return caml_call1(_o_[10], t) }
  function set_data$0(t, d) { return caml_call2(_o_[11], t, d) }
  function unset_data$0(t) { return caml_call1(_o_[12], t) }
  function check_data$0(t) { return caml_call1(_o_[13], t) }
  function blit_data$0(t1, t2) { return caml_call2(_o_[14], t1, t2) }
  function make$6(key1, key2, data) {
    var eph = create$6(0);
    set_data$0(eph, data);
    set_key1(eph, key1);
    set_key2(eph, key2);
    return eph
  }
  function query$0(eph, key1, key2) {
    var match = get_key1(eph);
    if (!match) return 0;
    var k = match[1];
    if (k !== key1) return 0;
    var match$0 = get_key2(eph);
    if (!match$0) return 0;
    var k$0 = match$0[1];
    return k$0 === key2 ? get_data$2(eph) : 0
  }
  function MakeSeeded$2(H1, H2) {
    function create(param, d) {
      var k2 = param[2], k1 = param[1], c = create$6(0);
      set_data$0(c, d);
      set_key1(c, k1);
      set_key2(c, k2);
      return c
    }
    function hash(seed, param) {
      var
      k2 = param[2],
      k1 = param[1],
      _f0_ = caml_call2(H2[2], seed, k2) * 65599 | 0;
      return caml_call2(H1[2], seed, k1) + _f0_ | 0
    }
    function equal(c, param) {
      var k2 = param[2], k1 = param[1], match = get_key1(c), match$0 = get_key2(c);
      if (match && match$0) {
        var k2$0 = match$0[1], k1$0 = match[1];
        if (caml_call2(H1[1], k1, k1$0) && caml_call2(H2[1], k2, k2$0)) return 0;
        return 1
      }
      return 2
    }
    function get_key(c) {
      var match = get_key1(c), match$0 = get_key2(c);
      if (match && match$0) { var k2 = match$0[1], k1 = match[1]; return [0, [0, k1, k2]] }
      return 0
    }
    function set_key_data(c, param, d) {
      var k2 = param[2], k1 = param[1];
      unset_data$0(c);
      set_key1(c, k1);
      set_key2(c, k2);
      return set_data$0(c, d)
    }
    function check_key(c) { var _fZ_ = check_key1(c); return _fZ_ ? check_key2(c) : _fZ_ }
    return MakeSeeded$0
      ([0, create, hash, equal, get_data$2, get_key, set_key_data, check_key])
  }
  function Make$3(H1, H2) {
    var equal = H2[1];
    function hash(seed, x) { return caml_call1(H2[2], x) }
    var equal$0 = H1[1], _fX_ = [0, equal, hash];
    function hash$0(seed, x) { return caml_call1(H1[2], x) }
    var
      include = MakeSeeded$2([0, equal$0, hash$0], _fX_),
      clear = include[2],
      reset = include[3],
      copy = include[4],
      add = include[5],
      remove = include[6],
      find = include[7],
      find_opt = include[8],
      find_all = include[9],
      replace = include[10],
      mem = include[11],
      iter = include[12],
      filter_map_inplace = include[13],
      fold = include[14],
      length = include[15],
      stats = include[16],
      to_seq = include[17],
      to_seq_keys = include[18],
      to_seq_values = include[19],
      add_seq = include[20],
      replace_seq = include[21],
      clean = include[23],
      stats_alive = include[24],
      _fY_ = include[1];
    function create(sz) { return caml_call2(_fY_, _cR_, sz) }
    function of_seq(i) { var tbl = create(16); caml_call2(replace_seq, tbl, i); return tbl }
    return [0,
      create,
      clear,
      reset,
      copy,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter,
      filter_map_inplace,
      fold,
      length,
      stats,
      to_seq,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq,
      clean,
      stats_alive]
  }
  function make$7(param) { return [0, 0] }
  function add$2(b, k1, k2, d) { var _fW_ = b[1]; b[1] = [0, make$6(k1, k2, d), _fW_]; return 0 }
  function test_keys(k1, k2, e) {
    var match = get_key1(e), match$0 = get_key2(e);
    if (match && match$0) { var x2 = match$0[1], x1 = match[1]; if (x1 === k1 && x2 === k2) return 1 }
    return 0
  }
  function remove$1(b, k1, k2) {
    var l = b[1], acc = 0;
    for (; ;) {
      if (!l) return 0;
      var h = l[1], t = l[2];
      if (test_keys(k1, k2, h)) { b[1] = rev_append(acc, t); return 0 }
      var l$0 = l[2], acc$0 = [0, h, acc], l = l$0, acc = acc$0
    }
  }
  function find$3(b, k1, k2) {
    var
    _fU_ = b[1],
    match = find_opt(function (_fV_) { return test_keys(k1, k2, _fV_) }, _fU_);
    if (!match) return 0;
    var e = match[1];
    return get_data$2(e)
  }
  function length$8(b) { return length$1(b[1]) }
  function clear$4(b) { b[1] = 0; return 0 }
  function create$7(n) { return caml_call1(_o_[1], n) }
  function length$9(k) { return caml_call1(_o_[2], k) }
  function get_key$1(t, n) { return caml_call2(_o_[3], t, n) }
  function get_key_copy$1(t, n) { return caml_call2(_o_[4], t, n) }
  function set_key$1(t, n, k) { return caml_call3(_o_[5], t, n, k) }
  function unset_key$1(t, n) { return caml_call2(_o_[6], t, n) }
  function check_key$1(t, n) { return caml_call2(_o_[7], t, n) }
  function blit_key$1(t1, o1, t2, o2, l) { return caml_call5(_o_[8], t1, o1, t2, o2, l) }
  function get_data$3(t) { return caml_call1(_o_[9], t) }
  function get_data_copy$1(t) { return caml_call1(_o_[10], t) }
  function set_data$1(t, d) { return caml_call2(_o_[11], t, d) }
  function unset_data$1(t) { return caml_call1(_o_[12], t) }
  function check_data$1(t) { return caml_call1(_o_[13], t) }
  function blit_data$1(t1, t2) { return caml_call2(_o_[14], t1, t2) }
  function make$8(keys, data) {
    var l = keys.length - 1, eph = create$7(l);
    set_data$1(eph, data);
    var _fS_ = l - 1 | 0, _fR_ = 0;
    if (_fS_ >= 0) {
      var i = _fR_;
      for (; ;) {
        set_key$1(eph, i, caml_check_bound(keys, i)[1 + i]);
        var _fT_ = i + 1 | 0;
        if (_fS_ !== i) { var i = _fT_; continue }
        break
      }
    }
    return eph
  }
  function query$1(eph, keys) {
    var l = length$9(eph);
    try {
      if (l !== keys.length - 1) throw Exit;
      var _fN_ = l - 1 | 0, _fM_ = 0;
      if (_fN_ >= 0) {
        var i = _fM_;
        for (; ;) {
          var match = get_key$1(eph, i);
          if (!match) throw Exit;
          var k = match[1];
          if (k !== caml_check_bound(keys, i)[1 + i]) throw Exit;
          var _fP_ = i + 1 | 0;
          if (_fN_ !== i) { var i = _fP_; continue }
          break
        }
      }
      var _fO_ = get_data$3(eph);
      return _fO_
    }
    catch (_fQ_) { _fQ_ = caml_wrap_exception(_fQ_); if (_fQ_ === Exit) return 0; throw _fQ_ }
  }
  function MakeSeeded$3(H) {
    function create(k, d) {
      var c = create$7(k.length - 1);
      set_data$1(c, d);
      var _fK_ = k.length - 1 - 1 | 0, _fJ_ = 0;
      if (_fK_ >= 0) {
        var i = _fJ_;
        for (; ;) {
          set_key$1(c, i, caml_check_bound(k, i)[1 + i]);
          var _fL_ = i + 1 | 0;
          if (_fK_ !== i) { var i = _fL_; continue }
          break
        }
      }
      return c
    }
    function hash(seed, k) {
      var h = [0, 0], _fF_ = k.length - 1 - 1 | 0, _fE_ = 0;
      if (_fF_ >= 0) {
        var i = _fE_;
        for (; ;) {
          var _fG_ = h[1], _fH_ = caml_check_bound(k, i)[1 + i];
          h[1] = (caml_call2(H[2], seed, _fH_) * 65599 | 0) + _fG_ | 0;
          var _fI_ = i + 1 | 0;
          if (_fF_ !== i) { var i = _fI_; continue }
          break
        }
      }
      return h[1]
    }
    function equal(c, k) {
      var len = k.length - 1, len$0 = length$9(c);
      if (len !== len$0) return 1;
      var i$1 = len - 1 | 0, i = i$1;
      for (; ;) {
        if (0 > i) return 0;
        var match = get_key$1(c, i);
        if (!match) return 2;
        var ki = match[1], _fD_ = caml_check_bound(k, i)[1 + i];
        if (!caml_call2(H[1], _fD_, ki)) return 1;
        var i$0 = i - 1 | 0, i = i$0
      }
    }
    function get_key(c) {
      var len = length$9(c);
      if (0 === len) return [0, [0]];
      var match = get_key$1(c, 0);
      if (!match) return 0;
      var k0 = match[1], a = caml_make_vect(len, k0), i$1 = len - 1 | 0, i = i$1;
      for (; ;) {
        if (1 > i) return [0, a];
        var match$0 = get_key$1(c, i);
        if (!match$0) return 0;
        var ki = match$0[1];
        caml_check_bound(a, i)[1 + i] = ki;
        var i$0 = i - 1 | 0, i = i$0
      }
    }
    function set_key_data(c, k, d) {
      unset_data$1(c);
      var _fB_ = k.length - 1 - 1 | 0, _fA_ = 0;
      if (_fB_ >= 0) {
        var i = _fA_;
        for (; ;) {
          set_key$1(c, i, caml_check_bound(k, i)[1 + i]);
          var _fC_ = i + 1 | 0;
          if (_fB_ !== i) { var i = _fC_; continue }
          break
        }
      }
      return set_data$1(c, d)
    }
    function check_key(c) {
      var i$1 = length$9(c) - 1 | 0, i = i$1;
      for (; ;) {
        var _fx_ = i < 0 ? 1 : 0;
        if (_fx_)
          var _fy_ = _fx_;
        else {
          var _fz_ = check_key$1(c, i);
          if (_fz_) { var i$0 = i - 1 | 0, i = i$0; continue }
          var _fy_ = _fz_
        }
        return _fy_
      }
    }
    return MakeSeeded$0
      ([0, create, hash, equal, get_data$3, get_key, set_key_data, check_key])
  }
  function Make$4(H) {
    var equal = H[1];
    function hash(seed, x) { return caml_call1(H[2], x) }
    var
      include = MakeSeeded$3([0, equal, hash]),
      clear = include[2],
      reset = include[3],
      copy = include[4],
      add = include[5],
      remove = include[6],
      find = include[7],
      find_opt = include[8],
      find_all = include[9],
      replace = include[10],
      mem = include[11],
      iter = include[12],
      filter_map_inplace = include[13],
      fold = include[14],
      length = include[15],
      stats = include[16],
      to_seq = include[17],
      to_seq_keys = include[18],
      to_seq_values = include[19],
      add_seq = include[20],
      replace_seq = include[21],
      clean = include[23],
      stats_alive = include[24],
      _fw_ = include[1];
    function create(sz) { return caml_call2(_fw_, _cS_, sz) }
    function of_seq(i) { var tbl = create(16); caml_call2(replace_seq, tbl, i); return tbl }
    return [0,
      create,
      clear,
      reset,
      copy,
      add,
      remove,
      find,
      find_opt,
      find_all,
      replace,
      mem,
      iter,
      filter_map_inplace,
      fold,
      length,
      stats,
      to_seq,
      to_seq_keys,
      to_seq_values,
      add_seq,
      replace_seq,
      of_seq,
      clean,
      stats_alive]
  }
  function make$9(param) { return [0, 0] }
  function add$3(b, k, d) { var _fv_ = b[1]; b[1] = [0, make$8(k, d), _fv_]; return 0 }
  function test_keys$0(k, e) {
    try {
      if (length$9(e) !== k.length - 1) throw Exit;
      var _fr_ = k.length - 1 - 1 | 0, _fq_ = 0;
      if (_fr_ >= 0) {
        var i = _fq_;
        for (; ;) {
          var match = get_key$1(e, i), switch$0 = 0;
          if (match) {
            var x = match[1];
            if (x === caml_check_bound(k, i)[1 + i]) {
              var _ft_ = i + 1 | 0;
              if (_fr_ !== i) { var i = _ft_; continue }
              switch$0 = 1
            }
          }
          if (!switch$0) throw Exit;
          break
        }
      }
      var _fs_ = 1;
      return _fs_
    }
    catch (_fu_) { _fu_ = caml_wrap_exception(_fu_); if (_fu_ === Exit) return 0; throw _fu_ }
  }
  function remove$2(b, k) {
    var l = b[1], acc = 0;
    for (; ;) {
      if (!l) return 0;
      var h = l[1], t = l[2];
      if (test_keys$0(k, h)) { b[1] = rev_append(acc, t); return 0 }
      var l$0 = l[2], acc$0 = [0, h, acc], l = l$0, acc = acc$0
    }
  }
  function find$4(b, k) {
    var
    _fo_ = b[1],
    match = find_opt(function (_fp_) { return test_keys$0(k, _fp_) }, _fo_);
    if (!match) return 0;
    var e = match[1];
    return get_data$3(e)
  }
  function length$10(b) { return length$1(b[1]) }
  function clear$5(b) { b[1] = 0; return 0 }
  var
    Stdlib_Ephemeron =
      [0,
        [0,
          create$5,
          get_key$0,
          get_key_copy$0,
          set_key$0,
          unset_key$0,
          check_key$0,
          blit_key$0,
          get_data$1,
          get_data_copy,
          set_data,
          unset_data,
          check_data,
          blit_data,
          make$4,
          query,
          Make$2,
          MakeSeeded$1,
          [0, make$5, add$1, remove$0, find$2, length$7, clear$3]],
        [0,
          create$6,
          get_key1,
          get_key1_copy,
          set_key1,
          unset_key1,
          check_key1,
          get_key2,
          get_key2_copy,
          set_key2,
          unset_key2,
          check_key2,
          blit_key1,
          blit_key2,
          blit_key12,
          get_data$2,
          get_data_copy$0,
          set_data$0,
          unset_data$0,
          check_data$0,
          blit_data$0,
          make$6,
          query$0,
          Make$3,
          MakeSeeded$2,
          [0, make$7, add$2, remove$1, find$3, length$8, clear$4]],
        [0,
          create$7,
          get_key$1,
          get_key_copy$1,
          set_key$1,
          unset_key$1,
          check_key$1,
          blit_key$1,
          get_data$3,
          get_data_copy$1,
          set_data$1,
          unset_data$1,
          check_data$1,
          blit_data$1,
          make$8,
          query$1,
          Make$4,
          MakeSeeded$3,
          [0, make$9, add$3, remove$2, find$4, length$10, clear$5]],
        [0,
          function (_fn_) {
            return MakeSeeded$0
              ([0, _fn_[3], _fn_[1], _fn_[2], _fn_[5], _fn_[4], _fn_[6], _fn_[7]])
          }]];
  caml_register_global(825, Stdlib_Ephemeron, "Stdlib__Ephemeron");
  function generic_basename(is_dir_sep, current_dir_name, name) {
    if (caml_string_equal(name, cst$100)) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for (; ;) {
      if (0 > n) return sub$0(name, 0, 1);
      if (caml_call2(is_dir_sep, name, n)) { var n$0 = n - 1 | 0, n = n$0; continue }
      var p = n + 1 | 0, n$1 = n;
      for (; ;) {
        if (0 > n$1) return sub$0(name, 0, p);
        if (caml_call2(is_dir_sep, name, n$1))
          return sub$0(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
        var n$2 = n$1 - 1 | 0, n$1 = n$2
      }
    }
  }
  function generic_dirname(is_dir_sep, current_dir_name, name) {
    if (caml_string_equal(name, cst$101)) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for (; ;) {
      if (0 > n) return sub$0(name, 0, 1);
      if (caml_call2(is_dir_sep, name, n)) { var n$0 = n - 1 | 0, n = n$0; continue }
      var n$1 = n;
      for (; ;) {
        if (0 > n$1) return current_dir_name;
        if (!caml_call2(is_dir_sep, name, n$1)) { var n$2 = n$1 - 1 | 0, n$1 = n$2; continue }
        var n$3 = n$1;
        for (; ;) {
          if (0 > n$3) return sub$0(name, 0, 1);
          if (!caml_call2(is_dir_sep, name, n$3))
            return sub$0(name, 0, n$3 + 1 | 0);
          var n$4 = n$3 - 1 | 0, n$3 = n$4
        }
      }
    }
  }
  function is_dir_sep(s, i) { return 47 === caml_string_get(s, i) ? 1 : 0 }
  function is_relative(n) {
    var
    _fl_ = caml_ml_string_length(n) < 1 ? 1 : 0,
    _fm_ = _fl_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    return _fm_
  }
  function is_implicit(n) {
    var _fg_ = is_relative(n);
    if (_fg_) {
      var
      _fh_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _fi_ = _fh_ || caml_string_notequal(sub$0(n, 0, 2), cst$103);
      if (_fi_)
        var
          _fj_ = caml_ml_string_length(n) < 3 ? 1 : 0,
          _fk_ = _fj_ || caml_string_notequal(sub$0(n, 0, 3), cst$102);
      else
        var _fk_ = _fi_
    }
    else
      var _fk_ = _fg_;
    return _fk_
  }
  function check_suffix(name, suff) { return ends_with$0(suff, name) }
  function chop_suffix_opt(suffix, filename) {
    var
    len_s = caml_ml_string_length(suffix),
    len_f = caml_ml_string_length(filename);
    if (len_s > len_f) return 0;
    var r = sub$0(filename, len_f - len_s | 0, len_s);
    return caml_string_equal(r, suffix)
      ? [0, sub$0(filename, 0, len_f - len_s | 0)]
      : 0
  }
  try { var _c1_ = caml_sys_getenv(cst_TMPDIR), _cT_ = _c1_ }
  catch (_ff_) {
    _ff_ = caml_wrap_exception(_ff_);
    if (_ff_ !== Not_found) throw _ff_;
    var _cT_ = cst_tmp
  }
  function quote(s) {
    var l = caml_ml_string_length(s), b = create$2(l + 20 | 0);
    add_char(b, 39);
    var _fd_ = l - 1 | 0, _fc_ = 0;
    if (_fd_ >= 0) {
      var i = _fc_;
      for (; ;) {
        if (39 === caml_string_get(s, i))
          add_string(b, quotequote);
        else
          add_char(b, caml_string_get(s, i));
        var _fe_ = i + 1 | 0;
        if (_fd_ !== i) { var i = _fe_; continue }
        break
      }
    }
    add_char(b, 39);
    return contents(b)
  }
  function quote_command(cmd, stdin, stdout, stderr, args) {
    if (stderr)
      var
        f = stderr[1],
        _e8_ = caml_equal(stderr, stdout) ? cst_2_1 : cat(cst_2, quote(f)),
        _e9_ = _e8_;
    else
      var _e9_ = cst$109;
    if (stdout)
      var f$0 = stdout[1], _e__ = cat(cst$104, quote(f$0));
    else
      var _e__ = cst$108;
    var _e$_ = cat(_e__, _e9_);
    if (stdin)
      var f$1 = stdin[1], _fa_ = cat(cst$105, quote(f$1));
    else
      var _fa_ = cst$107;
    var _fb_ = cat(_fa_, _e$_);
    return cat(concat$1(cst$106, map$4(quote, [0, cmd, args])), _fb_)
  }
  function basename(_e7_) { return generic_basename(is_dir_sep, current_dir_name, _e7_) }
  function dirname(_e6_) { return generic_dirname(is_dir_sep, current_dir_name, _e6_) }
  var
    Unix =
      [0,
        null$0,
        current_dir_name,
        parent_dir_name,
        dir_sep,
        is_dir_sep,
        is_relative,
        is_implicit,
        check_suffix,
        chop_suffix_opt,
        _cT_,
        quote,
        quote_command,
        basename,
        dirname];
  function is_dir_sep$0(s, i) {
    var c = caml_string_get(s, i), _e3_ = 47 === c ? 1 : 0;
    if (_e3_)
      var _e4_ = _e3_;
    else
      var _e5_ = 92 === c ? 1 : 0, _e4_ = _e5_ || (58 === c ? 1 : 0);
    return _e4_
  }
  function is_relative$0(n) {
    var
    _eX_ = caml_ml_string_length(n) < 1 ? 1 : 0,
    _eY_ = _eX_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    if (_eY_) {
      var
      _eZ_ = caml_ml_string_length(n) < 1 ? 1 : 0,
      _e0_ = _eZ_ || (92 !== caml_string_get(n, 0) ? 1 : 0);
      if (_e0_)
        var
          _e1_ = caml_ml_string_length(n) < 2 ? 1 : 0,
          _e2_ = _e1_ || (58 !== caml_string_get(n, 1) ? 1 : 0);
      else
        var _e2_ = _e0_
    }
    else
      var _e2_ = _eY_;
    return _e2_
  }
  function is_implicit$0(n) {
    var _eO_ = is_relative$0(n);
    if (_eO_) {
      var
      _eP_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _eQ_ = _eP_ || caml_string_notequal(sub$0(n, 0, 2), cst$113);
      if (_eQ_) {
        var
        _eR_ = caml_ml_string_length(n) < 2 ? 1 : 0,
        _eS_ = _eR_ || caml_string_notequal(sub$0(n, 0, 2), cst$112);
        if (_eS_) {
          var
          _eT_ = caml_ml_string_length(n) < 3 ? 1 : 0,
          _eU_ = _eT_ || caml_string_notequal(sub$0(n, 0, 3), cst$111);
          if (_eU_)
            var
              _eV_ = caml_ml_string_length(n) < 3 ? 1 : 0,
              _eW_ = _eV_ || caml_string_notequal(sub$0(n, 0, 3), cst$110);
          else
            var _eW_ = _eU_
        }
        else
          var _eW_ = _eS_
      }
      else
        var _eW_ = _eQ_
    }
    else
      var _eW_ = _eO_;
    return _eW_
  }
  function check_suffix$0(name, suff) {
    var _eL_ = caml_ml_string_length(suff) <= caml_ml_string_length(name) ? 1 : 0;
    if (_eL_)
      var
        s =
          sub$0
            (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
        _eM_ = lowercase_ascii$1(suff),
        _eN_ = caml_string_equal(lowercase_ascii$1(s), _eM_);
    else
      var _eN_ = _eL_;
    return _eN_
  }
  function chop_suffix_opt$0(suffix, filename) {
    var
    len_s = caml_ml_string_length(suffix),
    len_f = caml_ml_string_length(filename);
    if (len_s > len_f) return 0;
    var
      r = sub$0(filename, len_f - len_s | 0, len_s),
      _eK_ = lowercase_ascii$1(suffix);
    return caml_string_equal(lowercase_ascii$1(r), _eK_)
      ? [0, sub$0(filename, 0, len_f - len_s | 0)]
      : 0
  }
  try { var _c0_ = caml_sys_getenv(cst_TEMP), temp_dir_name = _c0_ }
  catch (_eJ_) {
    _eJ_ = caml_wrap_exception(_eJ_);
    if (_eJ_ !== Not_found) throw _eJ_;
    var temp_dir_name = cst$114
  }
  function quote$0(s) {
    var l = caml_ml_string_length(s), b = create$2(l + 20 | 0);
    add_char(b, 34);
    function add_bs(n) {
      var _eH_ = 1;
      if (n >= 1) {
        var j = _eH_;
        for (; ;) {
          add_char(b, 92);
          var _eI_ = j + 1 | 0;
          if (n !== j) { var j = _eI_; continue }
          break
        }
      }
      return 0
    }
    function loop$0(counter, i) {
      var i$0 = i;
      for (; ;) {
        if (i$0 === l) return add_char(b, 34);
        var c = caml_string_get(s, i$0);
        if (34 === c) {
          var _eF_ = 0;
          if (counter >= 50)
            return caml_trampoline_return(loop_bs, [0, _eF_, i$0]);
          var counter$1 = counter + 1 | 0;
          return loop_bs(counter$1, _eF_, i$0)
        }
        if (92 !== c) { add_char(b, c); var i$1 = i$0 + 1 | 0, i$0 = i$1; continue }
        var _eG_ = 0;
        if (counter >= 50)
          return caml_trampoline_return(loop_bs, [0, _eG_, i$0]);
        var counter$0 = counter + 1 | 0;
        return loop_bs(counter$0, _eG_, i$0)
      }
    }
    function loop_bs(counter, n, i) {
      var n$0 = n, i$0 = i;
      for (; ;) {
        if (i$0 === l) { add_char(b, 34); return add_bs(n$0) }
        var match = caml_string_get(s, i$0);
        if (34 === match) {
          add_bs((2 * n$0 | 0) + 1 | 0);
          add_char(b, 34);
          var _eE_ = i$0 + 1 | 0;
          if (counter >= 50) return caml_trampoline_return(loop$0, [0, _eE_]);
          var counter$1 = counter + 1 | 0;
          return loop$0(counter$1, _eE_)
        }
        if (92 === match) { var i$1 = i$0 + 1 | 0, n$1 = n$0 + 1 | 0, n$0 = n$1, i$0 = i$1; continue }
        add_bs(n$0);
        if (counter >= 50) return caml_trampoline_return(loop$0, [0, i$0]);
        var counter$0 = counter + 1 | 0;
        return loop$0(counter$0, i$0)
      }
    }
    function loop(i) { return caml_trampoline(loop$0(0, i)) }
    loop(0);
    return contents(b)
  }
  function quote_cmd_filename(f) {
    if (!contains$0(f, 34) && !contains$0(f, 37))
      return contains$0(f, 32) ? cat(cst$116, cat(f, cst$115)) : f;
    return failwith(cat(cst_Filename_quote_command_bad, f))
  }
  function quote_command$0(cmd, stdin, stdout, stderr, args) {
    if (stderr)
      var
        f = stderr[1],
        _ev_ =
          caml_equal(stderr, stdout)
            ? cst_2_1$0
            : cat(cst_2$0, quote_cmd_filename(f)),
        _ew_ = _ev_;
    else
      var _ew_ = cst$125;
    var _ex_ = [0, _ew_, _cU_];
    if (stdout)
      var f$0 = stdout[1], _ey_ = cat(cst$117, quote_cmd_filename(f$0));
    else
      var _ey_ = cst$124;
    var _ez_ = [0, _ey_, _ex_];
    if (stdin)
      var f$1 = stdin[1], _eA_ = cat(cst$118, quote_cmd_filename(f$1));
    else
      var _eA_ = cst$123;
    var
      s = concat$1(cst$119, map$4(quote$0, args)),
      b = create$2(caml_ml_string_length(s) + 20 | 0),
      _eB_ = [0, _eA_, _ez_];
    iter$4
      (function (c) {
        var switch$0 = 0;
        if (62 <= c) {
          var _eD_ = c - 63 | 0;
          if (60 < _eD_ >>> 0) { if (62 > _eD_) switch$0 = 1 }
          else
            if (31 === _eD_) switch$0 = 1
        }
        else
          if (42 <= c) { if (60 === c) switch$0 = 1 }
          else
            if (33 <= c)
              switch (c - 33 | 0) { case 2: case 3: case 6: break; default: switch$0 = 1 }
        return switch$0 ? (add_char(b, 94), add_char(b, c)) : add_char(b, c)
      },
        s);
    var _eC_ = [0, cst$120, [0, contents(b), _eB_]];
    return concat$1(cst$122, [0, cst$121, [0, quote_cmd_filename(cmd), _eC_]])
  }
  function drive_and_path(s) {
    var _er_ = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if (_er_) {
      var param = caml_string_get(s, 0), switch$0 = 0;
      if (91 <= param) { if (25 >= param - 97 >>> 0) switch$0 = 1 }
      else
        if (65 <= param) switch$0 = 1;
      var _es_ = switch$0 ? 1 : 0, _et_ = _es_ ? 58 === caml_string_get(s, 1) ? 1 : 0 : _es_
    }
    else
      var _et_ = _er_;
    if (!_et_) return [0, cst$126, s];
    var _eu_ = sub$0(s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, sub$0(s, 0, 2), _eu_]
  }
  function dirname$0(s) {
    var
    match = drive_and_path(s),
    path = match[2],
    drive = match[1],
    dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return cat(drive, dir)
  }
  function basename$0(s) {
    var match = drive_and_path(s), path = match[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path)
  }
  var
    Win32 =
      [0,
        null$1,
        current_dir_name$0,
        parent_dir_name$0,
        dir_sep$0,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        chop_suffix_opt$0,
        temp_dir_name,
        quote$0,
        quote_command$0,
        basename$0,
        dirname$0];
  function basename$1(_eq_) { return generic_basename(is_dir_sep$0, current_dir_name$1, _eq_) }
  function dirname$1(_ep_) { return generic_dirname(is_dir_sep$0, current_dir_name$1, _ep_) }
  var
    Cygwin =
      [0,
        null$2,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        chop_suffix_opt$0,
        _cT_,
        quote,
        quote_command,
        basename$1,
        dirname$1],
    Sysdeps =
      caml_string_notequal(os_type, cst_Cygwin)
        ? caml_string_notequal(os_type, cst_Win32) ? Unix : Win32
        : Cygwin,
    null$3 = Sysdeps[1],
    current_dir_name$2 = Sysdeps[2],
    parent_dir_name$2 = Sysdeps[3],
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    is_relative$1 = Sysdeps[6],
    is_implicit$1 = Sysdeps[7],
    check_suffix$1 = Sysdeps[8],
    chop_suffix_opt$1 = Sysdeps[9],
    temp_dir_name$0 = Sysdeps[10],
    quote$1 = Sysdeps[11],
    quote_command$1 = Sysdeps[12],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
  function concat$4(dirname, filename) {
    var l = caml_ml_string_length(dirname);
    if (0 !== l && !is_dir_sep$1(dirname, l - 1 | 0))
      return cat(dirname, cat(dir_sep$2, filename));
    return cat(dirname, filename)
  }
  function chop_suffix(name, suff) {
    return check_suffix$1(name, suff)
      ? sub$0
        (name,
          0,
          caml_ml_string_length(name) - caml_ml_string_length(suff) | 0)
      : invalid_arg(cst_Filename_chop_suffix)
  }
  function extension_len(name) {
    var i$4 = caml_ml_string_length(name) - 1 | 0, i$1 = i$4;
    for (; ;) {
      if (0 <= i$1 && !is_dir_sep$1(name, i$1)) {
        if (46 !== caml_string_get(name, i$1)) { var i$3 = i$1 - 1 | 0, i$1 = i$3; continue }
        var i$2 = i$1 - 1 | 0, i = i$2;
        for (; ;) {
          if (0 <= i && !is_dir_sep$1(name, i)) {
            if (46 !== caml_string_get(name, i))
              return caml_ml_string_length(name) - i$1 | 0;
            var i$0 = i - 1 | 0, i = i$0;
            continue
          }
          return 0
        }
      }
      return 0
    }
  }
  function extension(name) {
    var l = extension_len(name);
    return 0 === l ? cst$127 : sub$0(name, caml_ml_string_length(name) - l | 0, l)
  }
  function chop_extension(name) {
    var l = extension_len(name);
    return 0 === l
      ? invalid_arg(cst_Filename_chop_extension)
      : sub$0(name, 0, caml_ml_string_length(name) - l | 0)
  }
  function remove_extension(name) {
    var l = extension_len(name);
    return 0 === l ? name : sub$0(name, 0, caml_ml_string_length(name) - l | 0)
  }
  var prng$0 = [246, function (_eo_) { return caml_call1(_cg_[2], 0) }];
  function temp_file_name(temp_dir, prefix, suffix) {
    var
    _em_ = caml_obj_tag(prng$0),
    _en_ =
      250 === _em_ ? prng$0[1] : 246 === _em_ ? force_lazy_block(prng$0) : prng$0,
    rnd = caml_call1(_cg_[4], _en_) & 16777215;
    return concat$4(temp_dir, caml_call3(sprintf(_cV_), prefix, rnd, suffix))
  }
  var current_temp_dir_name = [0, temp_dir_name$0];
  function set_temp_dir_name(s) { current_temp_dir_name[1] = s; return 0 }
  function get_temp_dir_name(param) { return current_temp_dir_name[1] }
  function temp_file(opt, prefix, suffix) {
    if (opt)
      var sth = opt[1], temp_dir = sth;
    else
      var temp_dir = current_temp_dir_name[1];
    function try_name(counter) {
      var counter$0 = counter;
      for (; ;) {
        var name = temp_file_name(temp_dir, prefix, suffix);
        try { runtime.caml_sys_close(caml_sys_open(name, _cW_, 384)); return name }
        catch (e) {
          e = caml_wrap_exception(e);
          if (e[1] !== Sys_error) throw e;
          if (1000 <= counter$0) throw e;
          var counter$1 = counter$0 + 1 | 0, counter$0 = counter$1;
          continue
        }
      }
    }
    return try_name(0)
  }
  function open_temp_file(opt, _ek_, _ej_, prefix, suffix) {
    if (opt) var sth = opt[1], mode = sth; else var mode = _cX_;
    if (_ek_) var sth$0 = _ek_[1], perms = sth$0; else var perms = 384;
    if (_ej_)
      var sth$1 = _ej_[1], temp_dir = sth$1;
    else
      var temp_dir = current_temp_dir_name[1];
    function try_name(counter) {
      var counter$0 = counter;
      for (; ;) {
        var name = temp_file_name(temp_dir, prefix, suffix);
        try {
          var _el_ = [0, name, open_gen([0, 1, [0, 3, [0, 5, mode]]], perms, name)];
          return _el_
        }
        catch (e) {
          e = caml_wrap_exception(e);
          if (e[1] !== Sys_error) throw e;
          if (1000 <= counter$0) throw e;
          var counter$1 = counter$0 + 1 | 0, counter$0 = counter$1;
          continue
        }
      }
    }
    return try_name(0)
  }
  var
    Stdlib_Filename =
      [0,
        current_dir_name$2,
        parent_dir_name$2,
        dir_sep$2,
        concat$4,
        is_relative$1,
        is_implicit$1,
        check_suffix$1,
        chop_suffix,
        chop_suffix_opt$1,
        extension,
        remove_extension,
        chop_extension,
        basename$2,
        dirname$2,
        null$3,
        temp_file,
        open_temp_file,
        get_temp_dir_name,
        set_temp_dir_name,
        temp_dir_name$0,
        quote$1,
        quote_command$1];
  caml_register_global(826, Stdlib_Filename, "Stdlib__Filename");
  function add$4(x, y) { return [254, x[1] + y[1], x[2] + y[2]] }
  function sub$4(x, y) { return [254, x[1] - y[1], x[2] - y[2]] }
  function neg(x) { return [254, - x[1], - x[2]] }
  function conj(x) { return [254, x[1], - x[2]] }
  function mul(x, y) { return [254, x[1] * y[1] - x[2] * y[2], x[1] * y[2] + x[2] * y[1]] }
  function div(x, y) {
    if (Math.abs(y[2]) <= Math.abs(y[1])) {
      var r = y[2] / y[1], d = y[1] + r * y[2];
      return [254, (x[1] + r * x[2]) / d, (x[2] - r * x[1]) / d]
    }
    var r$0 = y[1] / y[2], d$0 = y[2] + r$0 * y[1];
    return [254, (r$0 * x[1] + x[2]) / d$0, (r$0 * x[2] - x[1]) / d$0]
  }
  function inv(x) { return div(one$4, x) }
  function norm2(x) { return x[1] * x[1] + x[2] * x[2] }
  function norm(x) {
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if (r == 0.) return i;
    if (i == 0.) return r;
    if (i <= r) { var q = i / r; return r * Math.sqrt(1. + q * q) }
    var q$0 = r / i;
    return i * Math.sqrt(1. + q$0 * q$0)
  }
  function arg(x) { return Math.atan2(x[2], x[1]) }
  function polar(n, a) { return [254, Math.cos(a) * n, Math.sin(a) * n] }
  function sqrt(x) {
    if (x[1] == 0. && x[2] == 0.) return _cY_;
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if (i <= r)
      var
        q = i / r,
        w = Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
    else
      var
        q$0 = r / i,
        w = Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
    if (0. <= x[1]) return [254, w, 0.5 * x[2] / w];
    var w$0 = 0. <= x[2] ? w : - w;
    return [254, 0.5 * i / w, w$0]
  }
  function exp(x) { var e = Math.exp(x[1]); return [254, e * Math.cos(x[2]), e * Math.sin(x[2])] }
  function log(x) { var _ei_ = Math.atan2(x[2], x[1]); return [254, Math.log(norm(x)), _ei_] }
  function pow(x, y) { return exp(mul(y, log(x))) }
  var
    Stdlib_Complex =
      [0,
        zero$4,
        one$4,
        i,
        neg,
        conj,
        add$4,
        sub$4,
        mul,
        inv,
        div,
        sqrt,
        norm2,
        norm,
        arg,
        polar,
        exp,
        log,
        pow];
  caml_register_global(827, Stdlib_Complex, "Stdlib__Complex");
  var
    Stdlib_ArrayLabels =
      [0,
        make_float,
        init$3,
        create_matrix,
        create_matrix,
        append$1,
        concat$2,
        sub$1,
        copy$1,
        fill$0,
        blit$1,
        to_list$1,
        of_list,
        iter$5,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$3,
        fold_left_map$0,
        fold_right$2,
        iter2$1,
        map2$1,
        for_all$3,
        exists$3,
        for_all2$1,
        exists2$1,
        mem$0,
        memq$0,
        find_opt$0,
        find_map$1,
        split$0,
        combine$0,
        sort,
        fast_sort$0,
        fast_sort$0,
        to_seq$4,
        to_seqi$1,
        of_seq$2,
        Floatarray];
  caml_register_global(828, Stdlib_ArrayLabels, "Stdlib__ArrayLabels");
  var
    Stdlib_ListLabels =
      [0,
        length$1,
        compare_lengths,
        compare_length_with,
        cons$0,
        hd,
        tl,
        nth,
        nth_opt,
        rev,
        init$0,
        append,
        rev_append,
        flatten,
        flatten,
        equal$6,
        compare$6,
        iter$2,
        iteri$0,
        map$4,
        mapi$0,
        rev_map,
        filter_map$0,
        concat_map,
        fold_left_map,
        fold_left$0,
        fold_right,
        iter2$0,
        map2$0,
        rev_map2,
        fold_left2$0,
        fold_right2,
        for_all$0,
        exists$0,
        for_all2$0,
        exists2$0,
        mem,
        memq,
        find$0,
        find_opt,
        find_map$0,
        find_all,
        find_all,
        filteri,
        partition$0,
        partition_map$0,
        assoc,
        assoc_opt,
        assq,
        assq_opt,
        mem_assoc,
        mem_assq,
        remove_assoc,
        remove_assq,
        split,
        combine,
        fast_sort,
        fast_sort,
        fast_sort,
        sort_uniq,
        merge,
        to_seq$1,
        of_seq];
  caml_register_global(829, Stdlib_ListLabels, "Stdlib__ListLabels");
  var
    Stdlib_BytesLabels =
      [0,
        make$0,
        init$1,
        empty$0,
        copy,
        to_bytes,
        of_bytes,
        sub,
        sub_string,
        extend,
        fill,
        blit,
        blit$0,
        concat$0,
        cat$0,
        iter$3,
        iteri$1,
        map$5,
        mapi$1,
        fold_left$1,
        fold_right$0,
        for_all$1,
        exists$1,
        trim,
        escaped$0,
        index,
        index_opt,
        rindex,
        rindex_opt,
        index_from,
        index_from_opt,
        rindex_from,
        rindex_from_opt,
        contains,
        contains_from,
        rcontains_from,
        uppercase$0,
        lowercase$0,
        capitalize,
        uncapitalize,
        uppercase_ascii$0,
        lowercase_ascii$0,
        capitalize_ascii,
        uncapitalize_ascii,
        compare$8,
        equal$8,
        starts_with,
        ends_with,
        unsafe_to_string,
        unsafe_of_string,
        split_on_char,
        to_seq$2,
        to_seqi,
        of_seq$0,
        get_utf_8_uchar,
        set_utf_8_uchar,
        is_valid_utf_8,
        get_utf_16be_uchar,
        set_utf_16be_uchar,
        is_valid_utf_16be,
        get_utf_16le_uchar,
        set_utf_16le_uchar,
        is_valid_utf_16le,
        get_uint8,
        get_int8,
        get_uint16_ne,
        get_uint16_be,
        get_uint16_le,
        get_int16_ne,
        get_int16_be,
        get_int16_le,
        get_int32_ne,
        get_int32_be,
        get_int32_le,
        get_int64_ne,
        get_int64_be,
        get_int64_le,
        set_uint8,
        set_int8,
        set_uint16_ne,
        set_int16_be,
        set_int16_le,
        set_int16_ne,
        set_int16_be,
        set_int16_le,
        set_int32_ne,
        set_int32_be,
        set_int32_le,
        set_int64_ne,
        set_int64_be,
        set_int64_le];
  caml_register_global(830, Stdlib_BytesLabels, "Stdlib__BytesLabels");
  var
    Stdlib_StringLabels =
      [0,
        make$1,
        init$2,
        empty$1,
        of_bytes,
        to_bytes,
        concat$1,
        cat,
        equal$9,
        compare$9,
        starts_with$0,
        ends_with$0,
        contains_from$0,
        rcontains_from$0,
        contains$0,
        sub$0,
        split_on_char$0,
        map$6,
        mapi$2,
        fold_left$2,
        fold_right$1,
        for_all$2,
        exists$2,
        trim$0,
        escaped$1,
        uppercase_ascii$1,
        lowercase_ascii$1,
        capitalize_ascii$0,
        uncapitalize_ascii$0,
        iter$4,
        iteri$2,
        index_from$0,
        index_from_opt$0,
        rindex_from$0,
        rindex_from_opt$0,
        index$0,
        index_opt$0,
        rindex$0,
        rindex_opt$0,
        to_seq$3,
        to_seqi$0,
        of_seq$1,
        get_utf_8_uchar$0,
        is_valid_utf_8$0,
        get_utf_16be_uchar$0,
        is_valid_utf_16be$0,
        get_utf_16le_uchar$0,
        is_valid_utf_16le$0,
        blit$0,
        copy$0,
        fill,
        uppercase$1,
        lowercase$1,
        capitalize$0,
        uncapitalize$0,
        get_uint8$0,
        get_int8$0,
        get_uint16_ne$0,
        get_uint16_be$0,
        get_uint16_le$0,
        get_int16_ne$0,
        get_int16_be$0,
        get_int16_le$0,
        get_int32_ne$0,
        get_int32_be$0,
        get_int32_le$0,
        get_int64_ne$0,
        get_int64_be$0,
        get_int64_le$0];
  caml_register_global(831, Stdlib_StringLabels, "Stdlib__StringLabels");
  var Stdlib_MoreLabels = [0, Stdlib_Hashtbl, Stdlib_Map, Stdlib_Set];
  caml_register_global(832, Stdlib_MoreLabels, "Stdlib__MoreLabels");
  var Stdlib_StdLabels = [0];
  caml_register_global(833, Stdlib_StdLabels, "Stdlib__StdLabels");
  var
    float32 = 0,
    float64 = 1,
    int8_signed = 2,
    int8_unsigned = 3,
    int16_signed = 4,
    int16_unsigned = 5,
    int32$1 = 6,
    int64$1 = 7,
    int$2 = 8,
    nativeint$1 = 9,
    complex32 = 10,
    complex64 = 11,
    char$0 = 12;
  function kind_size_in_bytes(param) {
    switch (param) {
      case 0: return 4;
      case 1: return 8;
      case 2: return 1;
      case 3: return 1;
      case 4: return 2;
      case 5: return 2;
      case 6: return 4;
      case 7: return 8;
      case 8: return 4;
      case 9: return 4;
      case 10: return 8;
      case 11: return 16;
      default: return 1
    }
  }
  var c_layout = 0, fortran_layout = 1;
  function cloop(arr, idx, f, col, max) {
    if (col === idx.length - 1)
      return caml_ba_set_generic(arr, idx, caml_call1(f, idx));
    var _eg_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _ef_ = 0;
    if (_eg_ >= 0) {
      var j = _ef_;
      for (; ;) {
        caml_check_bound(idx, col)[1 + col] = j;
        cloop(arr, idx, f, col + 1 | 0, max);
        var _eh_ = j + 1 | 0;
        if (_eg_ !== j) { var j = _eh_; continue }
        break
      }
    }
    return 0
  }
  function floop(arr, idx, f, col, max) {
    if (0 > col) return caml_ba_set_generic(arr, idx, caml_call1(f, idx));
    var _ed_ = caml_check_bound(max, col)[1 + col], _ec_ = 1;
    if (_ed_ >= 1) {
      var j = _ec_;
      for (; ;) {
        caml_check_bound(idx, col)[1 + col] = j;
        floop(arr, idx, f, col - 1 | 0, max);
        var _ee_ = j + 1 | 0;
        if (_ed_ !== j) { var j = _ee_; continue }
        break
      }
    }
    return 0
  }
  function init$6(kind, layout, dims, f) {
    var arr = caml_ba_create(kind, layout, dims), dlen = dims.length - 1;
    return 0 === dlen
      ? arr
      : layout
        ? (floop(arr, caml_make_vect(dlen, 1), f, dlen - 1 | 0, dims), arr)
        : (cloop(arr, caml_make_vect(dlen, 0), f, 0, dims), arr)
  }
  function dims(a) {
    var n = caml_ba_num_dims(a), d = caml_make_vect(n, 0), _d$_ = n - 1 | 0, _d__ = 0;
    if (_d$_ >= 0) {
      var i = _d__;
      for (; ;) {
        var _ea_ = runtime.caml_ba_dim(a, i);
        caml_check_bound(d, i)[1 + i] = _ea_;
        var _eb_ = i + 1 | 0;
        if (_d$_ !== i) { var i = _eb_; continue }
        break
      }
    }
    return d
  }
  function size_in_bytes(arr) {
    var _d9_ = fold_left$3(caml_mul, 1, dims(arr));
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _d9_)
  }
  function create$8(kind, layout) { return caml_ba_create(kind, layout, [0]) }
  function get$3(arr) { return runtime.caml_ba_get_generic(arr, [0]) }
  function set$2(arr) {
    var _d7_ = [0];
    return function (_d8_) { return caml_ba_set_generic(arr, _d7_, _d8_) }
  }
  function size_in_bytes$0(arr) { return kind_size_in_bytes(caml_ba_kind(arr)) }
  function of_value(kind, layout, v) { var a = create$8(kind, layout); caml_call1(set$2(a), v); return a }
  function create$9(kind, layout, dim) { return caml_ba_create(kind, layout, [0, dim]) }
  function size_in_bytes$1(arr) {
    var _d6_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _d6_)
  }
  function slice(a, n) {
    var match = runtime.caml_ba_layout(a);
    return match ? caml_ba_slice(a, [0, n]) : caml_ba_slice(a, [0, n])
  }
  function init$7(kind, layout, dim, f) {
    var arr = create$9(kind, layout, dim);
    if (layout) {
      var _d4_ = 1;
      if (dim >= 1) {
        var i$0 = _d4_;
        for (; ;) {
          caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
          var _d5_ = i$0 + 1 | 0;
          if (dim !== i$0) { var i$0 = _d5_; continue }
          break
        }
      }
      return arr
    }
    var _d2_ = dim - 1 | 0, _d1_ = 0;
    if (_d2_ >= 0) {
      var i = _d1_;
      for (; ;) {
        caml_ba_set_1(arr, i, caml_call1(f, i));
        var _d3_ = i + 1 | 0;
        if (_d2_ !== i) { var i = _d3_; continue }
        break
      }
    }
    return arr
  }
  function of_array(kind, layout, data) {
    var
    ba = create$9(kind, layout, data.length - 1),
    ofs = layout ? 1 : 0,
    _dZ_ = data.length - 1 - 1 | 0,
    _dY_ = 0;
    if (_dZ_ >= 0) {
      var i = _dY_;
      for (; ;) {
        caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
        var _d0_ = i + 1 | 0;
        if (_dZ_ !== i) { var i = _d0_; continue }
        break
      }
    }
    return ba
  }
  function create$10(kind, layout, dim1, dim2) { return caml_ba_create(kind, layout, [0, dim1, dim2]) }
  function size_in_bytes$2(arr) {
    var _dW_ = caml_ba_dim_2(arr), _dX_ = caml_ba_dim_1(arr);
    return caml_mul
      (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _dX_), _dW_)
  }
  function slice_left(a, n) { return caml_ba_slice(a, [0, n]) }
  function slice_right(a, n) { return caml_ba_slice(a, [0, n]) }
  function init$8(kind, layout, dim1, dim2, f) {
    var arr = create$10(kind, layout, dim1, dim2);
    if (layout) {
      var _dS_ = 1;
      if (dim2 >= 1) {
        var j$0 = _dS_;
        for (; ;) {
          var _dT_ = 1;
          if (dim1 >= 1) {
            var i$0 = _dT_;
            for (; ;) {
              caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
              var _dV_ = i$0 + 1 | 0;
              if (dim1 !== i$0) { var i$0 = _dV_; continue }
              break
            }
          }
          var _dU_ = j$0 + 1 | 0;
          if (dim2 !== j$0) { var j$0 = _dU_; continue }
          break
        }
      }
      return arr
    }
    var _dN_ = dim1 - 1 | 0, _dM_ = 0;
    if (_dN_ >= 0) {
      var i = _dM_;
      for (; ;) {
        var _dP_ = dim2 - 1 | 0, _dO_ = 0;
        if (_dP_ >= 0) {
          var j = _dO_;
          for (; ;) {
            caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
            var _dR_ = j + 1 | 0;
            if (_dP_ !== j) { var j = _dR_; continue }
            break
          }
        }
        var _dQ_ = i + 1 | 0;
        if (_dN_ !== i) { var i = _dQ_; continue }
        break
      }
    }
    return arr
  }
  function of_array$0(kind, layout, data) {
    var
    dim1 = data.length - 1,
    dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
    ba = create$10(kind, layout, dim1, dim2),
    ofs = layout ? 1 : 0,
    _dH_ = dim1 - 1 | 0,
    _dG_ = 0;
    if (_dH_ >= 0) {
      var i = _dG_;
      for (; ;) {
        var row = caml_check_bound(data, i)[1 + i];
        if (row.length - 1 !== dim2)
          invalid_arg(cst_Bigarray_Array2_of_array_n);
        var _dJ_ = dim2 - 1 | 0, _dI_ = 0;
        if (_dJ_ >= 0) {
          var j = _dI_;
          for (; ;) {
            caml_ba_set_2
              (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
            var _dL_ = j + 1 | 0;
            if (_dJ_ !== j) { var j = _dL_; continue }
            break
          }
        }
        var _dK_ = i + 1 | 0;
        if (_dH_ !== i) { var i = _dK_; continue }
        break
      }
    }
    return ba
  }
  function create$11(kind, layout, dim1, dim2, dim3) { return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]) }
  function size_in_bytes$3(arr) {
    var
    _dD_ = runtime.caml_ba_dim_3(arr),
    _dE_ = caml_ba_dim_2(arr),
    _dF_ = caml_ba_dim_1(arr);
    return caml_mul
      (caml_mul
        (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _dF_), _dE_),
        _dD_)
  }
  function slice_left_1(a, n, m) { return caml_ba_slice(a, [0, n, m]) }
  function slice_right_1(a, n, m) { return caml_ba_slice(a, [0, n, m]) }
  function slice_left_2(a, n) { return caml_ba_slice(a, [0, n]) }
  function slice_right_2(a, n) { return caml_ba_slice(a, [0, n]) }
  function init$9(kind, layout, dim1, dim2, dim3, f) {
    var arr = create$11(kind, layout, dim1, dim2, dim3);
    if (layout) {
      var _dx_ = 1;
      if (dim3 >= 1) {
        var k$0 = _dx_;
        for (; ;) {
          var _dy_ = 1;
          if (dim2 >= 1) {
            var j$0 = _dy_;
            for (; ;) {
              var _dA_ = 1;
              if (dim1 >= 1) {
                var i$0 = _dA_;
                for (; ;) {
                  caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
                  var _dC_ = i$0 + 1 | 0;
                  if (dim1 !== i$0) { var i$0 = _dC_; continue }
                  break
                }
              }
              var _dB_ = j$0 + 1 | 0;
              if (dim2 !== j$0) { var j$0 = _dB_; continue }
              break
            }
          }
          var _dz_ = k$0 + 1 | 0;
          if (dim3 !== k$0) { var k$0 = _dz_; continue }
          break
        }
      }
      return arr
    }
    var _dp_ = dim1 - 1 | 0, _do_ = 0;
    if (_dp_ >= 0) {
      var i = _do_;
      for (; ;) {
        var _dr_ = dim2 - 1 | 0, _dq_ = 0;
        if (_dr_ >= 0) {
          var j = _dq_;
          for (; ;) {
            var _du_ = dim3 - 1 | 0, _dt_ = 0;
            if (_du_ >= 0) {
              var k = _dt_;
              for (; ;) {
                caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
                var _dw_ = k + 1 | 0;
                if (_du_ !== k) { var k = _dw_; continue }
                break
              }
            }
            var _dv_ = j + 1 | 0;
            if (_dr_ !== j) { var j = _dv_; continue }
            break
          }
        }
        var _ds_ = i + 1 | 0;
        if (_dp_ !== i) { var i = _ds_; continue }
        break
      }
    }
    return arr
  }
  function of_array$1(kind, layout, data) {
    var
    dim1 = data.length - 1,
    dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
    dim3 =
      0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
    ba = create$11(kind, layout, dim1, dim2, dim3),
    ofs = layout ? 1 : 0,
    _dg_ = dim1 - 1 | 0,
    _df_ = 0;
    if (_dg_ >= 0) {
      var i = _df_;
      for (; ;) {
        var row = caml_check_bound(data, i)[1 + i];
        if (row.length - 1 !== dim2)
          invalid_arg(cst_Bigarray_Array3_of_array_n);
        var _di_ = dim2 - 1 | 0, _dh_ = 0;
        if (_di_ >= 0) {
          var j = _dh_;
          for (; ;) {
            var col = caml_check_bound(row, j)[1 + j];
            if (col.length - 1 !== dim3)
              invalid_arg(cst_Bigarray_Array3_of_array_n$0);
            var _dl_ = dim3 - 1 | 0, _dk_ = 0;
            if (_dl_ >= 0) {
              var k = _dk_;
              for (; ;) {
                caml_ba_set_3
                  (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col, k)[1 + k]);
                var _dn_ = k + 1 | 0;
                if (_dl_ !== k) { var k = _dn_; continue }
                break
              }
            }
            var _dm_ = j + 1 | 0;
            if (_di_ !== j) { var j = _dm_; continue }
            break
          }
        }
        var _dj_ = i + 1 | 0;
        if (_dg_ !== i) { var i = _dj_; continue }
        break
      }
    }
    return ba
  }
  function array0_of_genarray(a) {
    return 0 === caml_ba_num_dims(a)
      ? a
      : invalid_arg(cst_Bigarray_array0_of_genarra)
  }
  function array1_of_genarray(a) {
    return 1 === caml_ba_num_dims(a)
      ? a
      : invalid_arg(cst_Bigarray_array1_of_genarra)
  }
  function array2_of_genarray(a) {
    return 2 === caml_ba_num_dims(a)
      ? a
      : invalid_arg(cst_Bigarray_array2_of_genarra)
  }
  function array3_of_genarray(a) {
    return 3 === caml_ba_num_dims(a)
      ? a
      : invalid_arg(cst_Bigarray_array3_of_genarra)
  }
  function reshape_0(a) { return caml_ba_reshape(a, [0]) }
  function reshape_1(a, dim1) { return caml_ba_reshape(a, [0, dim1]) }
  function reshape_2(a, dim1, dim2) { return caml_ba_reshape(a, [0, dim1, dim2]) }
  function reshape_3(a, dim1, dim2, dim3) { return caml_ba_reshape(a, [0, dim1, dim2, dim3]) }
  var
    Stdlib_Bigarray =
      [0,
        float32,
        float64,
        complex32,
        complex64,
        int8_signed,
        int8_unsigned,
        int16_signed,
        int16_unsigned,
        int$2,
        int32$1,
        int64$1,
        nativeint$1,
        char$0,
        kind_size_in_bytes,
        c_layout,
        fortran_layout,
        [0, init$6, dims, size_in_bytes],
        [0,
          create$8,
          of_value,
          caml_ba_change_layout,
          size_in_bytes$0,
          get$3,
          set$2,
          of_value],
        [0,
          create$9,
          init$7,
          caml_ba_change_layout,
          size_in_bytes$1,
          slice,
          of_array],
        [0,
          create$10,
          init$8,
          caml_ba_change_layout,
          size_in_bytes$2,
          slice_left,
          slice_right,
          of_array$0],
        [0,
          create$11,
          init$9,
          caml_ba_change_layout,
          size_in_bytes$3,
          slice_left_1,
          slice_right_1,
          slice_left_2,
          slice_right_2,
          of_array$1],
        array0_of_genarray,
        array1_of_genarray,
        array2_of_genarray,
        array3_of_genarray,
        caml_ba_reshape,
        reshape_0,
        reshape_1,
        reshape_2,
        reshape_3];
  caml_register_global(834, Stdlib_Bigarray, "Stdlib__Bigarray");
  function with_open(openfun, s, f) {
    var ic = caml_call1(openfun, s);
    function _de_(param) { return caml_call1(f, ic) }
    return protect(function (param) { return close_noerr$0(ic) }, _de_)
  }
  function with_open_bin(s, f) { return with_open(open_bin$0, s, f) }
  function with_open_text(s, f) { return with_open(open_text$0, s, f) }
  function with_open_gen(flags, perm, s, f) { return with_open(function (_dd_) { return open_gen$0(flags, perm, _dd_) }, s, f) }
  var seek = _m_[4], pos = _m_[5], length$11 = _m_[6];
  function input_char$0(ic) {
    try { var c = caml_ml_input_char(ic) }
    catch (_dc_) {
      _dc_ = caml_wrap_exception(_dc_);
      if (_dc_ === End_of_file) return 0;
      throw _dc_
    }
    return [0, c]
  }
  function input_byte$0(ic) {
    try { var n = caml_ml_input_char(ic) }
    catch (_db_) {
      _db_ = caml_wrap_exception(_db_);
      if (_db_ === End_of_file) return 0;
      throw _db_
    }
    return [0, n]
  }
  function input_line$0(ic) {
    try { var s = input_line(ic) }
    catch (_da_) {
      _da_ = caml_wrap_exception(_da_);
      if (_da_ === End_of_file) return 0;
      throw _da_
    }
    return [0, s]
  }
  function really_input$0(ic, buf, pos, len) {
    try { really_input(ic, buf, pos, len); return _cZ_ }
    catch (_c$_) {
      _c$_ = caml_wrap_exception(_c$_);
      if (_c$_ === End_of_file) return 0;
      throw _c$_
    }
  }
  function really_input_string$0(ic, len) {
    try { var s = really_input_string(ic, len) }
    catch (_c__) {
      _c__ = caml_wrap_exception(_c__);
      if (_c__ === End_of_file) return 0;
      throw _c__
    }
    return [0, s]
  }
  function read_upto(ic, buf, ofs, len) {
    var ofs$0 = ofs, len$0 = len;
    for (; ;) {
      if (0 !== len$0) {
        var r = input(ic, buf, ofs$0, len$0);
        if (0 !== r) {
          var
          len$1 = len$0 - r | 0,
          ofs$1 = ofs$0 + r | 0,
          ofs$0 = ofs$1,
          len$0 = len$1;
          continue
        }
      }
      return ofs$0 - ofs | 0
    }
  }
  function ensure(buf, ofs, n) {
    var len = caml_ml_bytes_length(buf);
    if ((ofs + n | 0) <= len) return buf;
    var new_len = [0, len];
    for (; ;) {
      if (new_len[1] < (ofs + n | 0)) { new_len[1] = (2 * new_len[1] | 0) + 1 | 0; continue }
      var
        new_len$0 = new_len[1],
        new_len$1 =
          new_len$0 <= max_string_length
            ? new_len$0
            : ofs < max_string_length
              ? max_string_length
              : failwith(cst_In_channel_input_all_chann),
        new_buf = caml_create_bytes(new_len$1);
      blit(buf, 0, new_buf, 0, ofs);
      return new_buf
    }
  }
  function input_all(ic) {
    var chunk_size = 65536;
    try {
      var
      _c6_ = caml_ml_pos_in(ic),
      _c7_ = caml_ml_channel_size(ic) - _c6_ | 0,
      initial_size = _c7_
    }
    catch (_c9_) {
      _c9_ = caml_wrap_exception(_c9_);
      if (_c9_[1] !== Sys_error) throw _c9_;
      var initial_size = -1
    }
    var
      initial_size$0 = 0 <= initial_size ? initial_size : chunk_size,
      initial_size$1 =
        initial_size$0 <= max_string_length ? initial_size$0 : max_string_length,
      buf = caml_create_bytes(initial_size$1),
      nread = read_upto(ic, buf, 0, initial_size$1);
    if (nread < initial_size$1) return sub_string(buf, 0, nread);
    try { var c = caml_ml_input_char(ic) }
    catch (_c8_) {
      _c8_ = caml_wrap_exception(_c8_);
      if (_c8_ === End_of_file) return caml_string_of_bytes(buf);
      throw _c8_
    }
    function loop(buf, ofs) {
      var buf$0 = buf, ofs$0 = ofs;
      for (; ;) {
        var
        buf$1 = ensure(buf$0, ofs$0, chunk_size),
        rem = caml_ml_bytes_length(buf$1) - ofs$0 | 0,
        r = read_upto(ic, buf$1, ofs$0, rem);
        if (r < rem) return sub_string(buf$1, 0, ofs$0 + r | 0);
        var ofs$1 = ofs$0 + rem | 0, buf$0 = buf$1, ofs$0 = ofs$1
      }
    }
    var buf$0 = ensure(buf, nread, 65537);
    caml_bytes_set(buf$0, nread, c);
    return loop(buf$0, nread + 1 | 0)
  }
  var
    Stdlib_In_channel =
      [0,
        stdin,
        open_bin$0,
        open_text$0,
        open_gen$0,
        with_open_bin,
        with_open_text,
        with_open_gen,
        seek,
        pos,
        length$11,
        close$0,
        close_noerr$0,
        input_char$0,
        input_byte$0,
        input_line$0,
        input,
        really_input$0,
        really_input_string$0,
        input_all,
        set_binary_mode];
  caml_register_global(835, Stdlib_In_channel, "Stdlib__In_channel");
  function with_open$0(openfun, s, f) {
    var oc = caml_call1(openfun, s);
    function _c5_(param) { return caml_call1(f, oc) }
    return protect(function (param) { return close_noerr(oc) }, _c5_)
  }
  function with_open_bin$0(s, f) { return with_open$0(open_bin, s, f) }
  function with_open_text$0(s, f) { return with_open$0(open_text, s, f) }
  function with_open_gen$0(flags, perm, s, f) { return with_open$0(function (_c4_) { return open_gen(flags, perm, _c4_) }, s, f) }
  var
    seek$0 = _m_[1],
    pos$0 = _m_[2],
    length$12 = _m_[3],
    Stdlib_Out_channel =
      [0,
        stdout,
        stderr,
        open_bin,
        open_text,
        open_gen,
        with_open_bin$0,
        with_open_text$0,
        with_open_gen$0,
        seek$0,
        pos$0,
        length$12,
        close,
        close_noerr,
        flush,
        flush_all,
        output_char,
        output_byte,
        output_string,
        output_bytes,
        output,
        output_substring,
        set_binary_mode$0,
        runtime.caml_ml_set_buffered,
        runtime.caml_ml_is_buffered];
  caml_register_global(836, Stdlib_Out_channel, "Stdlib__Out_channel");
  return
}
  (globalThis));


var
  runtime = globalThis.jsoo_runtime,
  caml_output_value_to_bytes = runtime.caml_output_value_to_bytes;
function caml_call2(f, a0, a1) { return f.length == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]) }
var
  global_data = runtime.caml_get_global_data(),
  Stdlib_Marshal = global_data.Stdlib__Marshal,
  _a_ = [0, 1, 2, 3];
function marshal(v) { return caml_output_value_to_bytes(v, 0) }
function unmarshal(x) { return caml_call2(Stdlib_Marshal[4], x, 0) }
var
  s = caml_output_value_to_bytes(_a_, 0),
  v = unmarshal(s),
  Dune_exe_Marshal_test = [0, marshal, unmarshal, s, v];
runtime.caml_register_global
  (2, Dune_exe_Marshal_test, "Dune__exe__Marshal_test");


"use strict";
var runtime = globalThis.jsoo_runtime;
function caml_call1(f, a0) { return f.length == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]) }
var global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib;
caml_call1(Stdlib[103], 0);
var Std_exit = [0];
runtime.caml_register_global(1, Std_exit, "Std_exit");

let caml_read_file_content = runtime.caml_read_file_content
module.exports = {marshal, unmarshal, caml_read_file_content}
